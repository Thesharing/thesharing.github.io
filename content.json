{"pages":[{"title":"About Me","text":"ZhilongMaster of Engineering. TimeLine2018.08 参加DeeCamp夏令营 2017.06 在微软实习 - 2017.08 2016.12 参加 Hackathon Beijing 2016 2016.10 参加微软 Dev Asia 2016 黑客马拉松 - 三等奖 2016.08 参加微软学生夏令营 2016.05 “功夫道场”作为推荐项目参加校大学生创新实践实践展 2015.11 参加微软校园 Hackathon Now在写 DanmakuPie, 主写 Python, JavaScript 和 C#。 在追 Westworld, This is us, Modern Family, We Bare Bears。 在玩 Nintendo Switch。 偶尔会玩 Ingress, 属于 Resistance。 在看 一些奇奇怪怪的书，还有一堆技术书正在落灰。 热爱 《三体》和 The Song of Ice and Fire。","link":"/about/index.html"},{"title":"算法题","text":"Record of my solutions and thoughts to algorithm problems. LeetCode Problems Solutions Topic Difficulty 3 Longest Substring Without Repeating Characters C++ Hash Table Two Pointer Medium 5 Longest Palindromic Substring C++ Two Pointer Medium 6 ZigZag Conversion C++ String Medium 7 Reverse Integer C++ Math Easy 8 String to Integer (atoi) C++ String Simulation Medium 9 Palindrome Number C++ Math Easy 10 Regular Expression Matching C++ String Dynamic Programming Hard 11 Container With Most Water C++ Array Two Pointer Medium 12 Integer to Roman C++ Math HashMap Medium 13 Roman to Integer C++ Math HashMap Easy 14 Longest Common Prefix C++ String Easy 15 3Sum C++ Array Two Pointers Medium 16 3Sum Closest C++ Array Two Pointers Medium 17 Letter Combinations of a Phone Number C++ Array Backtracking Medium 19 Remove Nth Node From End of List C++ Linked List Two Pointers Medium 37 Sudoku Solver C++ Hard 51 N-Queens C++ Hard 100 Same Tree C++ Easy 709 To Lower Case C++ Easy 771 Jewels and Stones C++ Easy 929 Unique Email Address C++ Easy 961 N-Repeated Element in Size 2N Array C++ Easy POJCodes of Analysis of Algorithms Course","link":"/algorithms/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"9 Palindrome Number","text":"Hard Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'. 12&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3: 12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4: 12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5: 1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。 12&apos;.&apos; 匹配任意单个字符。&apos;*&apos; 匹配零个或多个前面的元素。 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: &apos;*&apos; 代表可匹配零个或多个前面的元素, 即可以匹配 &apos;a&apos; 。因此, 重复 &apos;a&apos; 一次, 字符串可变为 &quot;aa&quot;。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个(&apos;*&apos;)任意字符(&apos;.&apos;)。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: &apos;c&apos; 可以不被重复, &apos;a&apos; 可以被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 想法解12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public: bool isMatch(string s, string p) { if (p.size() &lt;= 0) { return s.size() &lt;= 0; } bool dp[s.size() + 1][p.size() + 1]; memset(dp, 0, sizeof(bool) * (s.size() + 1) * (p.size() + 1)); // Initialization dp[0][0] = true; // Check the situation \"#*#*#*#*#*#*#*\" for (int i = 0; i &lt; p.size(); i++) { if (p[i] == '*' &amp;&amp; dp[0][i - 1]) { dp[0][i + 1] = true; } } // dp[0][*] has been used, so dp[i+1][j+1] denotes s[i] &lt;==&gt; p[j] for (int i = 0; i &lt; s.size(); i++) { for (int j = 0; j &lt; p.size(); j++) { if (s[i] == p[j] || p[j] == '.') { dp[i + 1][j + 1] = dp[i][j]; } else if (p[j] == '*') { if (s[i] == p[j - 1] || p[j - 1] == '.') { dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j] || dp[i + 1][j - 1]; } else { dp[i + 1][j + 1] = dp[i + 1][j - 1]; } } } } return dp[s.size()][p.size()]; }};","link":"/algorithms/leetcode/10-regular-expression-matching.html"},{"title":"100 Same Tree","text":"Easy Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 1234567输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 1234567输入: 1 1 / \\ 2 2 [1,2], [1,null,2]输出: false 示例 3: 1234567输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]输出: false 想法难度不高，二叉树遍历。不过刚开始写的时候有点糊涂，弄错了很多边际条件，还写复杂了一点（判断子节点是否为空），后来改正。不过还有提升空间。 解1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool foundResult; bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL) { if (q == NULL) { return true; } else { return false; } } else if (q == NULL) { return false; } else if (p-&gt;val != q-&gt;val){ return false; } else { return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); } }};","link":"/algorithms/leetcode/100-Same-Tree.html"},{"title":"13 Roman to Integer","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: &quot;III&quot;输出: 3 示例 2: 12输入: &quot;IV&quot;输出: 4 示例 3: 12输入: &quot;IX&quot;输出: 9 示例 4: 123输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5: 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 想法按照规则来写就好，记录一下上一个值，如果小于当前值则减去两倍的上一个值（$cur+last$ –&gt; $cur - last$）即可。 解123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;class Solution { public: map&lt;char, int&gt; m = {{'M', 1000}, {'D', 500}, {'C', 100}, {'L', 50}, {'X', 10}, {'V', 5}, {'I', 1}}; int romanToInt(string s) { int last_value = 1000, cur_value = 1000, ans = 0; for (char &amp;ch : s) { cur_value = m[ch]; if (last_value &lt; cur_value) { ans = ans - 2 * last_value; } ans += cur_value; last_value = cur_value; } return ans; }};int main(void) { Solution s; string str; while(cin &gt;&gt; str) { cout &lt;&lt; s.romanToInt(str) &lt;&lt; endl; } return 0;}","link":"/algorithms/leetcode/13-roman-to-integer.html"},{"title":"12 Integer to Roman","text":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: 12Input: 3Output: &quot;III&quot; Example 2: 12Input: 4Output: &quot;IV&quot; Example 3: 12Input: 9Output: &quot;IX&quot; Example 4: 123Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3. Example 5: 123Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 12输入: 3输出: &quot;III&quot; 示例 2: 12输入: 4输出: &quot;IV&quot; 示例 3: 12输入: 9输出: &quot;IX&quot; 示例 4: 123输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例 5: 123输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 想法首先用一个map存储下来所有字母对应的数字，然后从大到小一边减一边输出即可。一个小Trick是把特殊情况（4和9、40和90、400和900）一起存在map里。 解1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution { public: string m[13] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"L\", \"XV\", \"V\", \"IV\", \"I\"}; int v[13] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; string intToRoman(int num) { string s; int cur = 0; while (num &gt; 0) { for (; cur &lt; 13; cur++) { if (num &gt;= v[cur]) { s += m[cur]; num -= v[cur]; break; } } } return s; }};int main(void){ Solution s; int input = 0; while (cin &gt;&gt; input) { cout &lt;&lt; s.intToRoman(input) &lt;&lt; endl; } return 0;}","link":"/algorithms/leetcode/12-integer-to-roman.html"},{"title":"11 Container With Most Water","text":"Medium Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). nvertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example: 12Input: [1,8,6,2,5,4,8,3,7]Output: 49 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 想法参考Solution做的……具体就是用双指针来扫描，从两端开始，如果$a_{left} &lt; a_{right}$则使左指针+1，若$a_{left} &gt; a_{right}​$则使右指针-1。证明在Solution里有…… 解12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution { public: int maxArea(vector&lt;int&gt; &amp;height) { int l = 0, r = height.size() - 1; int maxValue = 0; while (l &lt; r) { maxValue = max(maxValue, (r - l) * min(height[l], height[r])); if (height[l] &lt; height[r]) { l++; } else { r--; } } return maxValue; }};int main(void){ vector&lt;int&gt; v({1, 8, 6, 2, 5, 4, 8, 3, 7}); Solution s; cout &lt;&lt; s.maxArea(v) &lt;&lt; endl; return 0;}","link":"/algorithms/leetcode/11-container-with-most-water.html"},{"title":"14 Longest Common Prefix","text":"Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z.罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 想法从第一个字符串开始循环比对，如果字符不相同则缩短前缀长度，最终输出即可。 解1234567891011121314151617181920212223242526272829303132333435363738#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution { public: string longestCommonPrefix(vector&lt;string&gt; &amp;strs) { if (strs.size() &lt;= 0) { return \"\"; } else { string prefix = strs[0]; int index = prefix.size(); for (string &amp;s : strs) { for (int i = 0; i &lt; min(index, static_cast&lt;int&gt;(s.size())); i++) { if (prefix[i] != s[i]) { index = i; break; } } index = min(index, static_cast&lt;int&gt;(s.size())); } return prefix.substr(0, index); } }};int main(void){ Solution s; vector&lt;string&gt; strs = {\"aa\", \"a\"}; cout &lt;&lt; s.longestCommonPrefix(strs) &lt;&lt; endl; return 0;}","link":"/algorithms/leetcode/14-longest-common-prefix.html"},{"title":"19 Remove Nth Node From End of List","text":"Given a linked list, remove the n-th node from the end of list and return its head. Example: 123Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 想法快慢指针，快指针指向第K个节点，慢指针指向开始节点，当快指针到达末尾时慢指针正好指向倒数第K的节点。由于要删除该节点，还得记录慢指针的上一个节点。Corner Case：传入参数为空、删除的是头节点、K大于链表长度。 解12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution { public: ListNode *removeNthFromEnd(ListNode *head, int n) { if (head == NULL) { return head; } ListNode *cur = head, *ans = head, *last = NULL; int i = n - 1; while (cur-&gt;next != NULL) { if (i &lt;= 0) { last = ans; ans = ans-&gt;next; } else { i--; } cur = cur-&gt;next; } if (last == NULL) { ListNode *temp = head; head = head-&gt;next; delete (temp); } else { last-&gt;next = ans-&gt;next; delete (ans); } return head; }};","link":"/algorithms/leetcode/19-remove-nth-node-from-end-of-list.html"},{"title":"17 Letter Combinations of a Phone Number","text":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: 12Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 12输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 想法首先用数组或者map存下来数字和字母的对应关系，然后循环+DFS逐位组合字符即可，实际上这道题和求全排列没有什么区别…… 解12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution { public: char letter[10][5] = {\" \", \"*\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; ans; if (digits.size() &lt;= 0) { return ans; } string s; dfs(ans, s, digits, 0); return ans; } void dfs(vector&lt;string&gt; &amp;ans, string &amp;s, const string &amp;digits, int pos) { if (pos &gt;= digits.size()) { ans.push_back(s); return; } else { int loc = digits[pos] - '0'; for (int i = 0; letter[loc][i] != '\\0'; i++) { s.push_back(letter[loc][i]); dfs(ans, s, digits, pos + 1); s.pop_back(); } } }};int main(void){ Solution s; vector&lt;string&gt; ans = s.letterCombinations(\"\"); for (string s : ans) { cout &lt;&lt; s &lt;&lt; endl; } return 0;}","link":"/algorithms/leetcode/17-letter-combinations-of-a-phone-number.html"},{"title":"15 3 Sum","text":"Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: 1234567Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 想法思路就是固定一个值然后寻找其他两个值的和与第一个值互为相反数即可。对于乱序数组来说只能通过遍历来找和，那么复杂度是$O(n^2)$，因此可以先排序再用双指针（头和尾各一个）查找，复杂度是$O(n \\log{n})$。对于双指针来说，如果$(b+c) &gt; -a$ 说明$c$过大，右指针左移；如果$(b+c) &lt; -a$说明$b$过小，左指针右移。 解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) { vector&lt;vector&lt;int&gt;&gt; ans; sort(nums.begin(), nums.end()); if (nums.size() &lt; 3) { return ans; } for (int i = 0; i &lt; nums.size() - 2; i++) { if (i == 0 || i &gt; 0 &amp;&amp; nums[i] != nums[i - 1]) { int left = i + 1, right = nums.size() - 1, sum = -nums[i]; while (left &lt; right) { if (nums[left] + nums[right] == sum) { ans.push_back(vector&lt;int&gt;({nums[i], nums[left], nums[right]})); while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) { right--; } left++; right--; } else if (nums[left] + nums[right] &lt; sum) { left++; } else { right--; } } } } return ans; }};int main(void){ Solution s; vector&lt;int&gt; m = {-1, 0, 1}; for (auto v : s.threeSum(m)) { for (auto i : v) { cout &lt;&lt; i &lt;&lt; ' '; } cout &lt;&lt; endl; }; return 0;}","link":"/algorithms/leetcode/15-3-sum.html"},{"title":"16 3Sum Closest","text":"Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: 123Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 想法实际上和15. 3 Sum比较相似，只不过在原先是判断和是否等于0，这个需要记录三个数和目标值的差值的最小值最后返回即可。注意比较差值时需要比较绝对值。 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Solution { public: int threeSumClosest(vector&lt;int&gt; &amp;nums, int target) { sort(nums.begin(), nums.end()); int closest = INT_MAX; int sum = 0; for (int i = 0; i &lt; nums.size() - 2; i++) { int left = i + 1, right = nums.size() - 1, diff = 0; while (left &lt; right) { diff = nums[left] + nums[right] + nums[i] - target; if (abs(diff) &lt; closest) { closest = abs(diff); sum = diff + target; } if (diff &lt; 0) { while (left + 1 &lt; right &amp;&amp; nums[left] == nums[left + 1]) { left++; } left++; } else if (diff &gt; 0) { while (right - 1 &gt; left &amp;&amp; nums[right] == nums[right - 1]) { right--; } right--; } else { return sum; } } } return sum; }};int main(void){ Solution s; vector&lt;int&gt; nums = {1, 1, 1}; int target = 1; cout &lt;&lt; s.threeSumClosest(nums, target) &lt;&lt; endl; return 0;}","link":"/algorithms/leetcode/16-3-sum-closest.html"},{"title":"37 Sudoku Solver","text":"Hard Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character '.'. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。 一个数独。 答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 '.' 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 想法这道题想了好久，最后看了网上的答案（sigh），总结了一下，基本就是HashMap+DFS，首先用三个数组存储数独中每一行、每一列、每一个方块中数字的占用情况，然后用回溯法DFS遍历一遍即可。要注意方块的计算公式为$i / 3 \\times 3 + j / 3$。写的过程中遇到好多笔误，调了很多遍才能跑通（sigh）。 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;bool row[9][9];bool column[9][9];bool box[9][9];bool done;void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j){ if (i &gt; 8) { done = true; return; } if (board[i][j] == '.') { for (int n = 0; n &lt; 9; n++) { if (!(row[i][n] || column[j][n] || box[(i / 3) * 3 + j / 3][n])) { board[i][j] = n + '1'; row[i][n] = column[j][n] = box[(i / 3) * 3 + j / 3][n] = true; if (j &gt;= 8) { dfs(board, i + 1, 0); } else { dfs(board, i, j + 1); } if (done) break; board[i][j] = '.'; row[i][n] = column[j][n] = box[(i / 3) * 3 + j / 3][n] = false; } } } else { if (j &gt;= 8) { dfs(board, i + 1, 0); } else { dfs(board, i, j + 1); } }}void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board){ memset(row, 0, 9 * 9 * sizeof(bool)); memset(column, 0, 9 * 9 * sizeof(bool)); memset(box, 0, 9 * 9 * sizeof(bool)); done = false; int num = 0; //Initialize for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { num = board[i][j] - '1'; row[i][num] = true; column[j][num] = true; box[(i / 3) * 3 + j / 3][num] = true; } } } dfs(board, 0, 0);}","link":"/algorithms/leetcode/37-sudoku-solver.html"},{"title":"3 Longest Substring Without Repeating Characters","text":"Medium Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 想法这道题一方面可以直接用双指针去遍历，复杂度基本为$O(n)$，另一方面可以用一个Trick：通过记录字符最后出现的位置，当出现重复字符的时候将左指针直接跳转至重复字符最后出现的位置而非不断+1，这样虽然复杂度不变，但是计算次数变少。 解123456789101112131415class Solution { public: int lengthOfLongestSubstring(string s) { int index[300]; memset(index, 0, sizeof(int) * 300); int ans = 0; for (int i = 0, j = 0; j &lt; s.size(); j++) { i = max(i, index[s[j]]); ans = max(ans, j - i + 1); index[s[j]] = j + 1; } return ans; }};","link":"/algorithms/leetcode/3-longest-substring-without-repeating-characters.html"},{"title":"5 Longest Palindromic Substring","text":"Medium Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: 123Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: 12Input: &quot;cbbd&quot;Output: &quot;bb&quot; 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 想法这道题……想了一段时间，感觉最近做题速度好慢。实际上就是遍历每一个字符判断$s[i -j] == s[i+j]$和$s[i-j]==s[i+j+1]​$也就是中间有一个字符和中间没有字符这两种情况是否成立。WA了一次，因为忘记在不成立的时候break掉了…… 不过这个算法的复杂度是$O(n^2)$，有一个很有意思的算法Manacher‘s Algorithm复杂度是$O(n)$也就是线性复杂度，准备有时间好好看一下…… https://www.cnblogs.com/grandyang/p/4475985.html https://www.cnblogs.com/schaepher/p/6543605.html https://www.zhihu.com/question/37289584 https://www.geeksforgeeks.org/manachers-algorithm-linear-time-longest-palindromic-substring-part-1/ 解12345678910111213141516171819202122232425262728293031class Solution { public: string longestPalindrome(string s) { int l = 0, max = 0; int n = s.size(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt;= min(i, n - 1 - i); j++) { if (s[i - j] == s[i + j]) { if (max &lt; 2 * j + 1) { l = i - j; max = 2 * j + 1; } } else break; } for (int j = 0; j &lt;= min(i, n - 2 - i); j++) { if (s[i - j] == s[i + j + 1]) { if (max &lt; 2 * (j + 1)) { l = i - j; max = 2 * (j + 1); } } else break; } } return string(s, l, max); }};","link":"/algorithms/leetcode/5-longest-palindromic-substring.html"},{"title":"51 N-Queens","text":"Hard The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens’ placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: 12345678910111213Input: 4Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例: 12345678910111213输入: 4输出: [ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 想法经典的八皇后，DFS和递归的典范。这道题最让我纠结的部分在于： 要不要考虑旋转……（事实证明不需要） 如何初始化vector&lt;string&gt; std::vector::vector的构造函数里有这么一条： 12345678explicit vector( size_type count, const T&amp; value = T(), const Allocator&amp; alloc = Allocator());(until C++11) vector( size_type count, const T&amp; value, const Allocator&amp; alloc = Allocator());(since C++11) 也就是说可以通过vector v(count, value);来初始化vector&lt;string&gt;，同样的，string也支持这一构造函数，因此，通过vector&lt;string&gt; board(n, string(n, '.'));就可以初始化vector&lt;string&gt;了。 其实还可以考虑一下怎么不用递归写……大体用个队列也是可行的吧…… 最后就是算行列斜线标记那一点花了一点时间，还遇到小bug……注意左斜列是$n + y - x -1$，右斜列是$x+y$。 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void dfs(int n, int depth, vector&lt;vector&lt;string&gt;&gt; &amp;res, vector&lt;string&gt; &amp;board, vector&lt;bool&gt; &amp;row, vector&lt;bool&gt; &amp;column, vector&lt;bool&gt; &amp;rightX, vector&lt;bool&gt; &amp;leftX){ if (depth &gt;= n) { res.push_back(vector&lt;string&gt;(board)); } else { for (int index = 0; index &lt; n; index++) { if (row[index] &amp;&amp; column[depth] &amp;&amp; rightX[index + depth] &amp;&amp; leftX[depth - index + n - 1]) { row[index] = column[depth] = rightX[index + depth] = leftX[depth - index + n - 1] = false; board[index][depth] = 'Q'; dfs(n, depth + 1, res, board, row, column, rightX, leftX); board[index][depth] = '.'; row[index] = column[depth] = rightX[index + depth] = leftX[depth - index + n - 1] = true; } } }}vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n){ vector&lt;vector&lt;string&gt;&gt; res; vector&lt;string&gt; board(n, string(n, '.')); vector&lt;bool&gt; row(n, true); vector&lt;bool&gt; column(n, true); vector&lt;bool&gt; rightX(2 * n - 1, true); vector&lt;bool&gt; leftX(2 * n - 1, true); dfs(n, 0, res, board, row, column, rightX, leftX); return res;}int main(void){ vector&lt;vector&lt;string&gt;&gt; res = solveNQueens(8); int count = 0; for (vector&lt;string&gt; v : res) { cout &lt;&lt; \"Case\" &lt;&lt; ++count &lt;&lt; \":\" &lt;&lt; endl; for (string s : v) { cout &lt;&lt; s &lt;&lt; endl; } } return 0;}","link":"/algorithms/leetcode/51-n-queens.html"},{"title":"6 ZigZag Conversion","text":"Medium The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) 123P A H NA P L S I I GY I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows: 1string convert(string s, int numRows); Example 1: 12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2: 12345678Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： 123L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 请你实现这个将字符串进行指定行数变换的函数： 1string convert(string s, int numRows); 示例 1: 12输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 12345678输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot;解释:L D RE O E I IE C I H NT S G 想法这道题是在听宣讲会的时候做的，想的时间有点长😂，其实就是根据位置拼字符即可。只不过需要判断一下几个边界条件： 只有一行； 最后一行不满，需要判断长度； 算源字符的位置的时候要算快一点了。 解12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;climits&gt;using namespace std;string convert(string s, int numRows){ int m = numRows &gt; 1 ? numRows * 2 - 2 : 1; int len = s.size(); string ans; for (int i = 0; i &lt; numRows; i++) { for (int j = 0; j &lt; (len + m - 1) / m; j++) { if (j * m + i &lt; len) { ans.push_back(s[j * m + i]); int q = j * m + m - i; if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; q &lt; len) { ans.push_back(s[q]); } } } } return ans;}int main(void){ cout &lt;&lt; INT_MAX &lt;&lt; ' ' &lt;&lt; INT_MIN &lt;&lt; endl; cout &lt;&lt; convert(\"PAYPALISHIRING\", 1) &lt;&lt; endl; return 0;}","link":"/algorithms/leetcode/6-zig-zag-conversion.html"},{"title":"771 Jewels and Stones","text":"Easy You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。 J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此&quot;a&quot;和&quot;A&quot;是不同类型的石头。 示例 1: 12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 注意: S 和 J 最多含有50个字母。 J 中的字符不重复。 想法第一感觉是两重循环，遍历S的每一个字符，寻找J里面有没有相同的字符，复杂度是$O(n^2)$。后来想了一下，不需要这么高的复杂度，只需要用一个bool数组把字符是否出现存下来就行。复杂度降至$O(n)$。 解123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int numJewelsInStones(string J, string S){ if (J.length() == 0 || S.length() == 0) { return 0; } int ptr[52]; int temp = 0; int res = 0; memset(ptr, 0, sizeof(int) * 52); for (char &amp;c : J) { temp = int(c); if (temp &gt; 96) { ptr[temp - 71] = 1; } else { ptr[temp - 65] = 1; } } for (char &amp;c : S) { temp = int(c); if (temp &gt; 96) { if (ptr[temp - 71] == 1) { res += 1; } } else if(ptr[temp - 65] == 1) { res += 1; } } return res;}int main(void){ cout &lt;&lt; numJewelsInStones(\"aA\", \"aAAbbbb\") &lt;&lt; endl; cout &lt;&lt; endl;}","link":"/algorithms/leetcode/771-Jewels-and-Stones.html"},{"title":"709 To Lower Case","text":"Easy Example 1: 12Input: &quot;Hello&quot;Output: &quot;hello&quot; Example 2: 12Input: &quot;here&quot;Output: &quot;here&quot; Example 3: 12Input: &quot;LOVELY&quot;Output: &quot;lovely&quot; 实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。 示例 1： 12输入: &quot;Hello&quot;输出: &quot;hello&quot; 示例 2： 12输入: &quot;here&quot;输出: &quot;here&quot; 示例 3： 12输入: &quot;LOVELY&quot;输出: &quot;lovely&quot; 想法两种方式，一种是遍历字符按照ASCII大写变小写即可。另一种是利用C++的内置函数tolower()。不过由于int std::tolower ( int c );的输入是字符，因此需要用std::transform()来进行处理。 12OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op) std::transform 简单的程序诠释C++ STL算法系列之十八：transform tolower How to convert std::string to lower case? Why can’t “transform(s.begin(),s.end(),s.begin(),tolower)” be complied successfully? 解1234567class Solution {public: string toLowerCase(string str) { transform(str.begin(), str.end(), str.begin(), ::tolower); return str; }};","link":"/algorithms/leetcode/709-To-Lower-Case.html"},{"title":"7 Reverse Integer","text":"Easy Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $[−2^{31}, 2^{31} − 1]$. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[−2^{31}, 2^{31} − 1]​$。请根据这个假设，如果反转后整数溢出那么就返回 0。 想法这道题是一道Easy题，但是我RE两次+WA一次……这道题有一个很重要的边界条件要考虑： 可能会溢出。为了防止溢出，官方Solution指出可以借助 12if (rev &gt; INT_MAX/10 || (rev == INT_MAX / 10 &amp;&amp; pop &gt; 7)) return 0;if (rev &lt; INT_MIN/10 || (rev == INT_MIN / 10 &amp;&amp; pop &lt; -8)) return 0; 来判断是否溢出，简而言之就是通过$rev &gt; \\frac{INT_MAX}{10}$ or ($rev=\\frac{INT_MAX}{10}$ and $pop &gt; 7$)来判断上溢出（因为INT_MAX=2147483647），通过$rev&lt;\\frac{INT_MIN}{10}$ or ($rev=\\frac{INT_MIN}{10}$ and $pop&lt; -8​$)来判断下溢出（因为INT_MIN=-2147483648）。 值得注意的是INT_MAX和INT_MIN的绝对值不一样，所以要是取绝对值最后结果再根据Input取正负的话，-2147483648就会出错。 解1234567891011121314151617class Solution {public: int reverse(int x) { bool sign = (x &gt;= 0); long num = x; num = sign ? num : -num; long ans = 0; while (num &gt; 0) { ans = ans * 10 + num % 10; if (ans &gt; INT_MAX) { return 0; } num /= 10; } return sign ? ans : -ans; }};","link":"/algorithms/leetcode/7-reverse-integer.html"},{"title":"8 String to Integer (atoi)","text":"Medium Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ' ' is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: $ [−2^{31}, 2^{31} − 1]$. If the numerical value is out of the range of representable values, INT_MAX ($2^{31}-1$) or INT_MIN ($−2^{31}$) is returned. Example 1: 12Input: &quot;42&quot;Output: 42 Example 2: 1234Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is &apos;-&apos;, which is the minus sign. Then take as many numerical digits as possible, which gets 42. Example 3: 123Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit &apos;3&apos; as the next character is not a numerical digit. Example 4: 1234Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is &apos;w&apos;, which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed. Example 5: 1234Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−231) is returned. 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为$ [−2^{31}, 2^{31} − 1]​$。如果数值超过这个范围，请返回 INT_MAX ($2^{31} − 1​$) 或 INT_MIN $(−2^{31})​$ 。 示例 1: 12输入: &quot;42&quot;输出: 42 示例 2: 1234输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 123输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4: 1234输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 1234输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 想法这道题用自动机做的，直接模拟状态走一遍就行…… 就是没想到还有+号的存在…… 解12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;climits&gt;using namespace std;string convert(string s, int numRows){ int m = numRows &gt; 1 ? numRows * 2 - 2 : 1; int len = s.size(); string ans; for (int i = 0; i &lt; numRows; i++) { for (int j = 0; j &lt; (len + m - 1) / m; j++) { if (j * m + i &lt; len) { ans.push_back(s[j * m + i]); int q = j * m + m - i; if (i != 0 &amp;&amp; i != numRows - 1 &amp;&amp; q &lt; len) { ans.push_back(s[q]); } } } } return ans;}int main(void){ cout &lt;&lt; INT_MAX &lt;&lt; ' ' &lt;&lt; INT_MIN &lt;&lt; endl; cout &lt;&lt; convert(\"PAYPALISHIRING\", 1) &lt;&lt; endl; return 0;}","link":"/algorithms/leetcode/8-string-to-integer-atoi.html"},{"title":"9 Palindrome Number","text":"Easy Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up: Coud you solve it without converting the integer to a string? 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 想法考虑边界条件即可。用了一个数组把所有数字全部存储下来，然后一一对比即可。还可以考虑一下不存储怎么做。 解123456789101112131415161718192021class Solution { public: bool isPalindrome(int x) { if (x &lt; 0) { return false; } int num[20]; int length = 0; while (x &gt; 0) { num[length++] = x % 10; x /= 10; } for (int i = 0; i &lt; length / 2; i++) { if (num[i] != num[length - 1 - i]) { return false; } } return true; }};","link":"/algorithms/leetcode/9-palindrome-number.html"},{"title":"929 Unique Email Addresses","text":"Easy Every email consists of a local name and a domain name, separated by the @ sign. For example, in `alice@leetcode.com,aliceis the local name, andleetcode.com` is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example `m.y+name@email.comwill be forwarded tomy@email.com`. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one '@' character. 每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。 例如，在 `alice@leetcode.com中，alice是本地名称，而leetcode.com` 是域名。 除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。 如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，&quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。） 如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 `m.y+name@email.com将转发到my@email.com`。 （同样，此规则不适用于域名。） 可以同时使用这两个规则。 给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？ 示例： 123输入：[&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]输出：2解释：实际收到邮件的是 &quot;testemail@leetcode.com&quot; 和 &quot;testemail@lee.tcode.com&quot;。 提示： 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 每封 emails[i] 都包含有且仅有一个 '@' 字符。 想法一开始看题目这么长有点懵，后面整理一下思路就是遍历一遍按照状态机得到结果即可。主要是注意C++中vector的遍历以及string的遍历。 vector的遍历： 1for (vector&lt;string&gt;::iterator it = v.begin(); it != v.end(); it++) {} string的遍历： 1for(char &amp;c : *ch) {} 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) { vector&lt;string&gt; res; for (vector&lt;string&gt;::iterator it = emails.begin(); it != emails.end(); it++) { string s = \"\"; bool localname = true; bool afterplus = false; for (char &amp;c : *it) { switch (c) { case '@': localname = false; s += c; break; case '.': if (!localname) { s += c; } break; case '+': if (localname) { afterplus = true; } else { s += c; } break; default: if (!localname || !afterplus) { s += c; } } } bool equal = false; for (vector&lt;string&gt;::iterator it2 = res.begin(); it2 != res.end(); it2++) { if(s == *it2) { equal = true; break; } } if (!equal) { res.push_back(s); } } return res.size(); }};","link":"/algorithms/leetcode/929-Unique-Email-Addresses.html"},{"title":"961 N-Repeated Element in Size 2N Array","text":"Easy In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: 12Input: [1,2,3,3]Output: 3 Example 2: 12Input: [2,1,2,5,3,2]Output: 2 Example 3: 12Input: [5,1,5,2,5,3,5,4]Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 想法每次都把一个不难的题弄得很难，sigh 实际上就是用set查重，值得注意的是C++里set是用红黑树实现的。 最后就是Range-based for loop，C++11的新特性： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5}; for (const int&amp; i : v) // access by const reference std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (auto i : v) // access by value, the type of i is int std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (auto&amp;&amp; i : v) // access by forwarding reference, the type of i is int&amp; std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; const auto&amp; cv = v; for (auto&amp;&amp; i : cv) // access by f-d reference, the type of i is const int&amp; std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (int n : {0, 1, 2, 3, 4, 5}) // the initializer may be a braced-init-list std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; int a[] = {0, 1, 2, 3, 4, 5}; for (int n : a) // the initializer may be an array std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (int n : a) std::cout &lt;&lt; 1 &lt;&lt; ' '; // the loop variable need not be used std::cout &lt;&lt; '\\n'; } 解123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int repeatedNTimes(vector&lt;int&gt; &amp;A){ set&lt;int&gt; m; for (vector&lt;int&gt;::iterator it = A.begin(); it != A.end(); it++) { if (m.find(*it) != m.end()) { return *it; } else { m.insert(*it); } }} 不过有个更好的做法，在LeetCode上看到的： 123456789101112class Solution {public: int repeatedNTimes(vector&lt;int&gt;&amp; A) { unordered_set&lt;int&gt; seen; for (int a: A) { if (seen.count(a)) return a; seen.insert(a); } return 0; }};","link":"/algorithms/leetcode/961-n-repeated-element-in-size-2-n-array.html"},{"title":"","text":"玛雅历描述上周末，M.A. Ya教授对古老的玛雅有了一个重大发现。从一个古老的节绳（玛雅人用于记事的工具）中，教授发现玛雅人使用了一个一年有365天的叫做Haab的历法。这个Haab历法拥有19个月，在开始的18个月，一个月有20天，月份的名字分别是pop, no, zip, zotz, tzec, xul, yoxkin, mol, chen, yax, zac, ceh, mac, kankin, muan, pax, koyab, cumhu。这些月份中的日期用0到19表示。Haab历的最后一个月叫做uayet，它只有5天，用0到4表示。玛雅人认为这个日期最少的月份是不吉利的，在这个月法庭不开庭，人们不从事交易，甚至没有人打扫屋中的地板。 因为宗教的原因，玛雅人还使用了另一个历法，在这个历法中年被称为Tzolkin(holly年)，一年被分成13个不同的时期，每个时期有20天，每一天用一个数字和一个单词相组合的形式来表示。使用的数字是1~13，使用的单词共有20个，它们分别是：imix, ik, akbal, kan, chicchan, cimi, manik, lamat, muluk, ok, chuen, eb, ben, ix, mem, cib, caban, eznab, canac, ahau。注意：年中的每一天都有着明确唯一的描述，比如，在一年的开始，日期如下描述： 1 imix, 2 ik, 3 akbal, 4 kan, 5 chicchan, 6 cimi, 7 manik, 8 lamat, 9 muluk, 10 ok, 11 chuen, 12 eb, 13 ben, 1 ix, 2 mem, 3 cib, 4 caban, 5 eznab, 6 canac, 7 ahau, ，8 imix, 9 ik, 10 akbal ……也就是说数字和单词各自独立循环使用。Haab历和Tzolkin历中的年都用数字0，1，……表示，数字0表示世界的开始。所以第一天被表示成：Haab: 0. pop 0Tzolkin: 1 imix 0请帮助M.A. Ya教授写一个程序可以把Haab历转化成Tzolkin历。 输入Haab历中的数据由如下的方式表示：日期. 月份 年数输入中的第一行表示要转化的Haab历日期的数据量。下面的每一行表示一个日期，年数小于5000。 输出Tzolkin历中的数据由如下的方式表示：天数字 天名称 年数第一行表示输出的日期数量。下面的每一行表示一个输入数据中对应的Tzolkin历中的日期。 样例输入1234310. zac 00. pop 010. zac 1995 样例输出123433 chuen 01 imix 09 cimi 2801 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int convertMonthToInt(char str[], char habb[][10]){ int res = -1; for (int i = 0; i &lt; 19; i++){ if (strcmp(str, habb[i]) == 0) { res = i; } } return res;}int main(void){ char habb[19][10] = {\"pop\", \"no\", \"zip\", \"zotz\", \"tzec\", \"xul\", \"yoxkin\", \"mol\", \"chen\", \"yax\", \"zac\", \"ceh\", \"mac\", \"kankin\", \"muan\", \"pax\", \"koyab\", \"cumhu\", \"uayet\"}; char tzolkin[20][10] = {\"imix\", \"ik\", \"akbal\", \"kan\", \"chicchan\", \"cimi\", \"manik\", \"lamat\", \"muluk\", \"ok\", \"chuen\", \"eb\", \"ben\", \"ix\", \"mem\", \"cib\", \"caban\", \"eznab\", \"canac\", \"ahau\"}; int count; cin &gt;&gt; count; cout &lt;&lt; count &lt;&lt; endl; char dayStr[10]; int day; char monthStr[10]; int month; int year; for (int i = 0; i &lt; count; i++){ cin &gt;&gt; dayStr &gt;&gt; monthStr &gt;&gt; year; dayStr[strlen(dayStr) - 1] = 0; day = atoi(dayStr); month = convertMonthToInt(monthStr, habb); int totalDay = year * 365 + month * 20 + day; int newYear = totalDay / 260; int dayOfYear = totalDay % 260; int newMonth = dayOfYear % 13 + 1; int newDay = dayOfYear % 20; cout &lt;&lt; newMonth &lt;&lt; ' ' &lt;&lt; tzolkin[newDay] &lt;&lt; ' ' &lt;&lt; newYear &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/1-A 玛雅历.html"},{"title":"","text":"Til the Cows Come Home描述Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible.Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists. 输入 Line 1: Two integers: T and N Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100. 输出 Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1. 样例输入1234565 51 2 202 3 303 4 204 5 201 5 100 样例输出190 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int map[1000][1000];int d[1000];bool final[1000];int main (void){ memset(map, 0b01111111, 1000 * 1000 * sizeof(int)); int MAX = map[0][0]; int t, n; cin &gt;&gt; t &gt;&gt; n; int x, y, value; // Input for (int i = 0; i &lt; t; i++){ cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; value; // HERE: The road may be duplicate. if (value &lt; map[x - 1][y - 1]) { map[x - 1][y - 1] = value; map[y - 1][x - 1] = value; } } // Dijkstra Algorithm for (int i = 0; i &lt; n; i++){ final[i] = false; d[i] = map[0][i]; } d[0] = 0; final[0] = true; for(int i = 1; i &lt; n; i++){ int min = MAX; int v = 0; for (int w = 0; w &lt; n; w++){ if(!final[w]){ if(d[w] &lt; min){ v = w; min = d[w]; } } } final[v] = true; for(int w = 0; w &lt; n; w++){ if(!final[w] &amp;&amp; (min + map[v][w] &lt; d[w])){ d[w] = min + map[v][w]; } } } cout &lt;&lt; d[n - 1] &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/1-C Til the Cows Come Home.html"},{"title":"","text":"棋盘问题描述在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 样例输入1234567892 1#..#4 4...#..#..#..#...-1 -1 样例输出1221 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;long cal(char map[][9], int col[], int row[], int n, int k, int i){ if (k == 0){ return 1; } long res = 0; for (int a = i; a &lt;= n - k; a ++){ for (int b = 0; b &lt; n; b ++){ if (map[a][b] == '#' &amp;&amp; col[a] != 1 &amp;&amp; row[b] != 1){ col[a] = 1; row[b] = 1; res += cal(map, col, row, n, k - 1, a + 1); col[a] = 0; row[b] = 0; } } } return res;}int main(void){ char map[9][9]; int n, k; cin &gt;&gt; n &gt;&gt; k; while(n != -1 &amp;&amp; k != -1){ for(int i = 0; i &lt; n; i++){ cin &gt;&gt; map[i]; } int col[8] = {0}; int row[8] = {0}; cout &lt;&lt; cal(map, col, row, n, k, 0) &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; k; } }","link":"/algorithms/POJ/course/1-B 棋盘问题.html"},{"title":"","text":"仙岛求药描述少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由M×N个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。下图 显示了一个迷阵的样例及李逍遥找到仙药的路线 输入输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始，两者均不大于20。M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含N个字符,不同字符分别代表不同含义:1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。当在一行中读入的是两个零时，表示输入结束。 输出对于每组测试数据，分别输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 -1。 样例输入1234567891011121314151617181920212223242526278 8.@##...##....#.##.#.##....#.###.#.#...#...###.#....#.*...#...###6 5.*.#..#.....##.......#.......@9 6.#..#. .#.*.# .####. ..#... ..#... ..#... ..#... #.@.## .#..#. 0 0 样例输出123108-1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;queue&gt; using namespace std;struct pos{ int x; int y; int layer;};int main (void){ int m, n; cin &gt;&gt; m &gt;&gt; n; char map[20][20]; while(m != 0 &amp;&amp; n != 0){ queue&lt;pos&gt; q; bool res = false; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; map[i]; for(int j = 0; j &lt; n; j++){ if (map[i][j] == '@'){ struct pos p = {i, j, 0}; q.push(p); } } } while(q.size() &gt; 0){ struct pos p = q.front(); q.pop(); if(p.x - 1 &gt;= 0){ if (map[p.x - 1][p.y] == '.'){ struct pos t = {p.x - 1, p.y, p.layer + 1}; q.push(t); } else if(map[p.x - 1][p.y] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.y + 1 &lt; n){ if (map[p.x][p.y + 1] == '.'){ struct pos t = {p.x, p.y + 1, p.layer + 1}; q.push(t); } else if(map[p.x][p.y + 1] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.y - 1 &gt;= 0){ if (map[p.x][p.y - 1] == '.'){ struct pos t = {p.x, p.y - 1, p.layer + 1}; q.push(t); } else if(map[p.x][p.y - 1] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.x + 1 &lt; m){ if (map[p.x + 1][p.y] == '.'){ struct pos t = {p.x + 1, p.y, p.layer + 1}; q.push(t); } else if(map[p.x + 1][p.y] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } map[p.x][p.y] = '!'; } if(!res) { cout &lt;&lt; -1 &lt;&lt; endl; } cin &gt;&gt; m &gt;&gt; n; } return 0;}","link":"/algorithms/POJ/course/1-D 仙岛求药.html"},{"title":"","text":"1-E 二叉树的操作描述给定一棵二叉树，在二叉树上执行两个操作： 节点交换把二叉树的两个节点交换。 前驱询问询问二叉树的一个节点对应的子树最左边的节点。 输入第一行输出一个整数t(t &lt;= 100)，代表测试数据的组数。对于每组测试数据，第一行输入两个整数n m，n代表二叉树节点的个数，m代表操作的次数。随后输入n行，每行包含3个整数X Y Z，对应二叉树一个节点的信息。X表示节点的标识，Y表示其左孩子的标识，Z表示其右孩子的标识。再输入m行，每行对应一次操作。每次操作首先输入一个整数type。当type=1，节点交换操作，后面跟着输入两个整数x y，表示将标识为x的节点与标识为y的节点交换。输入保证对应的节点不是祖先关系。当type=2，前驱询问操作，后面跟着输入一个整数x，表示询问标识为x的节点对应子树最左的孩子。1&lt;=n&lt;=100，节点的标识从0到n-1，根节点始终是0.m&lt;=100 输出对于每次询问操作，输出相应的结果。 样例输入12345678910111213141516171825 50 1 21 -1 -12 3 43 -1 -14 -1 -12 01 1 22 01 3 42 23 20 1 21 -1 -12 -1 -11 1 22 0 样例输出12341342 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;using namespace std;struct node { int parent; int left; int right;};void swap(int a, int b, struct node tree[]){ // Parent if(tree[a].parent == tree[b].parent){ if(tree[tree[a].parent].left == a){ tree[tree[a].parent].left = b; tree[tree[a].parent].right = a; } else{ tree[tree[a].parent].right = b; tree[tree[a].parent].left = a; } } else{ if(tree[tree[a].parent].left == a){ tree[tree[a].parent].left = b; } else{ tree[tree[a].parent].right = b; } int temp = tree[a].parent; tree[a].parent = tree[b].parent; if(tree[tree[b].parent].left == b){ tree[tree[b].parent].left = a; } else { tree[tree[b].parent].right = a; } tree[b].parent = temp; }}int check(int p, struct node tree[]){ while(tree[p].left != -1){ p = tree[p].left; } return p;}void output(struct node tree[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; \"Tree: \" &lt;&lt; i &lt;&lt; \" Left: \" &lt;&lt; tree[i].left &lt;&lt; \" Right: \" &lt;&lt; tree[i].right &lt;&lt; \" Parent: \" &lt;&lt; tree[i].parent &lt;&lt; endl; }}int main (void){ struct node tree[100]; int group; cin &gt;&gt; group; for(int g = 0; g &lt; group; g++){ int n, m; cin &gt;&gt; n &gt;&gt; m; tree[0].parent = -1; int tag, left, right; for(int i = 0; i &lt; n; i++){ cin &gt;&gt; tag &gt;&gt; left &gt;&gt; right; tree[tag].left = left; tree[tag].right = right; tree[left].parent = tag; tree[right].parent = tag; } int type; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; type; if(type == 1){ int a, b; cin &gt;&gt; a &gt;&gt; b; swap(a, b, tree); } else if(type == 2){ int p; cin &gt;&gt; p; cout &lt;&lt; check(p, tree) &lt;&lt; endl; } } } return 0;}","link":"/algorithms/POJ/course/1-E 二叉树的操作.html"},{"title":"","text":"Butterfly描述有一群旅行爱好者，有一天，他们带回了n只蝴蝶回来。他们相信每一只都属于两个不同种类中的一种，为了讨论方便，我们称它们为A与B。他们想把n只标本分成两组——一些属于A且一些属于B——但是直接标记任何一个标本对于他们是非常困难，因此他们决定采用下面的方法。 对每对标本i和j，他们细心地把它们放到一起研究。如果他们以自己的判断足以确信，那么他们把这对蝴蝶标记为“相同”（这意味着他们相信这两只来自同一类）或者是“不同”（这意味着他们相信这两只来自不同的类）。他们也可以对某些标本判断不出来而弃权，在这种情况下，我们称这对标本是不明确的。 现在他们有n只标本的集合，还有对那些没有弃权的标本对的m个判断的集合（“相同”或者“不同”）。他们想知道这个数据与每只蝴蝶来自A和B中的一个类的想法是否一致。更具体地说，如果对每对蝴蝶按照下述方式标记A或B是可能的，即对每个标为“相同”的（i，j）对，就是i与j有相同标记的情况；对每个标为“不同”的（i，j）对，就是i与j有不同标记的情况。那么我们可以说这m个判断是一致的。他们正在冥思苦想自己的判断是否是一致的。请你帮他们设计合理的算法解决该问题。 输入输入包含多组数据，以文件结束符为终止。 每组数据第一行为两个整数，分别是n和m：n为蝴蝶的数量，编号从0到n-1m为关系的数量 接下来是m组关系数据，每组数据占一行，为三个整数，前两个整数表示蝴蝶的编号，第三个整数为关系的种类（相同或者不同）：0为相同，1为不同 1 &lt; n &lt;= 10001 &lt; m &lt;= 100000 输出合理就输出YES不合理就输出NO 样例输入123456783 30 1 01 2 10 2 13 30 1 01 2 10 2 0 样例输出12YESNO 提示注意输出的大写和回车 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct table{ int neighbor; int same; struct table *next;};struct head{ int type; bool visited; struct table *head; struct table *end;};struct connection{ int a; int b; int s;};struct connection conn[100000];struct head h[1000];int main(void){ int m, n; int i = 0; int a = 0; queue&lt;int&gt; q; while (scanf(\"%d %d\", &amp;m, &amp;n) != EOF) { bool res = true; for (i = 0; i &lt; m; i++) { h[i].visited = false; h[i].head = new struct table; h[i].head-&gt;next = NULL; h[i].type = 0; h[i].end = h[i].head; } for (i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;conn[i].a, &amp;conn[i].b, &amp;conn[i].s); a = conn[i].a; h[a].end-&gt;next = new struct table; h[a].end = h[conn[i].a].end-&gt;next; h[a].end-&gt;neighbor = conn[i].b; h[a].end-&gt;same = conn[i].s; h[a].end-&gt;next = NULL; } for (i = 0; i &lt; m; i++) { if (h[i].visited != true &amp;&amp; h[i].head-&gt;next != NULL) { q.push(i); h[i].visited = true; } while (!q.empty()) { int cur = q.front(); q.pop(); struct table *c = h[cur].head; while (c-&gt;next != NULL) { c = c-&gt;next; if (!h[c-&gt;neighbor].visited) { h[c-&gt;neighbor].visited = true; if (c-&gt;same == 0) { h[c-&gt;neighbor].type = h[cur].type; } else { h[c-&gt;neighbor].type = 1 - h[cur].type; } q.push(c-&gt;neighbor); } } } } for (int i = 0; i &lt; n; i++) { if(conn[i].s == 0){ if(h[conn[i].a].type != h[conn[i].b].type){ res = false; break; } } else{ if(h[conn[i].a].type == h[conn[i].b].type){ res = false; break; } } } if (res) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0;}","link":"/algorithms/POJ/course/2-A Butterfly.html"},{"title":"","text":"Dynamic Median描述设计一个数据结构，初始为空，支持以下操作： （1）增加一个元素，要求在log(n)时间内完成，其中n是该数据结构中当前元素的个数。注意：数据结构中允许有重复的元素。 （2）返回当前元素集合的中位数，要求在常数时间内完成。如果当前元素的个数为偶数，那么返回下中位数（即两个中位数中较小的一个）。 （3）删除中位数，要求在log(n)时间内完成。 输入输入的第一行是一个自然数T，代表测试数据的组数((1 ≤ T ≤ 600))。每组测试数据的第一行是个自然数N，代表操作的次数，1&lt;=N&lt;=10000。后面的N行中的每行代表一个操作，每次操作首先输入一个单字符代表操作的类型： I表示插入，后面跟着输入一个正整数（这是唯一带有输入数值的操作）。Q表示查询，输出当前的中位数（这是唯一产生输出的操作）。D表示删除当前的中位数。 输入保证是正确的：查询时集合保证不为空（即中位数是存在的），删除时保证集合中有足够可供删除的元素。 输出每次查询操作Q时输出的中位数，每次输出单独占一行。 样例输入1234567891018I 4I 3I 5Q DI 10I 2Q 样例输出1243 提示123 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main(void){ int group; scanf(\"%d\", &amp;group); while (group &gt; 0) { priority_queue&lt;int&gt; smallq; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; bigq; int n; int count = 0; scanf(\"%d\", &amp;n); while (n &gt; 0) { char ins; scanf(\"%c\", &amp;ins); while (ins == '\\n' || ins == ' ') { scanf(\"%c\", &amp;ins); } if (ins == 'I') { int num; scanf(\"%d\", &amp;num); count++; // insert if (bigq.size() == 0 || num &gt; bigq.top()) { bigq.push(num); } else if (smallq.size() == 0 || num &lt; smallq.top()) { smallq.push(num); } else if (bigq.size() &gt; smallq.size()) { smallq.push(num); } else { bigq.push(num); } while (((int)bigq.size() - (int)smallq.size()) &gt; 1) { smallq.push(bigq.top()); bigq.pop(); } while (((int)smallq.size() - (int)bigq.size()) &gt; 1) { bigq.push(smallq.top()); smallq.pop(); } } else if (ins == 'Q') { // query if (bigq.size() &gt; smallq.size()) { printf(\"%d\\n\", bigq.top()); } else { printf(\"%d\\n\", smallq.top()); } } else if (ins == 'D') { // delete if (bigq.size() &gt; smallq.size()) { bigq.pop(); } else { smallq.pop(); } } n--; } group--; } return 0;}","link":"/algorithms/POJ/course/2-B Dynamic Median.html"},{"title":"","text":"1-F 2的幂次方表示描述任何一个正整数都可以用2的幂次方表示。例如： 137=2^7+2^3+2^0 同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为： 2(7)+2(3)+2(0) 进一步：7=2^2+2+2^0（2^1用2表示） 3=2+2^0 所以最后137可表示为： 2(2(2)+2+2(0))+2(2+2(0))+2(0) 又如： 1315=2^10+2^8+2^5+2+1 所以1315最后可表示为： 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) 输入一个正整数n（n≤20000）。 输出一行，符合约定的n的0，2表示（在表示中不能有空格）。 样例输入1137 样例输出12(2(2)+2+2(0))+2(2+2(0))+2(0) 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int max(int num){ int i; for (i = 15; i &gt;= 0; i --) { if (int(pow(2, i) + 0.5) &lt;= num) { return i; } } return 0;}int main(void){ char map[16][30] = {\"(0)\", \"\", \"(2)\", \"(2+2(0))\", \"(2(2))\", \"(2(2)+2(0))\", \"(2(2)+2)\", \"(2(2)+2+2(0))\", \"(2(2+2(0)))\", \"(2(2+2(0))+2(0))\", \"(2(2+2(0))+2)\", \"(2(2+2(0))+2+2(0))\", \"(2(2+2(0))+2(2))\", \"(2(2+2(0))+2(2)+2(0))\", \"(2(2+2(0))+2(2)+2)\",\"(2(2+2(0))+2(2)+2(2)+2+2(0)))\"}; int num; cin &gt;&gt; num; int n = max(num); for(int i = n; i &gt;= 0; i--){ int diff = num - (int)(pow(2, i) + 0.5); if(diff &gt; 0){ cout &lt;&lt; \"2\" &lt;&lt; map[i] &lt;&lt; \"+\"; num = diff; } else if(diff == 0){ cout &lt;&lt; \"2\" &lt;&lt; map[i] &lt;&lt; endl; break; } } return 0;}","link":"/algorithms/POJ/course/1-F 2的幂次方表示.html"},{"title":"","text":"The Unique MST描述Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’. 输入The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them. 输出For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’. 样例输入1234567891023 31 2 12 3 23 1 34 41 2 22 3 23 4 24 1 2 样例输出123Not Unique! 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct edge { int x; int y; int w; int sign; edge(int x, int y, int w) : x(x), y(y), w(w), sign(0) {} // Implement &lt; and &gt; for sort bool operator&lt;(const edge &amp;e) const { return (w &lt; e.w); } bool operator&gt;(const edge &amp;e) const { return (w &gt; e.w); }};int find_parent(int x, int parent[]){ if (x != parent[x]) { parent[x] = find_parent(parent[x], parent); } return parent[x];}int main(void){ int parent[100]; int t; cin &gt;&gt; t; while (t-- &gt; 0) { bool has_signed_point = false; int m, n; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } // Input - Kruskal vector&lt;edge&gt; edge_v; int x, y, w; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edge_v.push_back(edge(x, y, w)); } sort(edge_v.begin(), edge_v.end()); // 如果 the edge has the same weight，标记为1 int last_w = -1; for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++){ if (last_w == it-&gt;w) { it--; it-&gt;sign = 1; // has the same weight it++; it-&gt;sign = 1; } last_w = it-&gt;w; } // 通过并查集来实现Kruskal // 如果用到的sign = 1的边，则改为sign = 2 int sum = 0; for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++) { if (find_parent(it-&gt;x, parent) != find_parent(it-&gt;y, parent)) { if (it-&gt;sign == 1) { has_signed_point = true; it-&gt;sign = 2; // should be deleted } sum += it-&gt;w; parent[it-&gt;y] = it-&gt;x; } } if (has_signed_point) { // 对于每一条sign = 2的边，尝试删掉这条边，然后重新跑一遍Kruskal，如果最小生成树的总长是一样的，说明不是Unique for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++) { if (it-&gt;sign == 2) { int sum_2 = 0; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } for (vector&lt;edge&gt;::iterator it_2 = edge_v.begin(); it_2 != edge_v.end(); it_2++) { if (it_2 != it) { if (find_parent(it_2-&gt;x, parent) != find_parent(it_2-&gt;y, parent)) { sum_2 += it_2-&gt;w; parent[it_2-&gt;y] = it_2-&gt;x; } } } if (sum == sum_2) { sum = -1; break; } } } } if (sum == -1) { cout &lt;&lt; \"Not Unique!\" &lt;&lt; endl; } else { cout &lt;&lt; sum &lt;&lt; endl; } } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct edge { int x; int y; int w; int sign; edge(int x, int y, int w, int s) : x(x), y(y), w(w), sign(s) {} bool operator&lt;(const edge &amp;e) const { return w &lt; e.w; } bool operator&gt;(const edge &amp;e) const { return w &gt; e.w; }};int n, m;int parent[110];int find_parent(int loc){ if (parent[loc] != loc) { parent[loc] = find_parent(parent[loc]); } return parent[loc];}int main(void){ int t; cin &gt;&gt; t; while (t-- &gt; 0) { cin &gt;&gt; n &gt;&gt; m; int x, y, w, s; vector&lt;edge&gt; v; edge *last_e = NULL; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; if (last_e != NULL &amp;&amp; last_e-&gt;w == w) { s = 1; last_e-&gt;sign = s; } else { s = 0; } v.push_back(edge(x, y, w, s)); last_e = &amp;v.back(); } sort(v.begin(), v.end()); for (int i = 1; i &lt;= n; i++) { parent[i] = i; } int sum = 0; for (vector&lt;edge&gt;::iterator it = v.begin(); it != v.end(); it++) { // cout &lt;&lt; \"X: \" &lt;&lt; it-&gt;x &lt;&lt; \" Y: \" &lt;&lt; it-&gt;y &lt;&lt; \" W: \" &lt;&lt; it-&gt;w &lt;&lt; \" S: \" &lt;&lt; it-&gt;sign &lt;&lt; endl; if (find_parent(it-&gt;x) != find_parent(it-&gt;y)) { sum += it-&gt;w; // HERE: Combine two sets parent[it-&gt;y] = it-&gt;x; if (it-&gt;sign == 1) { it-&gt;sign = 2; } } } bool res = true; for (vector&lt;edge&gt;::iterator it = v.begin(); it != v.end(); it++) { int sum_1 = 0; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } if (it-&gt;sign == 2) { it-&gt;sign = 3; for (vector&lt;edge&gt;::iterator it_1 = v.begin(); it_1 != v.end(); it_1++) { if (it_1-&gt;sign != 3 &amp;&amp; find_parent(it_1-&gt;x) != find_parent(it_1-&gt;y)) { sum_1 += it_1-&gt;w; parent[it_1-&gt;y] = it_1-&gt;x; } } if (sum_1 == sum) { res = false; break; } it-&gt;sign = 2; } } if (res) { cout &lt;&lt; sum &lt;&lt; endl; } else { cout &lt;&lt; \"Not Unique!\" &lt;&lt; endl; } } return 0;}","link":"/algorithms/POJ/course/2-D The Unique MST.html"},{"title":"","text":"Yogurt Factory描述The cows have purchased a yogurt factory that makes world-famous Yucky Yogurt. Over the next N (1 &lt;= N &lt;= 10,000) weeks, the price of milk and labor will fluctuate weekly such that it will cost the company C_i (1 &lt;= C_i &lt;= 5,000) cents to produce one unit of yogurt in week i. Yucky’s factory, being well-designed, can produce arbitrarily many units of yogurt each week. Yucky Yogurt owns a warehouse that can store unused yogurt at a constant fee of S (1 &lt;= S &lt;= 100) cents per unit of yogurt per week. Fortuitously, yogurt does not spoil. Yucky Yogurt’s warehouse is enormous, so it can hold arbitrarily many units of yogurt. Yucky wants to find a way to make weekly deliveries of Y_i (0 &lt;= Y_i &lt;= 10,000) units of yogurt to its clientele (Y_i is the delivery quantity in week i). Help Yucky minimize its costs over the entire N-week period. Yogurt produced in week i, as well as any yogurt already in storage, can be used to meet Yucky’s demand for that week. 输入 Line 1: Two space-separated integers, N and S. Lines 2..N+1: Line i+1 contains two space-separated integers: C_i and Y_i. 输出 Line 1: Line 1 contains a single integer: the minimum total cost to satisfy the yogurt schedule. Note that the total might be too large for a 32-bit integer. 样例输入123454 588 20089 40097 30091 500 样例输出1126900 提示OUTPUT DETAILS:In week 1, produce 200 units of yogurt and deliver all of it. In week 2, produce 700 units: deliver 400 units while storing 300 units. In week 3, deliver the 300 units that were stored. In week 4, produce and deliver 500 units. 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(void){ int n, s; cin &gt;&gt; n &gt;&gt; s; int c, y; int min_price = 6000; long long sum = 0; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c &gt;&gt; y; if (c &lt; (min_price + s)) { min_price = c; sum += (long long)c * (long long)y; } else { min_price = min_price + s; sum += (long long)min_price * (long long)y; } } printf(\"%lld\\n\", sum); return 0;}","link":"/algorithms/POJ/course/2-C Yogurt Factory.html"},{"title":"","text":"Subway描述You have just moved from a quiet Waterloo neighbourhood to a big, noisy city. Instead of getting to ride your bike to school every day, you now get to walk and take the subway. Because you don’t want to be late for class, you want to know how long it will take you to get to school.You walk at a speed of 10 km/h. The subway travels at 40 km/h. Assume that you are lucky, and whenever you arrive at a subway station, a train is there that you can board immediately. You may get on and off the subway any number of times, and you may switch between different subway lines if you wish. All subway lines go in both directions. 输入Input consists of the x,y coordinates of your home and your school, followed by specifications of several subway lines. Each subway line consists of the non-negative integer x,y coordinates of each stop on the line, in order. You may assume the subway runs in a straight line between adjacent stops, and the coordinates represent an integral number of metres. Each line has at least two stops. The end of each subway line is followed by the dummy coordinate pair -1,-1. In total there are at most 200 subway stops in the city. 输出Output is the number of minutes it will take you to get to school, rounded to the nearest minute, taking the fastest route. 样例输入1230 0 10000 10000 200 5000 200 7000 200 -1 -1 2000 600 5000 600 10000 600 -1 -1 样例输出121 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;double a[250];double b[250];double map[250][250];double d[250];bool final[250];int main(void){ scanf(\"%lf %lf %lf %lf\", &amp;a[0], &amp;b[0], &amp;a[1], &amp;b[1]); int c = 2; double x, y; bool start_of_new_line = true; double distance; // Read the input and calculate the distance of subway line while (scanf(\"%lf %lf\", &amp;x, &amp;y) != EOF) { if (x &gt; -1 &amp;&amp; y &gt; -1) { a[c] = x; b[c] = y; if (!start_of_new_line) { distance = sqrt(pow((x - a[c - 1]), 2) + pow((y - b[c - 1]), 2)); map[c][c - 1] = distance; map[c - 1][c] = distance; } start_of_new_line = false; c += 1; } else { start_of_new_line = true; } } // Calculate the distance of walking for (int i = 0; i &lt; c; i++) { map[i][i] = INT_MAX; for (int j = i + 1; j &lt; c; j++) { if (!(map[i][j] &gt; 0)) { distance = 4 * sqrt(pow((a[i] - a[j]), 2) + pow((b[i] - b[j]), 2)); map[i][j] = distance; map[j][i] = distance; } } } // Dijkstra - Preparation for (int i = 0; i &lt; c; i++) { final[i] = false; d[i] = map[0][i]; } // Dijkstra - Greedy Part d[0] = 0; final[0] = true; for (int i = 1; i &lt; c; i++) { double min = INT_MAX; int v = 0; for (int w = 0; w &lt; c; w++) { if (!final[w]) { if (d[w] &lt; min) { v = w; min = d[w]; } } } final[v] = true; for (int w = 0; w &lt; c; w++) { if (!final[w] &amp;&amp; (min + map[v][w] &lt; d[w])) { d[w] = min + map[v][w]; } } } // The goal is at point 1 double t = d[1] / 1000 / 40 * 60; int time = (int)(t + 0.5); printf(\"%d\\n\", time); return 0;}","link":"/algorithms/POJ/course/2-E Subway.html"},{"title":"","text":"2-F All Discs Considered描述Operating systems are large software artefacts composed of many packages, usually distributed on several media, e.g., discs. You probably remember the time when your favourite operating system was delivered on 21 floppy discs, or, a few years later, on 6 CDs. Nowadays, it will be shipped on several DVDs, each containing tens of thousands of packages. The installation of certain packages may require that other packages have been installed previously. Therefore, if the packages are distributed on the media in an unsuitable way, the installation of the complete system requires you to perform many media changes, provided that there is only one reading device available, e.g., one DVD-ROM drive. Since you have to start the installation somehow, there will of course be one or more packages that can be installed independently of all other packages. Given a distribution of packages on media and a list of dependences between packages, you have to calculate the minimal number of media changes required to install all packages. For your convenience, you may assume that the operating system comes on exactly 2 DVDs. 输入The input contains several test cases. Every test case starts with three integers N1, N2, D. You may assume that 1&lt;=N1,N2&lt;=50000 and 0&lt;=D&lt;=100000. The first DVD contains N1 packages, identified by the numbers 1, 2, …, N1. The second DVD contains N2 packages, identified by the numbers N1+1, N1+2, …, N1+N2. Then follow D dependence specifications, each consisting of two integers xi, yi. You may assume that 1&lt;=xi,yi&lt;=N1+N2 for 1&lt;=i&lt;=D. The dependence specification means that the installation of package xi requires the previous installation of package yi. You may assume that there are no circular dependences. The last test case is followed by three zeros. 输出For each test case output on a line the minimal number of DVD changes required to install all packages. By convention, the DVD drive is empty before the installation and the initial insertion of a disc counts as one change. Likewise, the final removal of a disc counts as one change, leaving the DVD drive empty after the installation. 样例输入123456783 2 11 22 2 21 34 22 1 11 30 0 0 样例输出123343 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct point { int in_1; int in_2; vector&lt;int&gt; dep;};struct point disc[100010];int main(void){ int m, n, d; int x, y; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;d); while (m != 0 || n != 0 || d != 0) { int insert_1 = 0; queue&lt;int&gt; q[2]; for (int i = 1; i &lt;= m + n; i++) { disc[i].in_1 = 0; disc[i].in_2 = 0; disc[i].dep.clear(); } for (int i = 0; i &lt; d; i++) { scanf(\"%d %d\", &amp;x, &amp;y); disc[y].dep.push_back(x); disc[x].in_1 += 1; disc[x].in_2 += 1; } for (int i = 1; i &lt;= m; i++) { if (disc[i].in_1 == 0) { q[0].push(i); } } for (int i = m + 1; i &lt;= m + n; i++) { if (disc[i].in_1 == 0) { q[1].push(i); } } int u = 0; while (q[u].size() &gt; 0 || q[1 - u].size() &gt; 0) { while (q[u].size() &gt; 0) { int t = q[u].front(); q[u].pop(); for (vector&lt;int&gt;::iterator it = disc[t].dep.begin(); it &lt; disc[t].dep.end(); it++) { disc[*it].in_1 -= 1; if (disc[*it].in_1 &lt;= 0) { if (*it &lt;= m) { q[0].push(*it); } else { q[1].push(*it); } } } } u = 1 - u; insert_1++; } insert_1++; int insert_2 = 0; for (int i = 1; i &lt;= m; i++) { if (disc[i].in_2 == 0) { q[0].push(i); } } for (int i = m + 1; i &lt;= m + n; i++) { if (disc[i].in_2 == 0) { q[1].push(i); } } u = 1; while (q[u].size() &gt; 0 || q[1 - u].size() &gt; 0) { while (q[u].size() &gt; 0) { int t = q[u].front(); q[u].pop(); for (vector&lt;int&gt;::iterator it = disc[t].dep.begin(); it &lt; disc[t].dep.end(); it++) { disc[*it].in_2 -= 1; if (disc[*it].in_2 &lt;= 0) { if (*it &lt;= m) { q[0].push(*it); } else { q[1].push(*it); } } } } u = 1 - u; insert_2++; } insert_2++; if (insert_1 &gt; insert_2) { printf(\"%d\\n\", insert_2); } else{ printf(\"%d\\n\", insert_1); } scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;d); } return 0;}","link":"/algorithms/POJ/course/2-F All Discs Considered.html"},{"title":"","text":"求逆序对数描述对于一个长度为N的整数序列A，满足i &lt; j 且 Ai &gt; Aj.的数对(i,j)称为整数序列A的一个逆序请求出整数序列A的所有逆序对个数 输入输入包含多组测试数据，每组测试数据有两行第一行为整数N(1 &lt;= N &lt;= 20000)，当输入0时结束第二行为N个整数，表示长为N的整数序列 输出每组数据对应一行，输出逆序对的个数 样例输入123456751 2 3 4 555 4 3 2 1110 样例输出1230100 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int src[100000];int dst[100000];int res;void mergesort(int a, int b){ if ((b - a) &lt;= 1) { return; } mergesort(a, (a + b + 1) / 2); mergesort((a + b + 1) / 2, b); int x = a; int y = (a + b + 1) / 2; int z = a; while ((x &lt; (a + b + 1) / 2) &amp;&amp; (y &lt; b)) { // 最重要的一步: Count if (src[x] &gt; src[y]) { // x以及x之后的都是逆序对 res += (a + b + 1) / 2 - x; dst[z++] = src[y++]; } else { dst[z++] = src[x++]; } } // 后面的不可能再有逆序对了，因为前面都算过了 while (x &lt; (a + b + 1) / 2) { dst[z++] = src[x++]; } while (y &lt; b) { dst[z++] = src[y++]; } // 复制一下 for (int i = a; i &lt; b; i++) { src[i] = dst[i]; }}int main(void){ int n; scanf(\"%d\", &amp;n); while (n &gt; 0) { res = 0; for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;src[i]); } mergesort(0, n); printf(\"%d\\n\", res); scanf(\"%d\", &amp;n); } return 0;}","link":"/algorithms/POJ/course/3-A 求逆序对数.html"},{"title":"","text":"Raid描述After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union’s attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by N nuclear power stations and breaking down any of them would disable the system. The general soon started a raid to the stations by N special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station? 输入The first line is a integer T representing the number of test cases.Each test case begins with an integer N (1 ≤ N ≤ 1000).The next N lines describe the positions of the stations. Each line consists of two integers X (0 ≤ X ≤ 1000000000) and Y (0 ≤ Y ≤ 1000000000) indicating the positions of the station.The next following N lines describe the positions of the agents. Each line consists of two integers X (0 ≤ X ≤ 1000000000) and Y (0 ≤ Y ≤ 1000000000) indicating the positions of the agent. 输出For each test case output the minimum distance with precision of three decimal placed in a separate line. 样例输入12345678910111213141516171819240 00 11 01 12 22 33 23 340 00 00 00 00 00 00 00 0 样例输出121.4140.000 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;double MAX = 100000000000;struct point { int x; int y; bool type; // true: station; false: agent;};struct point p[1050];int y[1050];int t[1050];int area[1050];bool compareByX(const point &amp;a, const point &amp;b){ return a.x &lt; b.x;}bool compareByY(const point &amp;a, const point &amp;b){ return a.y &lt; b.x;}int minInt(int a, int b){ return a &lt; b ? a : b;}double minDouble(double a, double b){ return a &lt; b ? a : b;}int MERGE(int start, int end, double left, double right){ int start1 = start, end1 = (start + end) / 2; int start2 = (start + end) / 2 + 1, end2 = end; int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) t[k++] = p[y[start1]].y &lt; p[y[start2]].y ? y[start1++] : y[start2++]; while (start1 &lt;= end1) t[k++] = y[start1++]; while (start2 &lt;= end2) t[k++] = y[start2++]; int i = 0; for (k = start; k &lt;= end; k++){ if(p[t[k]].x &gt;= left &amp;&amp; p[t[k]].x &lt;= right){ area[i++] = t[k]; } y[k] = t[k]; } return i;}double dist(point &amp;a, point &amp;b){ if (a.type == b.type) { return MAX; } else { return sqrt(pow((double)(a.x - b.x), 2) + pow((double)(a.y - b.y), 2)); }}double closestPair(int start, int end){ if ((end - start) &lt;= 0) { y[start] = start; return MAX; } else if ((end - start) == 1) { if (p[start].y &lt; p[end].y) { y[start] = start; y[end] = end; } else { y[start] = end; y[end] = start; } return dist(p[start], p[start + 1]); } // 分治为左边和右边（已经基于X坐标排序过） double min = minDouble(closestPair(start, (start + end) / 2), closestPair((start + end) / 2 + 1, end)); // 然后划分中间区域 double left = (double)(p[(start + end) / 2].x) - min; double right = (double)(p[(start + end) / 2].x) + min; // int areaLen = MERGE(start, end, left, right); for (int i = 0; i &lt; areaLen; i++) { for (int j = i + 1; j &lt; areaLen; j++) { if (p[area[j]].y &gt;= p[area[i]].y + min){ break; } double d = dist(p[area[i]], p[area[j]]); if (d &lt; min) { min = d; } } } return min;}int main(void){ int t; scanf(\"%d\", &amp;t); while (t--) { int n; int x, y; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d\", &amp;p[i].x, &amp;p[i].y); p[i].type = true; } for (int i = n + 1; i &lt;= 2 * n; i++) { scanf(\"%d %d\", &amp;p[i].x, &amp;p[i].y); p[i].type = false; } // 基于X坐标排序 sort(p + 1, p + 2 * n + 1, compareByX); printf(\"%.3lf\\n\", closestPair(1, 2 * n)); } return 0;}","link":"/algorithms/POJ/course/3-B Raid.html"},{"title":"","text":"Common Subsequence描述A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. 输入The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. 输出For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string a;string b;int cache[20000][20000];int max(int a, int b){ return (a &gt; b) ? a : b;}int findCommonSeq(int m, int n){ if (m &gt;= a.length() || n &gt;= b.length()) { return 0; } if (cache[m][n] == -1) { if (a[m] == b[n]) { cache[m][n] = 1 + findCommonSeq(m + 1, n + 1); } else { cache[m][n] = max(findCommonSeq(m, n + 1), findCommonSeq(m + 1, n)); } } return cache[m][n];}int main(void){ while (cin &gt;&gt; a &gt;&gt; b) { for (int i = 0; i &lt; a.length(); i++) { for (int j = 0; j &lt; b.length(); j++) { cache[i][j] = -1; } } cout &lt;&lt; findCommonSeq(0, 0) &lt;&lt; endl; } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;#include &lt;iostream&gt;#define SIZE 500using namespace std;int dp[SIZE][SIZE];char a[SIZE];char b[SIZE];int m, n;int main(void){ while (cin &gt;&gt; a &gt;&gt; b) { m = strlen(a); n = strlen(b); for (int i = m; i &gt;= 0; i--) { for (int j = n; j &gt;= 0; j--) { if (i == m || j == n) { dp[i][j] = 0; } else if (a[i] == b[j]) { dp[i][j] = dp[i + 1][j + 1] + 1; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]); } } } cout &lt;&lt; dp[0][0] &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/3-D Common Subsequence.html"},{"title":"","text":"Longest Ordered Subsequence描述A numeric sequence of ai is ordered if a1 &lt; a2 &lt; … &lt; aN. Let the subsequence of the given numeric sequence (a1, a2, …, aN) be any sequence (ai1, ai2, …, aiK), where 1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8). Your program, when given the numeric sequence, must find the length of its longest ordered subsequence. 输入The first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000 输出Output file must contain a single integer - the length of the longest ordered subsequence of the given sequence. 样例输入1271 7 3 5 9 4 8 样例输出14 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int res[1000];int num[1000];int n;int findLongestSeq(){ for (int i = 0; i &lt; n; i++) { int max = 1; for (int j = 0; j &lt; i; j++) { if (num[i] &gt; num[j]) { if (max &lt; (res[j] + 1)) { max = res[j] + 1; } } } res[i] = max; } int max = 0; for (int i = 0; i &lt; n; i++) { if (max &lt; res[i]) { max = res[i]; } } return max;}int main(void){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); } printf(\"%d\\n\", findLongestSeq()); return 0;} 代码 21234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[1010];int res[1010];int main(void){ cin &gt;&gt; n; memset(res, 0, sizeof(res)); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } for (int i = 0; i &lt; n; i++) { res[i] = 1; for (int j = 0; j &lt; i; j++) { if (num[i] &gt; num[j]) { res[i] = max(res[i], res[j] + 1); } } } int max_value = 0; for (int i = 0; i &lt; n; i++) { max_value = max(max_value, res[i]); } cout &lt;&lt; max_value &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/3-C Longest Ordered Subsequence.html"},{"title":"","text":"月度开销描述农夫约翰是一个精明的会计师。他意识到自己可能没有足够的钱来维持农场的运转了。他计算出并记录下了接下来 N (1 ≤ N ≤ 100,000) 天里每天需要的开销。 约翰打算为连续的M (1 ≤ M ≤ N) 个财政周期创建预算案，他把一个财政周期命名为fajo月。每个fajo月包含一天或连续的多天，每天被恰好包含在一个fajo月里。 约翰的目标是合理安排每个fajo月包含的天数，使得开销最多的fajo月的开销尽可能少。 输入第一行包含两个整数N,M，用单个空格隔开。接下来N行，每行包含一个1到10000之间的整数，按顺序给出接下来N天里每天的开销。 输出一个整数，即最大月度开销的最小值。 样例输入123456787 5100400300100500101400 样例输出1500 提示若约翰将前两天作为一个月，第三、四两天作为一个月，最后三天每天作为一个月，则最大月度开销为500。其他任何分配方案都会比这个值更大。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int num[100000];int m, n;long long solve(long long left, long long right){ if(left == right){ return left; } else{ long long mid = (left + right) / 2; int month = 0; long long cost = 0; for(int i = 0; i &lt; n; i++){ if(cost + (long long)num[i] &lt;= mid){ cost += (long long)num[i]; } else if((long long)num[i] &lt;= mid){ month += 1; cost = (long long)num[i]; if(month &gt; m){ break; } } else{ break; } } if(month &lt; m){ return solve(left, mid); } else{ return solve(mid + 1, right); } }}int main(void){ long long left = 0; long long right = 0; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++){ scanf(\"%d\", &amp;num[i]); if(left &lt; num[i]){ left = (long long)num[i]; } right += (long long)num[i]; } printf(\"%lld\", solve(left, right)); return 0;}","link":"/algorithms/POJ/course/3-E 月度开销.html"},{"title":"","text":"LITTLE SHOP OF FLOWERS描述You want to arrange the window of your flower shop in a most pleasant way. You have F bunches of flowers, each being of a different kind, and at least as many vases ordered in a row. The vases are glued onto the shelf and are numbered consecutively 1 through V, where V is the number of vases, from left to right so that the vase 1 is the leftmost, and the vase V is the rightmost vase. The bunches are moveable and are uniquely identified by integers between 1 and F. These id-numbers have a significance: They determine the required order of appearance of the flower bunches in the row of vases so that the bunch i must be in a vase to the left of the vase containing bunch j whenever i &lt; j. Suppose, for example, you have bunch of azaleas (id-number=1), a bunch of begonias (id-number=2) and a bunch of carnations (id-number=3). Now, all the bunches must be put into the vases keeping their id-numbers in order. The bunch of azaleas must be in a vase to the left of begonias, and the bunch of begonias must be in a vase to the left of carnations. If there are more vases than bunches of flowers then the excess will be left empty. A vase can hold only one bunch of flowers. Each vase has a distinct characteristic (just like flowers do). Hence, putting a bunch of flowers in a vase results in a certain aesthetic value, expressed by an integer. The aesthetic values are presented in a table as shown below. Leaving a vase empty has an aesthetic value of 0. According to the table, azaleas, for example, would look great in vase 2, but they would look awful in vase 4. To achieve the most pleasant effect you have to maximize the sum of aesthetic values for the arrangement while keeping the required ordering of the flowers. If more than one arrangement has the maximal sum value, any one of them will be acceptable. You have to produce exactly one arrangement. 输入The first line contains two numbers: F, V.The following F lines: Each of these lines contains V integers, so that Aij is given as the jth number on the (i+1)st line of the input file. 1 &lt;= F &lt;= 100 where F is the number of the bunches of flowers. The bunches are numbered 1 through F.F &lt;= V &lt;= 100 where V is the number of vases.-50 &lt;= Aij &lt;= 50 where Aij is the aesthetic value obtained by putting the flower bunch i into the vase j. 输出The first line will contain the sum of aesthetic values for your arrangement. 样例输入12343 57 23 -5 -24 165 21 -4 10 23-21 5 -4 -20 20 样例输出153 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int MIN = -100000;int F, V;int val[100][100];int res[100][100];int max(int a, int b){ return a &gt; b ? a : b;}int solve(int f, int v){ if(f &gt;= F || v &gt;= V){ return 0; } if (res[f][v] == MIN) { int max = 0; for (int i = 0; f + i &lt; F; i++) { max += val[f + i][v + i]; } for (int i = v; i &lt;= V - F + f; i++) { int sum = val[f][i] + solve(f + 1, i + 1); if (sum &gt; max) { max = sum; } } res[f][v] = max; } return res[f][v];}int main(void){ scanf(\"%d %d\", &amp;F, &amp;V); for (int i = 0; i &lt; F; i++) { for (int j = 0; j &lt; V; j++) { scanf(\"%d\", &amp;val[i][j]); res[i][j] = MIN; } } printf(\"%d\\n\", solve(0, 0)); return 0;}","link":"/algorithms/POJ/course/3-F LITTLE SHOP OF FLOWERS.html"},{"title":"","text":"Multiplication Puzzle描述The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000 If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150. 输入The first line of the input contains the number of cards N (3 &lt;= N &lt;= 100). The second line contains N integers in the range from 1 to 100, separated by spaces. 输出Output must contain a single integer - the minimal score. 样例输入12610 1 50 50 20 5 样例输出13650 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;climits&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int c[110];int d[110][110];int rec(int a, int b){ if (d[a][b] &lt; 0) { if ((b - a) == 1) { d[a][b] = 0; } else { int min = INT_MAX; for (int i = a + 1; i &lt; b; i++) { int l = rec(a, i); int r = rec(i, b); if (min &gt; l + r + c[a] * c[i] * c[b]) { min = l + r + c[a] * c[i] * c[b]; } } d[a][b] = min; } } return d[a][b];}int main(void){ cin &gt;&gt; n; memset(d, -1, sizeof(d)); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } cout &lt;&lt; rec(0, n - 1) &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/4-B Multiplication Puzzle.html"},{"title":"","text":"Drainage Ditches描述Every time it rains on Farmer John’s fields, a pond forms over Bessie’s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie’s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. 输入The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. 输出For each case, output a single integer, the maximum rate at which water may emptied from the pond. 样例输入1234565 41 2 401 4 202 4 202 3 303 4 10 样例输出150 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000001;int m, n;// m: count of points; (1 -&gt; m)// n: count of roads; (0 -&gt; n-1)int capacity[210][210];int former[210];int inqueue[210];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == m) { return true; } for (int i = 1; i &lt;= m; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ while (cin &gt;&gt; n &gt;&gt; m) { int max_flow = 0; memset(capacity, 0, sizeof(capacity)); int a, b, c; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; capacity[a][b] += c; } while (bfs()) { int bottleneck = MAX_VALUE; for (int i = m; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = m; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/4-C Drainage Ditches.html"},{"title":"","text":"Arbitrage描述Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 10.0 0.21 = 1.05 US dollars, making a profit of 5 percent. Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not. 输入The input will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;=n&lt;=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n. 输出For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”. 样例输入123456789101112131415161718192021223USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 样例输出12Case 1: YesCase 2: No 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct currency { double value; int source; currency(double n, int s) : value(n), source(s) {}};int n = 0;int m = 0;string name[35];int count[35];vector&lt;currency&gt; cur[35];double d[35];int t[35];int t_max;bool in_queue[35];queue&lt;int&gt; q;int find_money(string a){ for (int i = 0; i &lt; n; i++) { if (!a.compare(name[i])) { return i; } } return -1;}int main(void){ cin &gt;&gt; n; string a, b; double c; int case_number = 0; while (n != 0) { bool res = false; case_number ++; // Read value for (int i = 0; i &lt; n; i++) { cin &gt;&gt; name[i]; cur[i].clear(); } cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; c &gt;&gt; b; cur[find_money(b)].push_back(currency(c, find_money(a))); } //SPFA for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { t[j] = 0; d[j] = 0; in_queue[j] = false; } t_max = 0; q.push(i); t[i] = 1; d[i] = 1; in_queue[i] = true; while ((!q.empty()) &amp;&amp; (t_max &lt; n)) { int cur_node = q.front(); q.pop(); in_queue[cur_node] = false; for (vector&lt;currency&gt;::iterator it = cur[cur_node].begin(); it != cur[cur_node].end(); it++) { if (d[it-&gt;source] &lt; d[cur_node] * it-&gt;value) { d[it-&gt;source] = d[cur_node] * it-&gt;value; if (!in_queue[it-&gt;source]) { q.push(it-&gt;source); if ((++t[it-&gt;source]) &gt; t_max) { t_max = t[it-&gt;source]; } in_queue[it-&gt;source] = true; } } } } if (t_max &gt;= n) { res = true; } while (!q.empty()) { q.pop(); } } if(res){ cout &lt;&lt; \"Case \" &lt;&lt; case_number &lt;&lt; \": Yes\" &lt;&lt; endl; } else{ cout &lt;&lt; \"Case \" &lt;&lt; case_number &lt;&lt; \": No\" &lt;&lt; endl; } cin &gt;&gt; n; } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define SIZE 35using namespace std;struct edge { int s; // source double v; // value edge(int s, double v) : s(s), v(v) {}};char money_name[SIZE][200];int n, m;int money(char name[]){ for (int i = 0; i &lt; n; i++) { if (!strcmp(name, money_name[i])) { return i; } } return -1;}int main(void){ int case_num = 0; cin &gt;&gt; n; while (n != 0) { case_num++; vector&lt;edge&gt; cur[SIZE]; // ========== Input ========== for (int i = 0; i &lt; n; i++) { cin &gt;&gt; money_name[i]; } cin &gt;&gt; m; char src[200], dest[200]; double value; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; src &gt;&gt; value &gt;&gt; dest; cur[money(dest)].push_back(edge(money(src), value)); } // ========== SPFA =========== bool res = false; // HERE: Run n times to avoid isolated points for (int i = 0; i &lt; n; i++) { // Variables for SPFA queue&lt;int&gt; q; double d[SIZE]; bool in_queue[SIZE]; int successor[SIZE]; int t[SIZE]; // Init for (int j = 0; j &lt; n; j++) { t[j] = 0; d[j] = 0; in_queue[j] = false; successor[j] = j; } int t_max = 0; // Start point t[i] = 1; d[i] = 1; q.push(i); in_queue[i] = true; // Begin while (!q.empty() &amp;&amp; t_max &lt;= n) { int c = q.front(); q.pop(); in_queue[c] = false; for (vector&lt;edge&gt;::iterator it = cur[c].begin(); it != cur[c].end(); it++) { // source &lt; (source-&gt;dest) * dest if (d[it-&gt;s] &lt; d[c] * it-&gt;v) { d[it-&gt;s] = d[c] * it-&gt;v; successor[it-&gt;s] = c; // If not in queue, then push it if (!in_queue[it-&gt;s]) { q.push(it-&gt;s); in_queue[it-&gt;s] = true; if (++t[it-&gt;s] &gt; t_max) { t_max = t[it-&gt;s]; } } } } } // Negative cycle detect if (t_max &gt;= n) { res = true; break; } } cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \"; if (res) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else { cout &lt;&lt; \"No\" &lt;&lt; endl; } cin &gt;&gt; n; } return 0;}","link":"/algorithms/POJ/course/4-A Arbitrage.html"},{"title":"","text":"The Perfect Stall描述Farmer John completed his new barn just last week, complete with all the latest milking technology. Unfortunately, due to engineering problems, all the stalls in the new barn are different. For the first week, Farmer John randomly assigned cows to stalls, but it quickly became clear that any given cow was only willing to produce milk in certain stalls. For the last week, Farmer John has been collecting data on which cows are willing to produce milk in which stalls. A stall may be only assigned to one cow, and, of course, a cow may be only assigned to one stall.Given the preferences of the cows, compute the maximum number of milk-producing assignments of cows to stalls that is possible. 输入The input includes several cases. For each case, the first line contains two integers, N (0 &lt;= N &lt;= 200) and M (0 &lt;= M &lt;= 200). N is the number of cows that Farmer John has and M is the number of stalls in the new barn. Each of the following N lines corresponds to a single cow. The first integer (Si) on the line is the number of stalls that the cow is willing to produce milk in (0 &lt;= Si &lt;= M). The subsequent Si integers on that line are the stalls in which that cow is willing to produce milk. The stall numbers will be integers in the range (1..M), and no stall will be listed twice for a given cow. 输出For each case, output a single line with a single integer, the maximum number of milk-producing stall assignments that can be made. 样例输入1234565 52 2 53 2 3 42 1 53 1 2 51 2 样例输出14 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000;int m, n;int dist;// n -&gt; cow; m -&gt; stall;int capacity[410][410];int road_count[210];int former[410];int inqueue[410];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == dist) { return true; } for (int i = 1; i &lt;= dist; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ while (cin &gt;&gt; n &gt;&gt; m) { dist = 1 + n + m + 1; int max_flow = 0; memset(capacity, 0, sizeof(capacity)); int stall; for (int i = 2; i &lt;= n + 1; i++) { cin &gt;&gt; road_count[i]; for(int j = 0; j &lt; road_count[i]; j++){ cin &gt;&gt; stall; capacity[i][1 + n + stall] = MAX_VALUE; } capacity[1][i] = 1; } for (int i = 1; i &lt;= m; i++){ capacity[1 + n + i][dist] = 1; } while (bfs()) { int bottleneck = 2 * MAX_VALUE ; for (int i = dist; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = dist; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/4-D The Perfect Stall.html"},{"title":"","text":"Dual Core CPU描述As more and more computers are equipped with dual core CPU, SetagLilb, the Chief Technology Officer of TinySoft Corporation, decided to update their famous product - SWODNIW. The routine consists of N modules, and each of them should run in a certain core. The costs for all the routines to execute on two cores has been estimated. Let’s define them as Ai and Bi. Meanwhile, M pairs of modules need to do some data-exchange. If they are running on the same core, then the cost of this action can be ignored. Otherwise, some extra cost are needed. You should arrange wisely to minimize the total cost. 输入There are two integers in the first line of input data, N and M (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000) .The next N lines, each contains two integer, Ai and Bi.In the following M lines, each contains three integers: a, b, w. The meaning is that if module a and module b don’t execute on the same core, you should pay extra w dollars for the data-exchange between them. 输出Output only one integer, the minimum total cost. 样例输入123453 11 102 1010 32 3 1000 样例输出113 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;struct edge { int dest; int capacity;} edge_set[100000000];vector&lt;int&gt; source[200000];int n, m;int level[200000];int edge_count = 0;void addedge(int u, int v, int capacity){ edge_set[edge_count].dest = v; edge_set[edge_count].capacity = capacity; source[u].push_back(edge_count++); edge_set[edge_count].dest = u; edge_set[edge_count].capacity = 0; source[v].push_back(edge_count++);}bool bfs(){ memset(level, 0, sizeof(level)); queue&lt;int&gt; bfs_queue; level[0] = 1; bfs_queue.push(0); while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == n + 1) { return true; } for (int i = 0; i &lt; source[cur].size(); i++) { int dest = edge_set[source[cur][i]].dest; if (level[dest] == 0 &amp;&amp; edge_set[source[cur][i]].capacity &gt; 0) { level[dest] = level[cur] + 1; bfs_queue.push(dest); } } } return false;}int dfs(int s, int t, int max_f){ if (s == t) return max_f; int ret = 0; for (int i = 0; i &lt; source[s].size(); i++) { int src = source[s][i]; int v = edge_set[src].dest, f = edge_set[src].capacity; if (level[s] + 1 == level[v] &amp;&amp; f &gt; 0) { int min_n = min(max_f - ret, f); f = dfs(v, t, min_n); if (src % 2 == 0) { edge_set[src].capacity -= f; edge_set[src + 1].capacity += f; } else { edge_set[src].capacity -= f; edge_set[src - 1].capacity += f; } ret += f; if (ret == max_f) return ret; } } return ret;}int main(void){ scanf(\"%d%d\", &amp;n, &amp;m); int a, b, c; for (int i = 1; i &lt;= n; i++) { scanf(\"%d%d\", &amp;a, &amp;b); addedge(0, i, a); addedge(i, n + 1, b); } for (int i = 0; i &lt; m; i++) { scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); addedge(a, b, c); addedge(b, a, c); } int max_flow = 0; // for(int i = 1; i &lt;= n + 2; i ++){ // cout &lt;&lt; \"Source: \" &lt;&lt; i &lt;&lt; endl; // for(vector&lt;int&gt;::iterator it = source[i].begin(); it != source[i].end(); it++){ // cout &lt;&lt; edge_set[*it].dest &lt;&lt; '\\t' &lt;&lt; edge_set[*it].capacity &lt;&lt; endl; // } // } while (bfs()) { max_flow += dfs(0, n + 1, INF); } printf(\"%d\\n\", max_flow); return 0;}","link":"/algorithms/POJ/course/4-E Dual Core CPU.html"},{"title":"","text":"Dining描述Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others. Farmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible. Farmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both. Each dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2). 输入Line 1: Three space-separated integers: N, F, and DLines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink. 输出Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes 样例输入123454 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3 样例输出13 提示One way to satisfy three cows is:Cow 1: no mealCow 2: Food #2, Drink #2Cow 3: Food #1, Drink #1Cow 4: Food #3, Drink #3The pigeon-hole principle tells us we can do no better since there are only three kinds of food or drink. Other test data sets are more challenging, of course. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000;int n, f, d;int dist;// n -&gt; cow; m -&gt; stall;int capacity[410][410];int former[410];int inqueue[410];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == dist) { return true; } for (int i = 1; i &lt;= dist; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ cin &gt;&gt; n &gt;&gt; f &gt;&gt; d; int fi, di, food, drink; dist = 1 + f + n * 2 + d + 1; memset(capacity, 0, sizeof(capacity)); for (int cow = 1; cow &lt;= n; cow++) { cin &gt;&gt; fi &gt;&gt; di; for (int i = 0; i &lt; fi; i++) { cin &gt;&gt; food; capacity[1 + food][1 + f + cow] = 1; } for (int i = 0; i &lt; di; i++) { cin &gt;&gt; drink; capacity[1 + f + n + cow][1 + f + n * 2 + drink] = 1; } capacity[1 + f + cow][1 + f + n + cow] = 1; } for (int i = 1; i &lt;= f; i++) { capacity[1][1 + i] = 1; } for (int i = 1; i &lt;= d; i++) { capacity[1 + f + n * 2 + i][dist] = 1; } // cout &lt;&lt; \" S 1 2 3 1 2 3 4 1 2 3 4 1 2 3 E\" &lt;&lt; endl; // char ch[] = {' ', 'S', '1', '2', '3', '1', '2', '3', '4', '1', '2', '3', '4', '1', '2', '3', 'E'}; // for (int i = 1; i &lt;= dist; i++) { // cout &lt;&lt; ch[i] &lt;&lt; ' '; // for (int j = 1; j &lt;= dist; j++) { // cout &lt;&lt; capacity[i][j] &lt;&lt; ' '; // } // cout &lt;&lt; endl; // } int max_flow = 0; while (bfs()) { // for (int i = dist; i &gt; 1; i = former[i]) { // cout &lt;&lt; i &lt;&lt; ' '; // } // cout &lt;&lt; endl; int bottleneck = 2 * MAX_VALUE; for (int i = dist; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = dist; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/4-F Dining.html"},{"title":"","text":"To Europe! To Europe!描述Almost everyone in the candidate states wants to “go to Europe”, although most of the people have very vague ideas about what this actually means. Anyway, immediately after the borders are open, the inhabitants will take their cars and trucks and will “go to Europe”. This can cause many troubles, as the roads will be suddenly overloaded by vehicles of various types. You are to help to solve some of these traffic jams. Assume a convoy of vehicles has lined up in front of a single lane and one-way bridge over a river. Note that since the street is single lane, no vehicle can overtake any other. The bridge can sustain a given maximum load. To control the traffic on the bridge, operators are stationed on either end of the bridge. The convoy of vehicles is to be divided into groups, such that all the vehicles in any group can cross the bridge together. When a group reaches the other side, the operator on that side of the bridge uses a telephone to inform the operator on this side that the next group can start its journey over the bridge. The weight of each vehicle is known. The sum of the weights of the vehicles in any group cannot exceed the maximum load sustainable by the bridge. Associated with each vehicle is the maximum speed with which it can travel over the bridge. The time taken by a group of vehicles is calculated as the time taken by the slowest vehicle in the group to cross the bridge. The problem is to find the minimum amount of time in which the entire convoy can cross the bridge. 输入The input consists of several test cases. The first line of each test case contains three positive integers (separated by blanks): the first one represents the maximum load that the bridge can sustain b (in tonnes); the second one represents the length of the bridge l (in kms); and the third one is the number of vehicles (n) in the convoy. Each of the next n lines of input contains a pair of positive integers, wi and si (separated by blanks), where wi is the weight of the vehicle (in tonnes) and si is the maximum speed (in kmph) with which this vehicle can travel over the bridge. The weights and speeds of the vehicles are specified in the same order as the order in which the vehicles are queued up. You can assume that 1 &lt;= n,b,l,s &lt;= 1000 and any i in [1..n]: wi &lt;= b. After the last vehicle, the next test case description begins. The last test case is followed by a line containing three zeros. 输出The output of the program should be a single real number specifying the minimum time in minutes in which the convoy can cross the bridge. The number should be displayed with one digit after the decimal point. 样例输入123456789101112100 5 1040 2550 2050 2070 1012 509 7049 3038 2527 5019 700 0 0 样例输出175.0 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#define NUM 1010using namespace std;int w[NUM];int s[NUM];double t[NUM];int main(void){ int b, l, n; scanf(\"%d %d %d\", &amp;b, &amp;l, &amp;n); while (b != 0 &amp;&amp; l != 0 &amp;&amp; n != 0) { l *= 60; for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d\", &amp;w[i], &amp;s[i]); } t[0] = 0; for (int i = 1; i &lt;= n; i++) { int slowest_speed = s[i]; int load = w[i]; t[i] = (double)l / (double)s[i] + t[i - 1]; for (int j = i - 1; j &gt;= 1; j--) { load += w[j]; if (load &gt; b) { break; } slowest_speed = slowest_speed &lt; s[j] ? slowest_speed : s[j]; t[i] = (t[i] &lt; (t[j - 1] + (double)l / (double)slowest_speed)) ? t[i]: (t[j - 1] + (double)l / (double)slowest_speed); } } printf(\"%.1lf\\n\", t[n]); scanf(\"%d %d %d\", &amp;b, &amp;l, &amp;n); } return 0;}","link":"/algorithms/POJ/course/M-A To Europe! To Europe!.html"},{"title":"","text":"Radar Installation描述Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations 输入The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros 输出For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. 样例输入1234567893 21 2-3 12 11 20 20 0 样例输出12Case 1: 2Case 2: 1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int d, n;struct point { int x, y; double start, end; // Here we assume y is always smaller than d // We'll check whether y is larger than d when input point(int x, int y) : x(x), y(y) { double range = sqrt(pow(double(d), 2.0) - pow(double(y), 2.0)); start = double(x) - range; end = double(x) + range; } bool operator&lt;(const point &amp;p) const { return start &lt; p.start; } bool operator&gt;(const point &amp;p) const { return start &gt; p.start; }};int main(void){ cin &gt;&gt; n &gt;&gt; d; int case_num = 0; while (n != 0 &amp;&amp; d != 0) { case_num++; vector&lt;point&gt; v; int x, y; bool has_result = true; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; if (y &gt; d) { has_result = false; } v.push_back(point(x, y)); } if (!has_result) { cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \" &lt;&lt; -1 &lt;&lt; endl; } else { sort(v.begin(), v.end()); double radar_x = -1000000000; int radar_num = 0; for (vector&lt;point&gt;::iterator it = v.begin(); it != v.end(); it++) { if (it-&gt;start &gt; radar_x) { radar_num++; radar_x = it-&gt;end; } else { if (it-&gt;end &lt; radar_x) { radar_x = it-&gt;end; } } } cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \" &lt;&lt; radar_num &lt;&lt; endl; } cin &gt;&gt; n &gt;&gt; d; } return 0;}","link":"/algorithms/POJ/course/M-B Radar Installation.html"},{"title":"","text":"Palindrome描述A palindrome is a symmetrical string, that is, a string read identically from left to right as well as from right to left. You are to write a program which, given a string, determines the minimal number of characters to be inserted into the string in order to obtain a palindrome. As an example, by inserting 2 characters, the string “Ab3bd” can be transformed into a palindrome (“dAb3bAd” or “Adb3bdA”). However, inserting fewer than 2 characters does not produce a palindrome. 输入Your program is to read from standard input. The first line contains one integer: the length of the input string N, 3 &lt;= N &lt;= 5000. The second line contains one string with length N. The string is formed from uppercase letters from ‘A’ to ‘Z’, lowercase letters from ‘a’ to ‘z’ and digits from ‘0’ to ‘9’. Uppercase and lowercase letters are to be considered distinct. 输出Your program is to write to standard output. The first line contains one integer, which is the desired minimal number. 样例输入125Ab3bd 样例输出12 代码12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100000using namespace std;char str[5050];int n;int dp[5050][5050];int main(void){ cin &gt;&gt; n &gt;&gt; str; int k = 0; for (int i = n - 1; i &gt;= 0; i--) { for (int j = i; j &lt; n; j++) { if (i == j) { dp[i][j] = 0; } else if (str[i] == str[j]) { dp[i][j] = dp[i + 1][j - 1]; } else { dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1); } } k = 1 - k; } cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl; return 0;} 改进版本12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100000using namespace std;char str[5050];int n;int dp[2][5050];int main(void){ cin &gt;&gt; n &gt;&gt; str; int k = 0; for (int i = n - 1; i &gt;= 0; i--) { for (int j = i; j &lt; n; j++) { if (i == j) { dp[k][j] = 0; } else if (str[i] == str[j]) { dp[k][j] = dp[1 - k][j - 1]; } else { dp[k][j] = min(dp[1 - k][j] + 1, dp[k][j - 1] + 1); } } k = 1 - k; } cout &lt;&lt; dp[1 - k][n - 1] &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/M-D Palindrome.html"},{"title":"","text":"Percolation描述定义一个N行N列的矩阵，矩阵中的每个元素是个方格，每个方格有两种可能的状态：开通的或关闭的。初始时，所有方格都是关闭的。输入数据的每一步会指定矩阵中某个原来关闭的方格变成开通的。要求编写程序判断当前是否存在从矩阵中最上面一行的任何一个开着的方格走到最下面一行的任何一个开着的方格的路径。如果存在的话，输出当前的步数。比如走到第14步时，矩阵变成上下通透的，那么就输出14。注意：输入数据中只会把矩阵中的一部分方格打开。如果所有步骤都执行完了，矩阵仍然不是上下通透的，那么输出-1。显然，矩阵变成上下通透的一个必要条件是：最上面一行和最下面一行都至少要有一个方格是打开的。 在矩阵中行走时，只能横着走或竖着走，不能斜着走，也不能走出矩阵的边界。 输入输入的第一行是一个自然数T(1≤T≤10)，代表测试数据的组数。每组测试数据的第一行有两个自然数N和M，其中N（1≤N≤1,000）代表方阵的维度，M（1≤M≤N*N）代表本组测试中打开的方格数目。随后的M行中每行有两个自然数，分别代表所打开的方格的行、列下标。注意：本题中矩阵的下标从1开始，即所有下标的取值都是[1, N]区间中的正整数。 输出每组测试数据输出一个自然数K，表示打开第K个方格后，矩阵变成上下通透的。如果M个方格都打开后，矩阵仍然不是上下通透的，那么输出-1。 样例输入12345678910111214 10 2 23 14 24 41 22 32 13 23 43 1 样例输出18 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstring&gt;#include &lt;iostream&gt;int parent[1000060];int map[1005][1005];int n, m, t;int find_parent(int loc){ //int loc = (x - 1) * n + y; if (parent[loc] == -1) { parent[loc] = loc; } if (loc != parent[loc]) { parent[loc] = find_parent(parent[loc]); } return parent[loc];}int calc_loc(int x, int y){ return (x - 1) * n + y;}int main(void){ scanf(\"%d\", &amp;t); while (t-- &gt; 0) { memset(parent, -1, sizeof(parent)); memset(map[0], 0, 1005 * 1005 * sizeof(int)); scanf(\"%d %d\", &amp;n, &amp;m); int result = -1; int x, y, ancestor, loc; for (int i = 1; i &lt;= m; i++) { scanf(\"%d %d\", &amp;x, &amp;y); if (result == -1) { map[x][y] = 1; loc = calc_loc(x, y); if (x &gt; 1 &amp;&amp; map[x - 1][y] == 1) { ancestor = find_parent(calc_loc(x - 1, y)); parent[ancestor] = find_parent(loc); } if (x == 1) { ancestor = find_parent(0); parent[ancestor] = find_parent(loc); } if (x &lt; n &amp;&amp; map[x + 1][y] == 1) { ancestor = find_parent(calc_loc(x + 1, y)); parent[ancestor] = find_parent(loc); } if (x == n) { ancestor = find_parent(n * n + 1); parent[ancestor] = find_parent(loc); } if (y &gt; 1 &amp;&amp; map[x][y - 1] == 1) { ancestor = find_parent(calc_loc(x, y - 1)); parent[ancestor] = find_parent(loc); } if (y &lt; n &amp;&amp; map[x][y + 1] == 1) { ancestor = find_parent(calc_loc(x, y + 1)); parent[ancestor] = find_parent(loc); } if (find_parent(0) == find_parent(n * n + 1)) { result = i; } } } printf(\"%d\\n\", result); } return 0;}","link":"/algorithms/POJ/course/M-C Percolation.html"},{"title":"","text":"重要逆序对描述给定N个数的序列a1,a2,…aN，定义一个数对(ai, aj)为“重要逆序对”的充要条件为 i &lt; j 且 ai &gt; 2aj。求给定序列中“重要逆序对”的个数。 输入本题有多个测试点，每个测试点分为两行：第一行为序列中数字的个数N（1 ≤ N ≤ 200000），第二行为序列a1, a2 … aN(0 ≤a ≤ 10000000)，由空格分开。N=0表示输入结束。 输出每个测试点一行，输出一个整数，为给序列中“重要逆序对”的个数。 样例输入123100 9 8 7 6 5 4 3 2 10 样例输出116 提示请注意答案范围，如果使用printf输出long long类型，请用%lld 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[10000010];int temp[10000010];long long mergesort(int a, int b) { long long sum = 0; if ((b - a) &lt;= 0) { return sum; } sum += mergesort(a, (a + b) / 2); sum += mergesort((a + b) / 2 + 1, b); int x = a; int y = (a + b) / 2 + 1; int mid = (a + b) / 2; // 重要逆序对，要求i &lt; j 且 ai &gt; 2aj // 所以先算一遍有多少ai &gt; 2aj while (x &lt;= (a + b) / 2 &amp;&amp; y &lt;= b) { if (num[x] &gt; 2 * num[y]) { sum += mid - x + 1; y++; } else { x++; } } // 然后再做Merge Sort x = a; y = (a + b) / 2 + 1; int i = a; while (x &lt;= (a + b) / 2 &amp;&amp; y &lt;= b) { if (num[x] &lt; num[y]) { temp[i++] = num[x++]; } else { temp[i++] = num[y++]; } } // 同样，后面不用再算了，因为前面都已经算过了 while (x &lt;= (a + b) / 2) { temp[i++] = num[x++]; } while (y &lt;= b) { temp[i++] = num[y++]; } for (int i = a; i &lt;= b; i++) { num[i] = temp[i]; } return sum;}int main(void) { long long res; scanf(\"%d\", &amp;n); while (n &gt; 0) { for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); } res = mergesort(0, n - 1); printf(\"%lld\\n\", res); scanf(\"%d\", &amp;n); } return 0;}","link":"/algorithms/POJ/course/M-E 重要逆序对.html"},{"title":"","text":"昂贵的聘礼描述年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 输入输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。 输出输出最少需要的金币数。 样例输入1234567891 410000 3 22 80003 50001000 2 14 2003000 2 14 20050 2 0 样例输出15250 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define SIZE 200using namespace std;int map[SIZE][SIZE];int l[SIZE];int m, n;int final[SIZE];int d[SIZE];int main(void){ fill(map[0], map[0] + SIZE * SIZE, INT_MAX); scanf(\"%d %d\", &amp;m, &amp;n); int x, t, v; for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d %d\", &amp;map[0][i], &amp;l[i], &amp;x); for (int j = 0; j &lt; x; j++) { scanf(\"%d %d\", &amp;t, &amp;v); map[t][i] = v; } } int min_result = INT_MAX; for (int bound = 0; bound &lt;= m; bound++) { int upper_bound = l[1] + bound; int lower_bound = upper_bound - m; for (int i = 0; i &lt;= n; i++) { final[i] = false; d[i] = map[0][i]; } final[0] = true; d[0] = 0; for (int i = 1; i &lt;= n; i++) { int min_v = INT_MAX; int min_w = 0; for (int w = 1; w &lt;= n; w++) { if (!final[w] &amp;&amp; min_v &gt; d[w] &amp;&amp; l[w] &gt;= lower_bound &amp;&amp; l[w] &lt;= upper_bound) { min_v = d[w]; min_w = w; } } final[min_w] = true; for (int w = 1; w &lt;= n; w++) { if (map[min_w][w] &lt; INT_MAX &amp;&amp; l[w] &gt;= lower_bound &amp;&amp; l[w] &lt;= upper_bound) { d[w] = min(d[w], d[min_w] + map[min_w][w]); } } } min_result = min(min_result, d[1]); } printf(\"%d\\n\", min_result); return 0;}","link":"/algorithms/POJ/course/M-G 昂贵的聘礼.html"},{"title":"算法分析与复杂性理论","text":"第一次上机作业 玛雅历 棋盘问题 Til the Cows Come Home (Dijkstra) 仙岛求药 (BFS) 二叉树的操作 (Divide and Conquer) 2的幂次方表示 (Divide and Conquer) 第二次上机作业 Butterfly (Bipartite Graph) Dynamic Median (Priority Queue) Yogurt Factory (Greedy) The Unique MST (Minimum Spanning Tree) Subway (Dijkstra) All Discs Considered (Topological Sort) 第三次上机作业 求逆序对数 (Divide and Conquer) Raid (The Closest Pairs) Longest Ordered Subsequence (Longest Increasing Subsequence) Common Subsequence (Longest Common Subsequence) 月度开销 (Divide and Conquer, Binary Search) LITTLE SHOP OF FLOWERS (Dynamic Programming) 第四次上机作业 Arbitrage (SPFS, Negative Cycle Detect) Multiplication Puzzle (Matrix Multiplication) Drainage Ditches (Maximum Net Flow) The Perfect Stall (Maximum Net Flow) Dual Core CPU (Maximum Net Flow) Dining (Maximum Net Flow) 模拟考试 To Europe! To Europe! (Dynamic Programming) Radar Installation (Greedy) Percolation (Disjoint Set Union) Palindrome (Dynamic Programming) 重要逆序对 (Divide and Conquer) 昂贵的聘礼 (SPFS, Negative Cycle Detect)","link":"/algorithms/POJ/course/index.html"}],"posts":[{"title":"用编程展现绘画之美","text":"一个想法——通过Coding来画画。 这篇文章用于参加2016编程之美设计赛。 用编程展现绘画之美概述我们都知道，编程可以帮助我们更好地去探索动听的旋律： 我们也知道，编程可以帮助我们更好地吟诗作对，探索语言的魅力： 那么，编程可以帮助我们更好地去一览色彩的神奇吗？ 不妨和我一起试试，用Xaml语言来作一幅画吧。 教程首先，打开Visual Studio 2020，然后选择新建项目，在“新建项目”的对话框中选择“绘画”，在这里我们把作品命名为 Starry Night 在绘画之前，我们要准备好绘画用的材料以及想好自己想画的内容，跟着向导我们可以设定画的基本属性： 跟着向导完成初始化操作以后，我们可以看到接下来让我们挥洒灵感的地方： 而作品的标题、风格等信息已经定义好。 当然我们可以通过编写Xaml来绘画————例如，我们将画布涂上蓝色，再将整幅画按照黄金分割比例进行分隔：","link":"/2016/04/30/BoP/"},{"title":"在Ubuntu Server上配置CUDA环境","text":"在配置Ubuntu Server的CUDA和TensorFlow的过程中，遇到了很多问题（驱动无法正常运行、CUDA无法正常配置等等），在网上找了很多资料，最终正确安装驱动、CUDA、cuDNN和TensorFlow（GPU版本），因此将安装过程记录下来，方便以后再配环境。 版本要求： Ubuntu 16.04 LTS CUDA 9.0 cuDNN v7 Python 3.6 TensorFlow r1.10 PyTorch 0.4.1 1 准备工作1.1 检查GPU是否符合CUDA运行要求在Shell中运行命令： 1lspci | grep -i nvidia 查看GPU型号，然后在https://developer.nvidia.com/cuda-gpus页面中查找设备的GPU是否在支持CUDA的列表中。 1.2 检查GCC版本1gcc --version 对于Ubuntu 16.04来说，gcc版本需要&gt;5.4.0。 1.3 检查Kernel版本1uname -r 对于Ubuntu 16.04来说，内核版本需要&gt;4.4.0。 然后需要安装对应版本的Kernel Header： 1sudo apt-get install linux-headers-$(uname -r) 1.4 安装对应的库1234sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev \\ libboost-all-dev libhdf5-serial-dev libgflags-dev libgoogle-glog-dev liblmdb-dev \\ protobuf-compiler g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev \\ libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 2 安装CUDA2.1 首先安装显卡驱动（选做，CUDA自带的驱动可能会无法正常运行）(1) 禁用Nouveau运行命令： 1lsmod | grep nouveau 如果有显示内容，则说明Nouveau驱动正在运行，需要根据教程关闭Nouveau。 (2) 卸载之前的显卡驱动(3) 下载并安装驱动在NVIDIA驱动下载页面按照自己的GPU型号、系统以及CUDA版本选择驱动并进行下载，得到诸如nvidia-diag-driver-local-repo-ubuntu1604_3XY.AB-1_amd64.deb的文件（XY.AB需要根据下载版本进行修改）。 然后运行以下命令： 1234sudo dpkg -i nvidia-diag-driver-local-repo-ubuntu1604_3XY.AB-1_amd64.deb（XY.AB需要根据下载版本进行修改）sudo apt-get updatesudo apt-get install cuda-driverssudo reboot 运行后系统会进行重启，在运行命令前请保存所有正在运行的工作。 重启后运行： 1sudo nvidia-smi 如果正常输出显卡状态说民驱动安装成功。 2.2 安装CUDA在CUDA下载页面下载Runfile形式的CUDA安装包，形式为cuda_9.0.176_384.81_linux.run。 具体CUDA和cuDNN版本参考TensorFlow安装要求，对于r1.10版本来说支持的CUDA版本为9.0。 (Optional) 对于有GUI的系统来说，需要在启动时按下Ctrl + Alt + F1/F4进入tty1/tty4模式，然后运行： 1sudo service lightdm stop 停止GUI运行。 开始安装CUDA。 1sudo sh cuda_9.0.176_384.81_linux.run 一路按空格，输入accept同意用户协议 安装程序询问是否安装驱动，输入no 询问是否安装CUDA Toolkit，输入yes 更改CUDA Toolkit安装位置，这里不作修改 是否创建/usr/local/cuda符号链接，如果只安装一个CUDA版本，输入yes 询问是否安装CUDA Samples，输入yes 更改CUDA Samples安装位置，这里不作修改 如果没有报错，则说明安装成功。如果提示： Installing the CUDA Toolkit in /usr/local/cuda-8.0 … Missing recommended library: libGLU.so Missing recommended library: libX11.so Missing recommended library: libXi.so Missing recommended library: libXmu.so 则需要安装依赖库： 1sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 然后重新运行CUDA安装程序即可。 2.3 配置环境变量运行： 1sudo vi /etc/profile 用vi编辑启动脚本。用方向键将光标定位至文件末尾然后按i插入以下内容： 12export PATH=$PATH:/usr/local/cuda-9.0/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64:/usr/local/cuda-9.0/extras/CUPTI/lib64 在Shell中运行： 12export PATH=$PATH:/usr/local/cuda-9.0/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64:/usr/local/cuda-9.0/extras/CUPTI/lib64 2.4 验证CUDA是否安装成功(1) 验证驱动版本运行： 1cat /proc/driver/nvidia/version 查看驱动版本。 (2) 查看nvcc版本运行： 1nvcc -V i 查看nvcc版本。 (3) 运行示例（选做）按照教程运行示例。 3 安装cuDNN在cuDNN下载页面下载TensorFlow支持的cuDNN版本，目前支持的是cuDNN v7。在下载时需要注册NVIDIA账号和开发者账号。 下载后得到一个诸如cudnn-9.0-linux-x64-v7.tgz的压缩包。 运行： 1tar -xvzf cudnn-9.0-linux-x64-v7.tgz 进行解压，在当前目录得到cuda文件夹。 然后运行 123sudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 将cuDNN拷贝至CUDA目录中。 可以按照官方教程来验证cuDNN的安装。 4 安装Tensorflow如果没安装pip，则需要安装pip： 1sudo apt-get install python3-pip python3-dev 然后尝试从官方源下载安装TensorFlow： 1pip3 install tensorflow-gpu 如果安装缓慢或者网络错误，请尝试切换至清华大学提供的镜像源： 1pip3 install tensorflow-gpu -i https://pypi.tuna.tsinghua.edu.cn/simple 接下来验证安装，在Shell或者IDE中运行代码： 12345# Python Codeimport tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 等待，如果能够正常输出 1Hello, TensorFlow! 说明安装成功。如果输出错误信息，可以参考官方文档解决。 5 安装PyTorch运行： 1conda install pytorch torchvision -c pytorch 安装完成后，在Shell或者IDE里运行： 1234# Python Codeimport torchprint('CUDA support for Pytorch: ', torch.cuda.is_available())print('You are using device: ', torch.cuda.get_device_name(0)) 如果看到True和显卡名称，说明安装成功。 参考文档ubuntu16.04安装nvidia driver + cuda + cudnn (1) TensorFlow官方文档 CUDA安装文档（英文） cuDNN安装文档（英文） Ubuntu 14.04 上安装 CUDA 7.5/8.0 超详细教程","link":"/2018/08/15/Install-CUDA-on-Ubuntu-Server/"},{"title":"在Electron上实现始终置顶且可调整大小的二维码窗口","text":"弹幕派正在筹划使用Electron+Vue.js+Element来重构之前的桌面客户端，在重构过程中需要基于Electron的特性对之前的功能进行调整。其中要实现在弹幕窗口上显示一个始终置顶且可以手动调整大小以及移动位置，在实现过程中遇到一些问题并加以解决，在此进行分享。 怎样展现二维码第一个问题，是怎样展现二维码。由于二维码叠加在弹幕窗口之上，因此有两种可选方案：一是在原有的弹幕窗口上添加一个Vue组件，将二维码展现上去即可；二是新建一个窗口，单独用于显示二维码。 第一种方案需要手动实现二维码的位置移动和大小调整，但是由于是随着弹幕窗口一起显示，开启和关闭状态的管理较为简单，同时由于在同一窗口内，二维码地址等参数传递方便；第二种方案需要新开一个窗口，因此需要手动管理窗口的状态，且参数传递需要通过主进程进行传递，实现复杂度有所提升，好处在于位置移动和大小调整使用原生实现即可。首先基于第一种方式进行了实现。 与弹幕在同一窗口显示二维码组件的实现整体较为简单，显示一张二维码图片即可。由于需要手动实现窗口的调整大小和关闭，因此添加两个按钮，分别对应关闭和调整大小，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id=&quot;QRCode&quot; :style=&quot;location&quot;&gt; &lt;el-button circle class=&quot;close&quot;&gt; &lt;font-awesome-icon icon=&quot;times&quot;/&gt; &lt;/el-button&gt; &lt;el-button circle class=&quot;resize&quot;&gt; &lt;font-awesome-icon icon=&quot;expand-arrows-alt&quot;/&gt; &lt;/el-button&gt; &lt;img :src=&quot;src&quot; alt=&quot;QRCode&quot; class=&quot;QRCode&quot; :height=&quot;size&quot; :width=&quot;size&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import {remote} from &apos;electron&apos; export default { name: &quot;QRCode&quot;, data() { return { size: Math.floor(document.body.clientHeight / 2), location: { top: `${Math.floor(document.body.clientHeight / 4)}px`, left: `${Math.floor(document.body.clientWidth / 2 - document.body.clientHeight / 4)}px` } } }, props: { display: { type: Boolean }, src: { type: String } } }&lt;/script&gt; 值得注意的是初始显示位置和大小需要手动计算。 调整z-index接下来调整CSS样式。原本弹幕窗口的属性已经是始终置顶，下一步所需要做的是保证二维码在弹幕上方显示即可，通过设置z-index大于弹幕层的z-index即可，并设置position属性保证z-index生效。紧接着调整两个按钮的样式，设置position: absolute同时设置top和right值使其固定位置，在组件大小调整时仍然保持在窗口右上角/右下角即可。为了避免窗口过小时按钮遮挡住二维码，设置二维码的padding为1.5em并设置两个按钮的height和width为3em，这样可以跟随组件大小进行变化。最终CSS样式为： 1234567891011121314151617181920212223div { display: inline-block; position: absolute; padding: 1.5em; z-index: 4; } .close { position: absolute; top: 0; right: 0; height: 3em; width: 3em; } .resize { position: absolute; bottom: 0; right: 0; height: 3em; width: 3em; }} 全屏透明窗口的部分穿透完成以后运行可以看到二维码效果。接下来需要实现二维码的调整大小和关闭。然而这时会发现一个问题，和WPF不同的是，Electron不支持透明窗口的部分穿透。什么意思呢？由于我们的弹幕是全屏播放，因此为了保证不影响正常操作，需要在初始化窗口时设置window.setIgnoreMouseEvents(true)使得鼠标点击穿透到其他程序中。但是这样就导致没有办法通过点击按钮来调整二维码大小，也没有办法通过拖放来调整二维码显示的位置。而设置window.setIgnoreMouseEvents(false)又会导致其他窗口无法响应鼠标操作。在electron的官方GitHub Issue Support click-through of transparency #1335 有许多人遇到了同样的问题。简而言之，早期人们通过主进程捕捉当前鼠标位置像素点来决定是否发送事件给Renderer，非常复杂；在Electron 3.0.0版本后加入了setWindowShape API，如果是开发小部件（Gadget）的话使用这一API是非常得当的，直接将窗口大小设置为小部件的大小即可；但是由于弹幕需要全屏显示，因此需要其他方式来解决这一问题。 在Issue的最后有人提出一种解决方案，目前官方文档也已经写明：通过在元素上添加mouseenter和mouseleave事件，在鼠标进入二维码时设置window.setIgnoreMouseEvents(false)，捕捉鼠标事件；在鼠标离开元素时设置window.setIgnoreMouseEvents(true)释放鼠标事件，在本例中由于只有二维码一个元素需要处理鼠标事件，因此不会显得过于冗杂。完整实现为： 12345678let win = require('electron').remote.getCurrentWindow()let el = document.getElementById('QRCode')el.addEventListener('mouseenter', () =&gt; { win.setIgnoreMouseEvents(false)})el.addEventListener('mouseleave', () =&gt; { win.setIgnoreMouseEvents(true, { forward: true })}) 经过实现以后发现一个问题： 由于弹幕是Canvas动画，在鼠标移入/移出二维码时会导致明显的动画卡顿，在低性能设备上表现尤为明显，因此决定将这一方案弃置，转为用新窗口打开。 新窗口打开新窗口打开在实现上会比前一方案简单一点（并不），Vue组件基本和之前一样，不过由于调整二维码大小用的是原生的调整窗口大小，因此去掉resize按钮，同时把location、width和height等属性去掉即可。 接下来需要在主进程中实现二维码窗口，在主进程中创建createQRCodeWindow方法，通过传入screen.getAllDisplays()方法返回的screen对象获得窗口大小和位置进而调整每一个二维码窗口的显示；然后设置窗口属性（setAlwaysOnTop、loadURL等等）即可。值得注意的是需要在Vue Router里面配置QRCode.vue的路由。紧接着ipcMain中注册两个事件，一个是创建，另一个是关闭，传入参数为screen列表，根据列表在不同屏幕创建窗口即可。在渲染进程中通过按钮/开关等方式注册事件通过ipcRenderer触发事件并将当前已开启弹幕的屏幕的screen对象作为参数传入即可。 值得注意的是，为了避免窗口出错关闭后不断调用空引用提示错误，可以用try...catch...进行处理： 12345678910arg.forEach((idx) =&gt; { if (QRCodeWindows[idx]) { try { QRCodeWindows[idx].close() QRCodeWindows[idx] = null } catch (e) { danmakuWindows[idx] = null } } }) 如何传递参数打开窗口后我们要考虑两件事：一是如何使Vue页面知道自己所属的窗口，进而在调用ipcMain的关闭事件时指定自己所属的窗口；二是如何将二维码图片的地址从主进程传递到渲染进程中。一种方案是通过Vue Router的路由参数传递，另一种是通过ipcRenderer传递。前一种方案实现简单，但是将地址作为参数写入路由中总觉得会使地址过于丑陋，因此尝试第二种方案。 第二种方案在创建完窗口的同时通过调用window.webContents.send(channel, arguments)将参数传递过去，然后在Vue页面created环节通过注册ipcRender事件接收参数。但是实现后发现，参数并没有按照预期传递过去。这是由于我们在创建窗口并LoadURL后Vue生命周期还没有执行到created环节事件已经发出，渲染进程也就无法接收到参数。 那么为了保证事件可以被接收到，我们可以将发送参数作为一个事件放到ipcMain注册的事件中，等待渲染进程中Vue初始化完成了再进行调用，这样就确保渲染进程可以接收到参数。实现细节为： 主进程： 1234567891011121314ipcMain.on('initQRCode', () =&gt; { for (let k in QRCodeWindows) { if (QRCodeWindows.hasOwnProperty(k) &amp;&amp; QRCodeWindows[k]) { try { QRCodeWindows[k].webContents.send('initQRCode', { idx: k, src: 'http://static.danmakupie.com/qrcodes/VqUkcCq4Oj2ZmLDiROw3GA.png' }) } catch (e) { QRCodeWindows[k] = null } } }}) 渲染进程： 12345678created() { this.loading = true ipcRenderer.once('initQRCode', (event, arg) =&gt; { this.idx = arg.idx this.src = arg.src }) ipcRenderer.send('initQRCode', {})} 也就是说，等到Vue页面加载至created环节，注册事件监听后，再去触发主进程事件使其发送参数即可。但是这样有个问题是，渲染进程仍然不知道自己所在的窗口，因此主进程需要遍历所有的窗口逐一发送参数：如果窗口已经打开，那么窗口将接收参数；窗口没有打开则没有影响。这样会导致一个新问题：所有窗口初始化页面时都会触发主进程的事件，导致之前已经初始化过的窗口会不断响应并更新参数，这当然不是我们想要的，因此在渲染进程注册事件时使用once而非on方法，当触发时即注销事件，这样可以避免多次更新。 细节优化Loading界面由于二维码是从远端服务器获取图片，可能会出现图片加载时间过长，为了优化用户体验，可以加一个Loading界面。Element中提供了Loading界面，直接在div元素添加v-loading然后绑定一个Boolean变量即可。当开始载入页面时将loading变量设置为true，然后在图片加载完成时将loading变量设置为false即可。Vue中提供了图片加载完成事件v-on:load（简写为@load），直接绑定函数即可。 居中显示接下来要保证二维码图片始终居中显示。横向居中直接让div的属性设置为： 1234.container { text-align: center; margin: auto;} 即可。纵向居中稍微麻烦一点，具体可参考： CSS设置居中的方案总结-超全 和 盘点8种CSS实现垂直居中水平居中的绝对定位居中技术 由于是在Electron中实现，不需要考虑兼容性问题，因此这里使用兼容性比较差但是实现较为简单的flex，即添加一个父div，然后设置父div属性为： 1234#QRCodeParentContainer { display: flex; align-items: center;} 这样就能保证垂直居中和水平居中同时实现了。 等比例缩放但实际上这时会遇到一个问题，就是二维码并不是和窗口大小等比例缩放，且窗口没有办法等比例缩放。由官方Issue#8036可知目前Electron提供的API window.setAspectRatio(aspectRatio, extraSize: {width: float, height: float})只适用于macOS而非Windows，而Issue中提供的解决方案都不能很好地解决这一问题，因此接下来着重于保证二维码能够和窗口等比例缩放且按照最短边来显示，保证显示完整，不会出现滚动条。 首先设置图片的CSS样式为： 12345.QRCode { display: block; height: 100%; widht: 100%} 然后设置包含图片的子div的样式为： 1234#QRCodeChildContainer { width: 100vmin; height: 100vmin;} 其中vmin是指视口高度和宽度之间的最小值的 1/100。视口高度是指浏览器当前文档可见部分的高度，视口宽度同理。CSS引入了vh表示视口高度的 1/100，vw表示视口宽度的 1/100，vmin表示视口高度和宽度之间的最小值的 1/100，vmax表示视口高度和宽度之间的最大值的 1/100。在这里我们用100vmin就可以保证图片的大小始终是最短边来显示，不会出现滚动条。接着设置包含子div的父div格式为： 1234#QRCodeParentContainer { height: 100vh; width: 100vw;} 这样就可以保证二维码能够跟随窗口进行大小变化。 参考： 纯css实现容器高度随宽度等比例变化的四种解决方案 vh,vw单位你知道多少？ - MDN 文档 拖拽拖拽移动的实现非常简单，在div上添加属性-webkit-app-region: drag即可。为了防止拖拽override掉按钮点击事件，需要在按钮上添加属性-webkit-app-region: no-drag： 1234567#QRCodeChildContainer { -webkit-app-region: drag;}.close { -webkit-app-region: no-drag} 总结看似简单的二维码窗口却花了很长时间去调整和实现，本次实现主要涉及到以下一些知识点： 设置position使得z-index生效 Electron中透明窗口的部分穿透 Electron中如何用ipc从主进程向渲染进程传递初始化参数 Element中的Loading控制 CSS中元素的居中显示 CSS中元素等比例缩放 CSS实现Electron窗口拖拽","link":"/2019/02/06/An-always-on-top-window-based-on-electron/"},{"title":"浅谈BackgroundWorker的使用","text":"这是弹幕派开发文档系列的第一篇！在开发弹幕派的过程中，通过网上的资料、MSDN学习到了很多WPF和C#的相关知识，在这里一并写出来，希望能够帮助到C#特别是WPF开发者。弹幕派是我们开发的一个桌面弹幕小程序，说它小，但是它的开发周期可不短，在开发过程中学到了很多东西，今天我要说的便是第一个，如何运用后台进程连接网络。 浅谈BackgroundWorker在WPF中的使用弹幕派在刚开始UI的渲染（即弹幕的产生和刷新）以及弹幕内容的获取都是在一个进程中完成的，这样导致一个问题就在于每当从网络获取数据时就会出现明显卡顿，如果网络失去连接就会导致程序假死无法继续进行。很明显这样是不行的，因此必须要引入多线程，通过后台线程获取数据，再将数据更新到UI中。 在WPF中，为了保证线程安全，Windows只允许创建UI元素的线程访问这些元素。如果在其他线程中尝试修改UI元素的属性，就会触发STA错误，导致程序崩溃。这样做是为了保证内容渲染的一致性。但是也会导致一个问题——我们无法通过后台线程直接修改UI元素的属性。WPF通过Dispatcher机制解决了这一问题。WPF为UI渲染设置了一个Dispatcher，这个Dispatcher我们可以理解为调度员，它与UI渲染相关的事件排成一个队列，按优先级对其队列中的元素进行排序，并且按序执行，这样可以保证UI在渲染时只执行一个任务，保证UI内容的一致性。如果我们的后台线程需要对界面元素的属性进行修改，可以请求UI线程代替它完成这一操作。那么如何请求UI线程帮忙呢？通过向Dispatcher注册工作项，将想要执行的任务加入队列，这个任务会在某个时间由Dispatcher完成，后台进程无需插手UI渲染。 Dispatcher类提供两种调用方法，一种是Invoke同步调用，调用方必须等待UI进程完成这一任务才会返回并继续下面的操作；另一种是BeginInvoke异步调用，调用方在调用后会立即返回。在弹幕派原有的代码中对这一部分有所使用。原本弹幕派刷新弹幕是通过每秒钟定时修改所有弹幕TextBlock的Margin属性的值达到移动弹幕的效果，那么在计时器Timer的Elapse事件触发的函数中，如果直接修改这些Margin会触发STA错误。因此需要通过BeginInvoke来执行这一操作。 12345private delegate void DispatcherDelegateTimer(); // 声明委托private void OnTimedEvent(object sender, EventArgs e) { this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new DispatcherDelegateTimer(UpdateUI)); //通过BeginInvoke注册} 使用后台进程有三种方式，第一种是Task，第二种是Thread，第三种就是我们今天要介绍的BackgroundWorker了。这三种方法各有千秋，但是BackgroundWorker更适合用于实现后台连接网络下载，因此在弹幕派的弹幕获取、自动更新等地方都主要使用了BackgroundWorker。 那么如何用BackgroundWorker实现后台连接网络获取数据呢？首先我们需要引入命名空间 1using System.ComponentModel; 之后我们需要添加BackgroundWorker组件，这一组件可以从Xaml界面添加——从工具箱中的“组件”选项卡中，添加BackgroundWorker组件；也可以在代码中声明： 1private BackgroundWorker fetchBW = new BackgroundWorker(); 之后在初始化过程中设置BackgroundWorker的属性，可以在构造函数中，也可以在Loaded函数中。 12345fetchBW.WorkerReportsProgress = true; //是否报告工作进度fetchBW.WorkerSupportsCancellation = true; //是否允许异步取消工作fetchBW.DoWork += new DoWorkEventHandler(FetchBW_DoWork); //这里声明要做的工作fetchBW.ProgressChanged += new ProgressChangedEventHandler(FetchBW_ProgressChanged); //当工作进度改变时更新界面fetchBW.RunWorkerCompleted += new RunWorkerCompletedEventHandler(FetchBW_RunWorkerCompleted); //当工作完成时处理工作结果 首先要设置是否报告工作进度，如果WorkerReportsProgress为true，则可以在ProgressChanged事件的函数中处理进度条等信息。当然Progress的数值要自行在DoWork函数中利用ReportProgress设置数值的变化（例如获取已经下载的进度并更新进度条）。 1234567891011121314151617181920212223private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e){ BackgroundWorker worker = sender as BackgroundWorker; for (int i = 1; i &lt;= 10; i++) { if (worker.CancellationPending == true) { e.Cancel = true; break; } else { // Perform a time consuming operation and report progress. System.Threading.Thread.Sleep(500); worker.ReportProgress(i * 10); } }}private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e){ resultLabel.Text = (e.ProgressPercentage.ToString() + \"%\");} 如果允许异步取消（WorkerSupportsCancellation = false），则通过CancelAsync可以取消工作。此时CancellationPending = true。之后再绑定DoWork、ProgressChanged、RunWorkerCompleted事件。DoWork里写明主要功能，同时需要回报进度和处理取消事件。ProgressChanged里根据进度处理事件（修改进度条等），RunWorkerCompleted事件处理DoWork的结果。 那么如何在RunWorkerCompleted中获取DoWork的结果呢？ 1234567891011121314151617181920212223242526private void FetchBW_DoWork(Object sender, DoWorkEventArgs e) { BackgroundWorker backgroundWorker = sender as BackgroundWorker; //sender即源BackgroundWorker //...... // 将获得的结果进行封装，然后将解析结果保存至e.Result中供RunWorkerCompleted使用 fetchedData result = new fetchedData(num, contentList); e.Result = result; backgroundWorker.ReportProgress(100); // 当Dowork完成时直接将进度设为100%，触发RunWorkerCompleted事件}private void FetchBW_ProgressChanged(object sender, ProgressChangedEventArgs e) { return;}private void FetchBW_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Cancelled == false &amp;&amp; e.Error == null) { fetchedData result = e.Result as fetchedData; danmuStorage.AddRange(result.contentList); result.contentList.Clear(); } else { Debug.WriteLine(\"获取时出现错误\"); } bwTimer.Stop();} 将结果保存至DoWork的e.Result中，之后可以在RunWorkerCompleted的e.Result中获取到结果。处理结果时要处理Cancelled（取消事件）和Error（错误事件）。这里要注意的是，对于网络访问等操作来说，很有可能会出现网络连接中断导致超时，因此这个时候需要我们设置一个定时器，在开始处理事件前启动定时器，然后在定时器超时时调用CancelAsync即可。 BackgroundWorker不仅可以在WPF中调用，在WinForm中也可以。BackgroundWorker最适合的场景便是后台下载，通过DoWork、ReportProgress和RunWorkerCompleted三者分开，可以明确地划分执行工作、更新界面、处理结果三个部分，与定时器Timer和按钮Button结合使用还可以保证程序不会由于网络连接中断等原因一直卡住。 参考资料wpf 多线程 线程处理模型 如何：使用后台辅助线程 如何：在后台下载文件 如何：在后台运行操作 BackgroundWorker Dispatcher类 委托 delegate","link":"/2016/08/29/BackgroundWorker/"},{"title":"如何快速掌握Markdown语法？","text":"Markdown 是一种轻量级标记语言。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。掌握Markdown语法的基本语法，只需要十点就够了。 Q: 有哪些网站可以用来写Markdown呢？ A: Github、简书都支持Markdown，Github中可以一边写Markdown一边预览。 Q: 有哪些Markdown编辑器呢？ A: 近似全能的新兴编辑器Visual Studio Code、MarkdownPad都可以用来写Markdown，你可以用他们来进行练习。 在Gist中，用Github账号登录以后即可建立一个Gist（可以理解为文章），在里面编辑Markdown文档可以直接点击Preview查看效果。 在Visual Studio Code中新建一个Markdown文档（即新建文档 -&gt; 另存为 文件名.md），在编辑时点击右上角预览按钮可以实时预览效果。 目录 一、段落和换行 二、标题 三、列表 四、链接 五、图片 六、粗体和斜体 七、代码 八、引用 九、反斜杠 十、分割线 Tips 一、段落和换行在Markdown里，一个换行不会另起一行，只有两个（及以上）的换行会另起一行。这是为了保证书写格式的整齐。 每一行的行首不能有空格和缩进。 二、标题用 # 来标记标题，# 越多，标题级别越小。# 后面要有一个空格，表明这个#是标题的意思。 12345# Head 1## Head 2### Head 3#### Head 4##### Head 5 Head 1Head 2Head 3Head 4Head 5三、列表用 * 来标记无序列表的项目，* 后面要有空格，缩进可以调整项目级别。 12345* Item 1* Item 2* Item 3 * Item 3.1 * Item 3.2 Item 1 Item 2 Item 3 Item 3.1 Item 3.2 用 1.、2.、3.（数字后面加一个点）标记有序列表的项目，标号后面要有空格。 12341. Item 12. Item 23. Item 34. Item 4 Item 1 Item 2 Item 3 Item 4 四、链接用方括号和圆括号表示链接。方括号括起 网址的标题或描述， 圆括号括起 网址。就像这样： 1[弹幕派](www.danmakupie.com) 弹幕派 五、图片图片和链接比较像，只不过图片要在前面加一个感叹号（!），方括号括起 图片的标题或描述，圆括号括起图片地址。 1![弹幕派Logo](http://7xr64j.com1.z0.glb.clouddn.com/blog/howtowritemarkdown/danmakupie-logo.png) 六、粗体和斜体用**和*分别标记粗体和斜体。 1**粗体** *斜体* 粗体 斜体 七、代码代码分为两种，一种是大段文字里掺杂一些代码，用`（键盘左上角的反引号）标记。 1在写C语言之前，要引入`#include &lt;stdio.h&gt;`才能正常编译。 在写C语言之前，要引入#include &lt;stdio.h&gt;才能正常编译。 另外一种是大块代码，用三个`（反引号）标记。 ``` #include &lt;stdio.h&gt; int main(void){return 0;}``` 12345#include &lt;stdio.h&gt; int main(void){ return 0;} 我们还可以将代码行都缩进一个Tab，从而将这些行标记为代码（这也就是为什么不要在普通文字前面缩进）。 12345[Tab] #include &lt;stdio.h&gt;[Tab] [Tab] int main(void){[Tab] return 0;[Tab] } 12345#include &lt;stdio.h&gt; int main(void){ return 0;} 八、引用有的时候我们需要标明一段话是引用自其他文章的，我们用&gt;标记。 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 九、反斜杠（转义字符）上面可以看到，有很多字符都用来当标记符了。那么如果我们需要输入这些字符怎么办呢？答案就是反斜杠，用反斜杠来转义这些字符。 1\\*literal asterisks\\* *literal asterisks* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 十、分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 1234567* * *********- - - Tips:1. 如果想要添加一个发送电子邮件的链接该怎么办？1[联系我们](mailto:danmakupie@outlook.com) 联系我们 1[联系我们](mailto:danmakupie@outlook.com?subject=弹幕派意见反馈) 联系我们 2. 链接可以跳转到本页面的另一个地方吗？在Github里是支持跳转到页面里的另一个标题的：1[八、引用](#八、引用) 八、引用 这样就可以跳转到“八、引用”这个标题了。这可以用来做目录。 所有用#标记的标题都可以。GitHub对中文的支持不太好。 3. 参考式链接一些链接可能要在文档里重复多次，每次都要写一遍链接太费事了。因此就有参考式链接。参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][1] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[1]: http://www.danmakupie.com \"弹幕派\" This is an example reference-style link. 4. 引用可以嵌套引用吗？可以，通过多个&gt;可以不断嵌套： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. This is the first level of quoting. This is nested blockquote. Back to the first level. 引用里还可以有其他标记： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 5. 如何输入上标和下标？用&lt;sub&gt;和&lt;/sub&gt;包括下标文字： 1H&lt;sub&gt;2&lt;/sub&gt;O H2O 用&lt;sup&gt;和&lt;/sup&gt;包括上标文字： 1X&lt;sup&gt;2&lt;/sup&gt;+2x+1 = 0 X2+2x+1 = 0 6. 代码块如何进行语法高亮？在```之后加上语言的标记，例如： ``` c 可以标记C语言。 具体各语言高亮支持请查看highlight.js - CSS classes reference 参考资料http://wowubuntu.com/markdown/ 延伸阅读Learning-Markdown (Markdown 入门参考) 这里有讲怎么用Markdown画表格（虽然我从来没画出来过）。","link":"/2016/11/01/How-to-Write-Markdown/"},{"title":"Visual Studio Code配置C/C++编译运行环境","text":"最近一直在用C++写LeetCode，本地调试的时候一直在纠结用什么编辑器，CLion有点耗资源，Visual Studio又有点杀鸡焉用宰牛刀，Dev-Cpp已经太古老了，于是决定用VS Code来写，但是官方文档写的有点……不是特别友好，因此在这里记录一下自己是怎么配置的。 1 安装MinGW或者CLang 2 安装并配置C/C++插件 2.1 配置IntelliSence 2.2 配置编译选项 2.3 配置Debug选项 2.4 设置代码格式化 3 后续 1 安装MinGW或者Clang目前Windows上比较主流的C++编译器包括MinGW（也就是Windows版本的GCC）以及CLang。在这里以MinGW为例。 MinGW可以下载Online Installer然后选择对应的版本号进行安装，在这里可以选择8.1.0, posix和seh。对于不同版本的对比可以参考这篇StackOverflow。 安装完成后将MinGW安装目录/bin文件夹（例如C:\\Dev\\mingw64\\bin）加入环境变量，具体可以参考这篇文档。加入环境变量后重新开启一个命令行然后输入g++ --version就可以看到安装好的MinGW的版本号了。 2 安装并配置C/C++插件访问C/C++ - Visual Studio Marketplace点击Install启动VS Code安装插件即可。 可以参考官方文档来配置C/C++插件，这里着重对官方文档中没有讲明白的部分进行强调。比较懒的同学可以直接跳过每一节后面详细配置部分，直接复制配置修改对应编译器和Debugger的位置即可使用。下面均以Windows系统为主，macOS和Linux可以根据详细配置部分自行修改。 2.1 配置IntelliSence新建一个项目文件夹，在VS Code中打开，然后在VS Code中按Ctrl + Shift + P输入命令C/C++: Edit Configurations...，VS Code会自动在项目文件夹根目录新建配置文件夹.vscode并同时在.vscode中新建配置文件c_cpp_properties.json。 先给出配置文件内容： 1234567891011121314151617181920{ \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"C:/Dev/MinGW/mingw64/bin/gcc.exe\", //修改为本机gcc.exe路径 \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" } ], \"version\": 4} 然后介绍其中重要的部分： c_cpp_properties.json中共包含三部分： env：可以在这里定义用户变量，在下面的configuration中可以使用这里定义的变量来代替多次重复出现的地址等配置。 configurations：在这里配置IntelliSence选项。每一个选项都会有默认值。 version：指c_cpp_properties.json的版本，这里不需要作修改。 configurations中包含以下配置项： name：配置文件名称，在这里如果根据系统填”Linux”, “Mac”或者”Win32”，那么插件会自动根据这里填写的系统名称来读取默认值。在VS Code的状态栏中会显示这一配置名称。通过点击状态栏中的名称可以更换配置。在这里我们指定为Win32。 intelliSenseMode：如果插件设置中C_Cpp.intelliSenseEngine设置为”default”的话，这里可以指定IntelliSence的模式。msvc-x64对应Visual Studio模式，clang-x64对应Clang模式，gcc-x64对应GCC模式。Windows默认使用msvc-x64，macOS默认使用clang-x64，Linux默认使用gcc-x64，在这里由于我们用的是GCC，因此修改为gcc-x64。 includePath：指定IntelliSence在目录中搜索源文件所包含（#include）的头文件。这与在命令行中调用编译器时用-I选项指定的路径是一样的。如果路径末尾是/**的话IntelliSence会自动加载所有的子目录。如果是Windows系统并且安装了Visual Studio 的C++功能，或者配置了compilePath，这里可以不做配置。 macFramePath：同上，指定macOS框架的头文件目录地址。 defines：这里可以指定在编译过程中所调用的预处理符号的内容，与命令行调用编译器时-D选项指定的内容是一样的。如果是Windows系统并且安装了Visual Studio 的C++功能，或者配置了compilePath，这里可以不做配置。 forceInclude：（可选）强制加载的头文件，优先于源文件中指定的头文件，按照配置文件里的顺序加载，这里不需要配置。 compilerPath ：（可选）编译器的绝对路径。插件会根据编译器决定includePath和default define的值。可以在路径后附加选项，例如-nostdinc++, -m32, -fno-ms-extensions等等。如果选项有空格需要用双引号（“）括起来。这里需要找到刚才安装的MinGW中gcc.exe的位置，例如C:/Dev/MinGW/mingw64/bin/gcc.exe。 cStandard：C的标准，这里填c11。 cppStadard：C++的标准，这里填cpp17。 compileCommands：（可选） If &quot;C_Cpp.intelliSenseEngine&quot; is set to “Default” in your settings file, the includes and defines discovered in this file will be used instead of the values set for includePath and defines. If the compile commands database does not contain an entry for the translation unit that corresponds to the file you opened in the editor, then a warning message will appear and the extension will use the includePath and defines settings instead. For more information about the file format, see the Clang documentation. Some build systems, such as CMake, simplify generating this file. 参考： c_cpp_properties.json Reference Guide 2.2 配置编译选项VS Code通过Tasks来执行编译和运行操作。在.vscode文件夹中新建文件tasks.json进行配置。 先给出配置文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Build\", \"command\": \"C:/Dev/MinGW/mingw64/bin/g++.exe\", // 修改这里为本机g++路径 \"type\": \"shell\", \"args\": [ \"-g\", \"-Wall\", \"-std=c++11\", \"-lm\", \"${file}\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.exe\" //Linux和macOS这里要修改为.o ], \"presentation\": { \"reveal\": \"always\", \"echo\": true, \"focus\": true }, \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [\"relative\", \"${workspaceRoot}\"], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } }, \"group\": { \"kind\": \"build\", \"isDefault\": true } }, { \"label\": \"Run\", \"type\": \"shell\", \"dependsOn\": \"Build\", \"command\": \"${fileDirname}/${fileBasenameNoExtension}.o\", \"windows\": { \"command\": \"${fileDirname}/${fileBasenameNoExtension}.exe\" }, \"args\": [], \"presentation\": { \"reveal\": \"always\", \"focus\": true }, \"problemMatcher\": [], \"group\": { \"kind\": \"test\", \"isDefault\": true } } ]} 然后解释其中配置的内容： label：任务标签。 type：任务类型，一般指定为shell或process。当设置为shell时会将命令看作终端操作，包括bash、cmd或PowerShell。当指定为process时会将命令看作是一个进程。这里选择shell。 command：命令内容，这里指定编译器的路径，比如g++的路径C:/Dev/MinGW/mingw64/bin/g++.exe。 args：命令的参数列表。 windows：Windows特定的配置属性，例如macOS和Linux上指定编译的输出文件为.o，而Windows下指定编译的输出文件为.exe。 group：指定任务的分组归属。例如指定group为test，那么可以通过命令面板的Run Test Task运行该任务。 presentation：指定如何在界面上显示任务输出。 ​ reveal：在执行任务时是否显示内置的终端面板，可选的值包括：always：始终显示；never：从不显示；silent：只在不扫描错误和警告时显示。默认值为always。 ​ focus：终端是否在输入时激活。默认值为false。 ​ echo：是否将执行的命令输出到终端中。默认值为true。 ​ showReuseMessage：是否显示”终端将被任务重用，按任意键关闭。“这一消息。 ​ panel：控制是否在各任务间共享终端输出。 ​ shared：共享终端，所有任务的输出都会在同一个终端内显示。 ​ dedicated：每一个任务都有自己的输出终端，但是对于同一个任务来说，如果被重复执行的话仍会在同一个终端内显示。 ​ new：无论是否是同一个任务都会打开一个新的输出终端。 ​ clear：在任务执行之前是否清空输出终端，默认值为false。 ​ group：指定任务输出的分组，同一个分组的任务会共享终端而非开启新终端。 problemMatcher：将编译器输出的错误映射至VS Code的问题面板。具体可以参考Defining a problem matcher。 参考： Integrate with External Tools via Tasks Schema for tasks.json 2.3 配置Debug选项如果要启用Debug，需要在.vscode文件夹下创建launch.json。 先给出配置内容： 12345678910111213141516171819202122232425262728293031323334{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 // https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\",// 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"${fileDirname}/${fileBasenameNoExtension}.o\", // 将要进行调试的程序的路径 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}\", \"externalConsole\": true, \"environment\": [], \"MIMode\": \"gdb\", \"windows\": { \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"miDebuggerPath\": \"C:/Dev/MinGW/mingw64/bin/gdb.exe\" // 修改为本机gdb.exe的路径 }, \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Build\" } ]} 然后解释每一项具体的含义： program：（必填项）指定Debugger程序路径，在这里修改成本机gdb.exe的路径。 symbolSearchPath：指定符号文件的路径。 externalConsole：在Windows中，设置为true调用外部终端，设置为false调用VS Code集成终端；在Linux中，设置为true调用会通知VS Code启动外部终端，设置为false会调用VS Code集成终端；在macOS中，设置为true会通过lldb-mi调用外部终端，设置为false会在Debug面板中显示输出。 args：参数列表。 cwd：终端启动时所在的路径。 environment：环境变量。 MIMode：指定VS Code连接的Debugger的类型，必须是gdb或者lldb中一种。 miDebuggerPath：Debugger路径。如果没有指定完整路径，VS Code会搜索系统变量PATH。 miDebuggerArgs：传递给Debugger的参数列表。 stopAtEntry：是否在程序入口暂停。默认值为false。 type：指定Debugger类型，对于Visual Studio Windows debugger需要指定为cppvsdbg，对于GDB或者LLDB需要指定为cppdbg。 参考： Configuring launch.json for C/C++ debugging 2.4 设置代码格式化在VS Code里可以通过Shift + ALt + F对整篇代码进行格式化，或者选中一段代码通过Ctrl + K Ctrl + F来进行段落的格式化。也可以在设置中设置editor.formatOnSave设定在保存时自动格式化或editor.formatOnType设定在输入时自动格式化。默认VS Code调用Clang Format对代码进行格式化，因此在项目文件夹下新建.clang-format文件来指定格式化样式。由于Clang Format可以设置的项目非常多，因此这里只举例说明： 12345678UseTab: falseIndentWidth: 4BreakBeforeBraces: Stroustrup AllowShortIfStatementsOnASingleLine: falseIndentCaseLabels: trueColumnLimit: 0Standard: Cpp11Cpp11BracedListStyle: true UseTab：用Tab或空格控制缩进。 IndentWidth：缩进长度。 BreakBeforeBraces：在括号前是否换行。 AllowShortIfStatementsOnASingleLine：是否将 if (a) return;放在同一行。 IndentCaseLabels：对于switch语句，case是否缩进。 ColumnLimit：限制一行的长度。 Standard：cpp标准，Cpp03会适应C++03标准，cpp11会适应C++11、C++14和C++17标准。例如， C++03标准的A&lt;A&lt;int&gt; &gt;会被替换为C++11标准的A&lt;A&lt;int&gt;&gt;。 Cpp11BracedListStyle：使用C++11的列表格式： 12345true: false:vector&lt;int&gt; x{1, 2, 3, 4}; vs. vector&lt;int&gt; x{ 1, 2, 3, 4 };vector&lt;T&gt; x{{}, {}, {}, {}}; vector&lt;T&gt; x{ {}, {}, {}, {} };f(MyMap[{composite, key}]); f(MyMap[{ composite, key }]);new int[3]{1, 2, 3}; new int[3]{ 1, 2, 3 }; 参考：Clang-Format Style Options 3 后续完成以上步骤以后你会得到一个.vscode文件夹（包含三个配置文件）以及.clang-format文件。之后再新建项目时直接将这个文件夹复制过去即可。 打开一个.cpp文件然后按F5即可启动调试。按Ctrl + Shift + P然后输入Run Build Task即可编译。输入Run Test Task即可运行。在设置中可以为这两个选项添加快捷键绑定。按Ctrl + Shift + F可以格式化代码。 以上。 参考VS Code 搭建 C/C++ 编译运行环境的三种方案 C/C++ for Visual Studio Code (Preview) c_cpp_properties.json Reference Guide Configuring launch.json for C/C++ debugging Variables Reference Customizing IntelliSense Integrate with External Tools via Tasks Clang-Format Style Options","link":"/2019/03/11/Configure-vscode-for-cpp/"},{"title":"用Hexo搭建一个GitHub个人Blog","text":"不知道有没有人像我一样，想要建立个人主页，可是对JaveScript和PHP都不了解。不过现在好了，基于开源的Hexo，只需1小时，即可在GitHub搭建一个简单又美观的个人主页，并在上面发表你的第一篇文章。Here we go. 目录 准备 配置Git 安装Hexo 部署Hexo 下载主题 个性化你的博客 部署你的Blog 写文章 更多配置 添加站长统计和SiteMap 支持数学公式 添加RSS订阅 节点分流 准备 Node.js Git 选装 Markdown Pad 2 - Markdown编辑器 Visual Studio Code - Markdown编辑器 配置Git首先在GitHub上注册免费账号。接着在账户界面选择+ New repository，在Repository Name中填入用户名.github.io，选择Public，点击Create Respository创建一个目录。这个目录就是你的网站的存储空间。 接下来打开Git Bash，在Git Bash中输入 1cd ~/. ssh 以检查本机的ssh密钥。如果提示：’No such file or directory 说明你是第一次使用Git。 生成新的SSH Key： 123ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;此处直接回车&gt; 这里邮箱地址要填入注册邮箱地址。 然后设置密码： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置SSH Key了： 在本机设置SSH Key后，需要添加SSH Key到GitHub上，为之后的从本地向GitHub上提交网站做准备。 用文本编辑器打开C:\\Users\\用户名.ssh\\id_rsa.pub，里面是刚才生成的密钥。 登录GitHub，在右上角的头像选择Settings -&gt; SSH Key -&gt; New SSH Key，然后将文件中的内容拷贝至Key中即可。Title为这个SSH Key的名称，可以自定。 测试设置结果： 1$ ssh -T git@github.com 如果得到如下反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 此时输入yes即可。然后会看到： 1Hi thesharing! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 说明SSH Key已经设置成功，这台设备的Git Bash已经可以访问你的GitHub了。 接下来需要设置登录信息： 12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的注册邮箱&quot; 到这一步，Git Bash就配置完毕了。 安装HexoHexo 是一个快速、简洁且高效的博客框架。在安装完以上的软件以后，在命令提示行中使用npm命令即可完成安装。 1npm install -g hexo-cli 可能会有网络错误，可以重新执行命令安装。 接下来执行 1npm install 以安装所需的依赖包。 部署Hexo指定一个文件夹作为你的博客存放的文件夹，然后从此文件夹打开命令行，开始部署： 1hexo init 等待一段时间，Hexo会在这个文件夹下建立工作目录。现在本地博客已经建立完毕，执行以下命令： 12hexo generatehexo server 然后在浏览器中访问localhost:4000即可看到初始化的博客内容。 下载主题在Hexo的官方网站Themes|Hexo 上有一些主题可供使用，在Hexo的GitHub主页Themes - hexojs/hexo上提供了更多的主题链接可供下载。你可以选择用Git将主题Clone到本地，以获得主题的实时更新，也可以通过Download Zip将主题下载到本地的hexo文件夹/theme/使用。针对不同主题会有不同的设置项，一般主题的GitHub主页会提供Wiki来帮助设置主页。本次以PPOffice开发的Icarus为例进行主题方面的设置。 个性化你的博客首先要配置你的站点信息，用Visual Studio Code等文本编辑器（不推荐使用记事本，存在一些格式上的问题）打开hexo/_config.yml开始配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Site 站点信息设置title: Zhilong's Blog # 站点标题subtitle: Have a try # 副标题description: Zhilong's personal blog on github # 给搜索引擎看的，对站点的描述，可以自定义author: Thesharing # 网站作者：在站点下方可以看到language: zh-CN # 语言：简体中文 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://thesharing.github.io/ #站点地址root: / #站点的根目录permalink: :year/:month/:day/:title/ #文章默认存放位置的格式，这里表示目录结构为：year/month/day/title.md# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: [readme.md, \"*.html\", \"*.htm\"] # Writing 文章布局、写作格式的定义new_post_name: :title.md # 新文章的文章名，这里是用文章标题作为文件名default_layout: post # 默认的布局，详情查看https://hexo.io/zh-cn/docs/writing.html以获得更多信息auto_spacing: true # 是否在中文字符和英文字符之间自动添加空格titlecase: false # 是否将标题大写external_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true backtick_code_block: true line_number: true tab_replace: # 目录和标签default_category: uncategorized # 默认目录category_map:tag_map:sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server 本地服务器信息## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: falselogger_format: # Date / Time format 日期、时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss # Pagination 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 配置站点所用主题和插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: icarus # 主题 # Deployment 站点部署到github的设置## 官方文档：https://hexo.io/zh-cn/docs/deployment.htmldeploy: type: git repository: https://github.com/thesharing/thesharing.github.io.git # Repository地址 branch: master 可以将其直接复制入你的_config.yml文件中使用。下面解释各项如何修改。 Site按照说明修改即可。 URL将url改为你的博客首地址，可以到GoDaddy上购买域名进行绑定，那么这里就应该改成你的域名而非GitHub.io地址。 Writing - Pagination均不必修改，如自定义请参考官方Doc进行修改。 Theme将Theme修改为你下载的主题的主题名，要注意，theme文件夹下的主题文件夹也要对应名称。 Deploy将repository改为https://github.com/你的用户名/你的用户名.github.io.git，branch不变。 此时第一个配置文件设置结束，我们打开主题的配置文件来配置主题样式。这里以icarus为例，打开hexo/themes/icarus/_config.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235# Version of the Icarus theme that is currently usedversion: 2.3.0# Path or URL to the website's iconfavicon: /images/favicon.png# Path or URL to RSS atom.xmlrss: rss.xml# Path or URL to the website's logo to be shown on the left of the navigation bar or footerlogo: /images/logo.png# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # Navigation bar link settingsnavbar: # Navigation bar menu links menu: 首页: / 归档: /archives 关于: /about # Navigation bar links to be shown on the right links: GitHub: icon: fab fa-github url: 'http://github.com/thesharing/'# Footer section link settingsfooter: # Links to be shown on the right of the footer section links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/'# Article display settingsarticle: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles highlight: pojoaque # Whether to show article thumbnail images thumbnail: false # Whether to show estimate article reading time readtime: true# Search plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# Comment plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: # Name of the comment plugin type: disqus shortname: thesharing# Donation entries# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: '/images/alipay.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: '/images/wechat.jpg' # - # # Donation entry name # type: paypal # # Paypal business ID or email address # business: '' # # Currency code # currency_code: USD # - # # Donation entry name # type: patreon # # URL to the Patreon page # url: ''# Share plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # Share plugin name type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # left sidebar settings left: # Whether the left sidebar is sticky when page scrolls # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # right sidebar settings right: # Whether the right sidebar is sticky when page scrolls # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# Sidebar widget settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # Widget name type: profile # Where should the widget be placed, left or right position: left # Author name to be shown in the profile widget author: Your Name # Title of the author to be shown in the profile widget author_title: Your Title # Author's current location to be shown in the profile widget location: Your Location # Path or URL to the avatar to be shown in the profile widget avatar: /images/avatar.png # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: true # Path or URL for the follow button follow_link: 'http://github.com/thesharing/' # Links to be shown on the bottom of the profile widget social_links: Github: icon: fab fa-github url: '' StackOverflow: icon: fab fa-stack-overflow url: '' Steam: icon: fab fa-steam url: '' Instagram: icon: fab fa-instagram url: '' Weibo: icon: fab fa-weibo url: '' Facebook: icon: fab fa-facebook url: '' Twitter: icon: fab fa-twitter url: '' - # Widget name type: toc # Where should the widget be placed, left or right position: right - # Widget name type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: GitHub - Thesharing: http://github.com/thesharing/ - # Widget name type: recent_posts # Where should the widget be placed, left or right position: right - # Widget name type: archive # Where should the widget be placed, left or right position: right - # Widget name type: category # Where should the widget be placed, left or right position: right - # Widget name type: tag # Where should the widget be placed, left or right position: right - # Widget name type: tagcloud # Where should the widget be placed, left or right position: left# Other plugin settingsplugins: # Enable page animations animejs: true # Enable the lightGallery and Justified Gallery plugins # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/ gallery: true # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated-browser: true # Enable the MathJax plugin # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/ mathjax: true # Show the back to top button on mobile devices back-to-top: true # Google Analytics plugin settings # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics google-analytics: # Google Analytics tracking id tracking_id: # Baidu Analytics plugin settings # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics baidu-analytics: # Baidu Analytics tracking id tracking_id: # Hotjar user feedback plugin # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar # hotjar: # # Hotjar site id # site_id: # Show a loading progress bar at top of the page progressbar: true # Show the copy button in the highlighted code area clipboard: true # BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: false# CDN provider settings# http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL of the JavaScript and/or stylesheet CDN provider cdn: unpkg # Name or URL of the webfont CDN provider fontcdn: google # Name or URL of the webfont Icon CDN provider iconcdn: fontawesome 可配置项 在配置的navbar部分中按照页面名: 页面目录的格式可以自行添加页面。 logo中可以设置Logo以及Logo大小。建议直接替换而非自定目录。 avatar中设置资料页的头像，author为作者名，author_title为作者介绍，location为地区，follow为“关注我”指向的地址。 highlight为语法高亮的主题 sidebar为资料页的位置（左、右） thumbnail设置是否显示缩略图 favicon设置网站图标 social_links设置社交图标 comment设置评论系统，disqus后填入论坛名即可 plugin中设置Google站长分析等插件信息 Disqus进入Disqus完成注册以后，点击右上角的“设置”，选择“Add Disqus To Site”，然后按照向导进行设置即可。这里要注意，Disqus URL中填写的就是上面设置文件中要填写的论坛名。 生成并预览设置完成后，在hexo文件夹下打开命令行输入 12hexo generatehexo server 如果运行成功，那么输入localhost:4000即可打开你的个人主页。 部署你的Blog之前我们一直在本地运行，接下来我们要把个人主页部署到GitHub上去。在每一次对设置的修改以及写文章之后都要用hexo generate命令重新生成一次。然后右击hexo文件夹，选择Git Bash Here，打开Git Bash，在Git Bash中输入 1$ npm install hexo-deployer-git --save 等待安装完成以后，再执行： 1$ hexo deploy 有可能会提示输入邮箱和密码，按照之前设置的输入即可。如果失败可能是网络问题，重新尝试一下。 提示成功以后可以在你的GitHub的该Repository下看到Commit成功+1，说明服务器已经接受了你的提交，一般等待3-5分钟以后，你的Blog便会被刷新。此时用你的用户名.github.io即可访问到你的Blog，怎么样，是不是很Coooool？ 写文章那么说了这么多，个人主页已经建好，接下来就是充实内容了。内容怎么充实呢？写文章咯。 在hexo文件夹下打开命令行，输入： 1hexo new [layout] &lt;title&gt; 这里[layout]是指你所用的模板名称，所有模板都在hexo\\scaffolds\\文件夹下存放，关于模板的更多信息，请访问官方Doc，里面有很详尽的解释。 title则是文章的标题，可以为中文。 在执行完命令后，到hexo\\source\\_posts\\文件夹下可以找到生成的Markdown文件。用MarkdownPad 2或者Visual Studio Code打开Markdown文件即可开始书写你的文章，正如我现在所做。至于Markdown文法，又是一个大坑。 对于图片，我们需要将文章中要用到的图片上传至图床然后引用外链。图床是指存放图片的云存储空间，我个人正在使用的是七牛，可以找一个适合自己的图床一直用下去。 在写完文章以后，再次hexo generate然后部署就可以了。 Markdown教程：如何快速掌握Markdown语法？ Hexo中支持的语法高亮：highlight.js - CSS classes reference 更多配置添加站长统计和SiteMap为了提升在搜索引擎中的搜索权重，可以通过添加站长统计以及提交SiteMap进一步优化SEO。 首先注册百度站长统计和 Google Analytics，获得追踪ID。对于百度站长统计来说，只需要在管理后台的新版统计代码获取页面复制追踪ID至icarus的baidu-analytics - tracking_id即可。对于Google Analytics来说，只需要在管理后台的媒体资源设置页面复制跟踪 ID至icarus的google-analytics - tracking_id即可。 然后需要生成SiteMap。在Hexo根目录下执行： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 安装完成后在Hexo文件夹中的_config.yml中添加： 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 然后运行hexo -g即可生成sitemap.xml和baidusitemap.xml文件。 在生成了SiteMap文件后需要进行提交。 百度提交方式为： 访问链接提交|百度搜索资源平台并用百度账号登录，然后选择自动提交 - sitemap方式填入baidusitemap.xml的地址即可。 Google提交方式为： 访问Search Console，用Google账号登录，下载Google验证网页，将其放入hexo/source文件夹中，同时在Hexo的_config.yml文件中设置渲染排除项： 1skip_render: [readme.md, \"*.html\", \"*.htm\"] 然后运行hexo generate并运行hexo deploy。接着在Search Console的抓取 - 站点地图部分指定sitemap.xml的地址即可。 可参考hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 支持数学公式目前主流的数学公式库为MathJax，对于icarus这样直接支持MathJax的主题，在其_config.yml文件的plugin部分设置mathjax: true即可。 对于不支持MathJax的主题来说，在Hexo根目录下运行： 1npm install --save hexo-math 然后在Hexo的_config.yml文件中设置MathJax： 123456math: engine: 'mathjax' mathjax: src: custom_mathjax_source config: # MATHJAX CONFIG 可参考hexo中插入数学公式 添加RSS订阅首先在Hexo根目录下运行： 1npm install --save hexo-generator-feed 然后在Hexo的_config.yml文件中添加配置： 1234567feed: type: atom path: rss.xml limit: 0 hub: content: true order_by: -date 接着在icarus的_config.yml文件中添加RSS的入口，可以在Navbar部分添加RSS链接： 1234567navbar: # Navigation bar menu links menu: 首页: / 归档: /archives 关于: /about RSS: /rss.xml 也可以在Social Links部分添加： 1234social_links: RSS: icon: fab fa-rss url: '/rss.xml' 可参考为hexo博客添加RSS订阅功能 节点分流如果你已经将你的个人主页挂靠在自己申请的域名上，那么你可以通过域名解析进行节点分流，国外用户访问GitHub，国内用户访问coding.net，从而解决GitHub在国内访问速度慢的问题。 首先在coding.net（现在又称腾讯云开发者平台）注册账号，并新建一个项目，然后在项目设置中开启Pages服务。然后在Hexo的_config.xml文件中设置deploy到多个仓库中： 12345deploy: type: git repository: github: git@github.com:abc/abc.github.io.git tencent: git@git.dev.tencent.com:abc/abc.git 接下来运行hexo d将页面分别部署到两个仓库中。访问coding.net / GitHub提供的原始网址，保证可以正常访问。 再在云服务商的域名解析页面进行设置，添加CNAME记录，境外线路指向abc.github.io，境内线路指向abc.coding.me。等待DNS刷新后就可以进行节点分流了。 推荐阅读 与 参考资料文档 | Hexo Hexo系列教程 - 2 如何搭建一个独立博客——简明Github Pages与Hexo教程 Hexo你的博客 Hexo的GitHub文档（英文） Markdown 语法 问题 Markdown Pad 2 无法正常预览怎么办？ 按照官网提示，安装Awesomium 1.6.6 SDK以及Microsoft’s DirectX End-User Runtimes (June 2010)以后可以解决。","link":"/2016/02/23/Build-a-Github-Blog-with-Hexo/"},{"title":"《Python 工匠：善用变量来改善代码质量》摘录","text":"在GitHub上看到一个内容很赞的Python读物《Python 工匠：善用变量来改善代码质量》，通读一遍学到不少新知识，因此决定把这些有用的Tricks记下来，方便日后查阅。 所有内容摘自https://github.com/piglei/one-python-craftsman，作者piglei Table of Contents 1 当Class不包含方法时，可以用NamedTuple代替 2 自定义对象的True/False 3 在条件判断中使用 all() / any() 4 使用 try/while/for 中 else 分支 5 以r开头的内建字符串函数 6 无穷大float(&quot;inf&quot;)和负无穷大float(&quot;-inf&quot;) 7 当需要频繁在list前端插入元素时，考虑用collections.deque 8 用collcetions.defaultdict统计次数 9 字典操作 10 next()函数 11 使用partial构造新函数 12 使用 product扁平化多层嵌套循环 13 使用 islice实现循环内隔行处理 14 使用 takewhile 替代 break 语句 15 尝试用类来实现装饰器 16 使用 wrapt 模块编写更扁平的装饰器 17 使用 pathlib 模块改写代码 1 当Class不包含方法时，可以用NamedTuple代替1234567891011from collections import namedtupleAddress = namedtuple(\"Address\", ['country', 'province', 'city'])addr = Address( country='China', province='Beijing', city='Beijing' )print(addr.country) 2 自定义对象的True/False在Python内，对象的布尔值由__bool__和__len__返回，如果未定义__bool__则返回__len__ != 0的值。 因此可以通过定义__bool__和__len__来直接定义对象的True/False。 1234567891011121314class UserCollection: def __init__(self, users): self._users = users def __len__(self): return len(self._users)users = UserCollection([piglei, raymond])# 定义了 __len__ 方法后，UserCollection 对象本身就可以被用于布尔判断了if users: print(\"There's some users in collection!\") 3 在条件判断中使用 all() / any()all() 和 any() 两个函数非常适合在条件判断中使用。这两个函数接受一个可迭代对象，返回一个布尔值，其中： all(seq)：仅当 seq 中所有对象都为布尔真时返回 True，否则返回 False any(seq)：只要 seq 中任何一个对象为布尔真就返回 True，否则返回 False 假如我们有下面这段代码： 12345678910def all_numbers_gt_10(numbers): \"\"\"仅当序列中所有数字大于 10 时，返回 True \"\"\" if not numbers: return False for n in numbers: if n &lt;= 10: return False return True 如果使用 all() 内建函数，再配合一个简单的生成器表达式，上面的代码可以写成这样： 12def all_numbers_gt_10_2(numbers): return bool(numbers) and all(n &gt; 10 for n in numbers) 4 使用 try/while/for 中 else 分支让我们看看这个函数： 123456789101112def do_stuff(): first_thing_successed = False try: do_the_first_thing() first_thing_successed = True except Exception as e: print(&quot;Error while calling do_some_thing&quot;) return # 仅当 first_thing 成功完成时，做第二件事 if first_thing_successed: return do_the_second_thing() 在函数 do_stuff 中，我们希望只有当 do_the_first_thing() 成功调用后（也就是不抛出任何异常），才继续做第二个函数调用。为了做到这一点，我们需要定义一个额外的变量 first_thing_successed 来作为标记。 其实，我们可以用更简单的方法达到同样的效果： 12345678def do_stuff(): try: do_the_first_thing() except Exception as e: print(&quot;Error while calling do_some_thing&quot;) return else: return do_the_second_thing() 在 try 语句块最后追加上 else 分支后，分支下的do_the_second_thing() 便只会在 try 下面的所有语句正常执行（也就是没有异常，没有 return、break 等）完成后执行。 类似的，Python 里的 for/while 循环也支持添加 else 分支，它们表示：当循环使用的迭代对象被正常耗尽、或 while 循环使用的条件变量变为 False 后才执行 else 分支下的代码。 5 以r开头的内建字符串函数Python 的字符串有着非常多实用的内建方法，最常用的有 .strip()、.split() 等。这些内建方法里的大多数，处理起来的顺序都是从左往右。但是其中也包含了部分以 r 打头的从右至左处理的镜像方法。在处理特定逻辑时，使用它们可以让你事半功倍。 假设我们需要解析一些访问日志，日志格式为：”{user_agent}” {content_length}： 1&gt;&gt;&gt; log_line = &apos;&quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot; 47632&apos; 如果使用 .split() 将日志拆分为 (user_agent, content_length)，我们需要这么写： 123&gt;&gt;&gt; l = log_line.split()&gt;&gt;&gt; \" \".join(l[:-1]), l[-1]('\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\"', '47632') 但是如果使用 .rsplit() 的话，处理逻辑就更直接了： 12&gt;&gt;&gt; log_line.rsplit(None, 1)['\"AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36\"', '47632'] 6 无穷大float(&quot;inf&quot;)和负无穷大float(&quot;-inf&quot;)7 当需要频繁在list前端插入元素时，考虑用collections.deque8 用collcetions.defaultdict统计次数12345678from collections import defaultdictdef counter_by_collections(l): result = defaultdict(int) for key in l: result[key] += 1 return result 9 字典操作 如果移除字典成员，不关心是否存在： 调用 pop 函数时设置默认值，比如 dict.pop(key, None) 在字典获取成员时指定默认值：dict.get(key, default_value) 对列表进行不存在的切片访问不会抛出 IndexError 异常：[&quot;foo&quot;][100:200] 10 next()函数next() 是一个非常实用的内建函数，它接收一个迭代器作为参数，然后返回该迭代器的下一个元素。使用它配合生成器表达式，可以高效的实现“从列表中查找第一个满足条件的成员”之类的需求。 1234numbers = [3, 7, 8, 2, 21]# 获取并立即返回列表里的第一个偶数print(next(i for i in numbers if i % 2 == 0))# OUTPUT: 8 11 使用partial构造新函数假设这么一个场景，在你的代码里有一个参数很多的函数 A，适用性很强。而另一个函数 B 则是完全通过调用 A 来完成工作，是一种类似快捷方式的存在。 比方在这个例子里， double 函数就是完全通过 multiply 来完成计算的： 1234567def multiply(x, y): return x * ydef double(value): # 返回另一个函数调用结果 return multiply(2, value) 对于上面这种场景，我们可以使用 functools 模块里的 partial() 函数来简化它。 partial(func, *args, **kwargs) 基于传入的函数与可变（位置/关键字）参数来构造一个新函数。所有对新函数的调用，都会在合并了当前调用参数与构造参数后，代理给原始函数处理。 利用 partial 函数，上面的 double 函数定义可以被修改为单行表达式，更简洁也更直接。 123import functoolsdouble = functools.partial(multiply, 2) 建议阅读：partial 函数官方文档 12 使用 product扁平化多层嵌套循环虽然我们都知道“扁平的代码比嵌套的好”。但有时针对某类需求，似乎一定得写多层嵌套循环才行。比如下面这段： 12345678def find_twelve(num_list1, num_list2, num_list3): &quot;&quot;&quot;从 3 个数字列表中，寻找是否存在和为 12 的 3 个数 &quot;&quot;&quot; for num1 in num_list1: for num2 in num_list2: for num3 in num_list3: if num1 + num2 + num3 == 12: return num1, num2, num3 对于这种需要嵌套遍历多个对象的多层循环代码，我们可以使用 product() 函数来优化它。product() 可以接收多个可迭代对象，然后根据它们的笛卡尔积不断生成结果。 1234567from itertools import productdef find_twelve_v2(num_list1, num_list2, num_list3): for num1, num2, num3 in product(num_list1, num_list2, num_list3): if num1 + num2 + num3 == 12: return num1, num2, num3 相比之前的代码，使用 product() 的函数只用了一层 for 循环就完成了任务，代码变得更精炼了。 13 使用 islice实现循环内隔行处理有一份包含 Reddit 帖子标题的外部数据文件，里面的内容格式是这样的： 1234567python-guide: Python best practices guidebook, written for humans.---Python 2 Death Clock---Run any Python Script with an Alexa Voice Command---&lt;... ...&gt; 可能是为了美观，在这份文件里的每两个标题之间，都有一个 &quot;---&quot; 分隔符。现在，我们需要获取文件里所有的标题列表，所以在遍历文件内容的过程中，必须跳过这些无意义的分隔符。 参考之前对 enumerate() 函数的了解，我们可以通过在循环内加一段基于当前循环序号的 if 判断来做到这一点： 12345678def parse_titles(filename): &quot;&quot;&quot;从隔行数据文件中读取 reddit 主题名称 &quot;&quot;&quot; with open(filename, &apos;r&apos;) as fp: for i, line in enumerate(fp): # 跳过无意义的 &apos;---&apos; 分隔符 if i % 2 == 0: yield line.strip() 但对于这类在循环内进行隔行处理的需求来说，如果使用 itertools 里的 islice() 函数修饰被循环对象，可以让循环体代码变得更简单直接。 islice(seq, start, end, step) 函数和数组切片操作（ list[start:stop:step] ）有着几乎一模一样的参数。如果需要在循环内部进行隔行处理的话，只要设置第三个递进步长参数 step 值为 2 即可（默认为 1）。 1234567from itertools import islicedef parse_titles_v2(filename): with open(filename, &apos;r&apos;) as fp: # 设置 step=2，跳过无意义的 &apos;---&apos; 分隔符 for line in islice(fp, 0, None, 2): yield line.strip() 14 使用 takewhile 替代 break 语句有时，我们需要在每次循环开始时，判断循环是否需要提前结束。比如下面这样： 123456for user in users: # 当第一个不合格的用户出现后，不再进行后面的处理 if not is_qualified(user): break # 进行处理 ... ... 对于这类需要提前中断的循环，我们可以使用 takewhile() 函数来简化它。takewhile(predicate, iterable) 会在迭代 iterable 的过程中不断使用当前对象作为参数调用 predicate 函数并测试返回结果，如果函数返回值为真，则生成当前对象，循环继续。否则立即中断当前循环。 使用 takewhile 的代码样例： 1234from itertools import takewhilefor user in takewhile(is_qualified, users): # 进行处理 ... ... itertools 里面还有一些其他有意思的工具函数，他们都可以用来和循环搭配使用，比如使用 chain 函数扁平化双层嵌套循环、使用 zip_longest 函数一次同时循环多个对象等等。 itertools — Functions creating iterators for efficient looping Infinite iterators: Iterator Arguments Results Example count() start, [step] start, start+step, start+2*step, … count(10) --&gt; 10 11 12 13 14 ... cycle() p p0, p1, … plast, p0, p1, … cycle('ABCD') --&gt; A B C D A B C D ... repeat() elem [,n] elem, elem, elem, … endlessly or up to n times repeat(10, 3) --&gt; 10 10 10 Iterators terminating on the shortest input sequence: Iterator Arguments Results Example accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) --&gt; 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain('ABC', 'DEF') --&gt; A B C D E F chain.from_iterable() iterable p0, p1, … plast, q0, q1, … chain.from_iterable(['ABC', 'DEF']) --&gt; A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress('ABCDEF', [1,0,1,0,1,1]) --&gt; A C E F dropwhile() pred, seq seq[n], seq[n+1], starting when pred fails dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 6 4 1 filterfalse() pred, seq elements of seq where pred(elem) is false filterfalse(lambda x: x%2, range(10)) --&gt; 0 2 4 6 8 groupby() iterable[, key] sub-iterators grouped by value of key(v) islice() seq, [start,] stop [, step] elements from seq[start:stop:step] islice('ABCDEFG', 2, None) --&gt; C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) --&gt; 32 9 1000 takewhile() pred, seq seq[0], seq[1], until pred fails takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --&gt; 1 4 tee() it, n it1, it2, … itn splits one iterator into n zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest('ABCD', 'xy', fillvalue='-') --&gt; Ax By C- D- Combinatoric iterators: Iterator Arguments Results product() p, q, … [repeat=1] cartesian product, equivalent to a nested for-loop permutations() p[, r] r-length tuples, all possible orderings, no repeated elements combinations() p, r r-length tuples, in sorted order, no repeated elements combinations_with_replacement() p, r r-length tuples, in sorted order, with repeated elements product('ABCD', repeat=2) AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD permutations('ABCD', 2) AB AC AD BA BC BD CA CB CD DA DB DC combinations('ABCD', 2) AB AC AD BC BD CD combinations_with_replacement('ABCD', 2) AA AB AC AD BB BC BD CC CD DD 15 尝试用类来实现装饰器绝大多数装饰器都是基于函数和 闭包) 实现的，但这并非制造装饰器的唯一方式。事实上，Python 对某个对象是否能通过装饰器（@decorator）形式使用只有一个要求：decorator 必须是一个“可被调用（callable）的对象。 1234567# 使用 callable 可以检测某个对象是否“可被调用”&gt;&gt;&gt; def foo(): pass...&gt;&gt;&gt; type(foo)&lt;class &apos;function&apos;&gt;&gt;&gt;&gt; callable(foo)True 函数自然是“可被调用”的对象。但除了函数外，我们也可以让任何一个类（class）变得“可被调用”（callable）。办法很简单，只要自定义类的 __call__ 魔法方法即可。 1234567891011class Foo: def __call__(self): print(&quot;Hello, __call___&quot;)foo = Foo()# OUTPUT: Trueprint(callable(foo))# 调用 foo 实例# OUTPUT: Hello, __call__foo() 基于这个特性，我们可以很方便的使用类来实现装饰器。 下面这段代码，会定义一个名为 @delay(duration) 的装饰器，使用它装饰过的函数在每次执行前，都会等待额外的 duration 秒。同时，我们也希望为用户提供无需等待马上执行的 eager_call 接口。 12345678910111213141516171819202122232425import timeimport functoolsclass DelayFunc: def __init__(self, duration, func): self.duration = duration self.func = func def __call__(self, *args, **kwargs): print(f&apos;Wait for {self.duration} seconds...&apos;) time.sleep(self.duration) return self.func(*args, **kwargs) def eager_call(self, *args, **kwargs): print(&apos;Call without delay&apos;) return self.func(*args, **kwargs)def delay(duration): &quot;&quot;&quot;装饰器：推迟某个函数的执行。同时提供 .eager_call 方法立即执行 &quot;&quot;&quot; # 此处为了避免定义额外函数，直接使用 functools.partial 帮助构造 # DelayFunc 实例 return functools.partial(DelayFunc, duration) 如何使用装饰器的样例代码： 123456789@delay(duration=2)def add(a, b): return a + b# 这次调用将会延迟 2 秒add(1, 2)# 这次调用将会立即执行add.eager_call(1, 2) @delay(duration) 就是一个基于类来实现的装饰器。当然，如果你非常熟悉 Python 里的函数和闭包，上面的 delay 装饰器其实也完全可以只用函数来实现。所以，为什么我们要用类来做这件事呢？ 与纯函数相比，我觉得使用类实现的装饰器在特定场景下有几个优势： 实现有状态的装饰器时，操作类属性比操作闭包内变量更符合直觉、不易出错 实现为函数扩充接口的装饰器时，使用类包装函数，比直接为函数对象追加属性更易于维护 更容易实现一个同时兼容装饰器与上下文管理器协议的对象（参考 unitest.mock.patch） 16 使用 wrapt 模块编写更扁平的装饰器在写装饰器的过程中，你有没有碰到过什么不爽的事情？不管你有没有，反正我有。我经常在写代码的时候，被下面两件事情搞得特别难受： 实现带参数的装饰器时，层层嵌套的函数代码特别难写、难读 因为函数和类方法的不同，为前者写的装饰器经常没法直接套用在后者上 比如，在下面的例子里，我实现了一个生成随机数并注入为函数参数的装饰器。 1234567891011121314151617181920212223import randomdef provide_number(min_num, max_num): &quot;&quot;&quot;装饰器：随机生成一个在 [min_num, max_num] 范围的整数，追加为函数的第一个位置参数 &quot;&quot;&quot; def wrapper(func): def decorated(*args, **kwargs): num = random.randint(min_num, max_num) # 将 num 作为第一个参数追加后调用函数 return func(num, *args, **kwargs) return decorated return wrapper @provide_number(1, 100)def print_random_number(num): print(num)# 输出 1-100 的随机整数# OUTPUT: 72print_random_number() @provide_number 装饰器功能看上去很不错，但它有着我在前面提到的两个问题：嵌套层级深、无法在类方法上使用。如果直接用它去装饰类方法，会出现下面的情况： 1234567class Foo: @provide_number(1, 100) def print_random_number(self, num): print(num)# OUTPUT: &lt;__main__.Foo object at 0x104047278&gt;Foo().print_random_number() Foo 类实例中的 print_random_number 方法将会输出类实例 self ，而不是我们期望的随机数 num。 之所以会出现这个结果，是因为类方法（method）和函数（function）二者在工作机制上有着细微不同。如果要修复这个问题，provider_number 装饰器在修改类方法的位置参数时，必须聪明的跳过藏在 *args 里面的类实例 self 变量，才能正确的将 num 作为第一个参数注入。 这时，就应该是 wrapt 模块闪亮登场的时候了。wrapt 模块是一个专门帮助你编写装饰器的工具库。利用它，我们可以非常方便的改造 provide_number 装饰器，完美解决“嵌套层级深”和“无法通用”两个问题， 1234567891011121314151617181920212223242526import wraptdef provide_number(min_num, max_num): @wrapt.decorator def wrapper(wrapped, instance, args, kwargs): # 参数含义： # # - wrapped：被装饰的函数或类方法 # - instance： # - 如果被装饰者为普通类方法，该值为类实例 # - 如果被装饰者为 classmethod 类方法，该值为类 # - 如果被装饰者为类/函数/静态方法，该值为 None # # - args：调用时的位置参数（注意没有 * 符号） # - kwargs：调用时的关键字参数（注意没有 ** 符号） # num = random.randint(min_num, max_num) # 无需关注 wrapped 是类方法或普通函数，直接在头部追加参数 args = (num,) + args return wrapped(*args, **kwargs) return wrapper &lt;... 应用装饰器部分代码省略 ...&gt; # OUTPUT: 48Foo().print_random_number() 使用 wrapt 模块编写的装饰器，相比原来拥有下面这些优势： 嵌套层级少：使用 `@wrapt.decorator` 可以将两层嵌套减少为一层 更简单：处理位置与关键字参数时，可以忽略类实例等特殊情况 更灵活：针对 instance 值进行条件判断后，更容易让装饰器变得通用 17 使用 pathlib 模块改写代码为了让文件处理变得更简单，Python 在 3.4 版本引入了一个新的标准库模块：pathlib。它基于面向对象思想设计，封装了非常多与文件操作相关的功能。如果使用它来改写上面的代码，结果会大不相同。 使用 pathlib 模块后的代码： 12345from pathlib import Pathdef unify_ext_with_pathlib(path): for fpath in Path(path).glob(&apos;*.txt&apos;): fpath.rename(fpath.with_suffix(&apos;.csv&apos;)) 和旧代码相比，新函数只需要两行代码就完成了工作。而这两行代码主要做了这么几件事： 首先使用 Path(path) 将字符串路径转换为 Path 对象 调用 .glob(‘*.txt’) 对路径下所有内容进行模式匹配并以生成器方式返回，结果仍然是 Path 对象，所以我们可以接着做后面的操作 使用 .with_suffix(‘.csv’) 直接获取使用新后缀名的文件全路径 调用 .rename(target) 完成重命名 相比 os 和 os.path，引入 pathlib 模块后的代码明显更精简，也更有整体统一感。所有文件相关的操作都是一站式完成。 其他用法 除此之外，pathlib 模块还提供了很多有趣的用法。比如使用 / 运算符来组合文件路径： 123456789# 😑 旧朋友：使用 os.path 模块&gt;&gt;&gt; import os.path&gt;&gt;&gt; os.path.join(&apos;/tmp&apos;, &apos;foo.txt&apos;)&apos;/tmp/foo.txt&apos;# ✨ 新潮流：使用 / 运算符&gt;&gt;&gt; from pathlib import Path&gt;&gt;&gt; Path(&apos;/tmp&apos;) / &apos;foo.txt&apos;PosixPath(&apos;/tmp/foo.txt&apos;) 或者使用 .read_text() 来快速读取文件内容： 12345678910# 标准做法，使用 with open(...) 打开文件&gt;&gt;&gt; with open(&apos;foo.txt&apos;) as file:... print(file.read())...foo# 使用 pathlib 可以让这件事情变得更简单&gt;&gt;&gt; from pathlib import Path&gt;&gt;&gt; print(Path(&apos;foo.txt&apos;).read_text())foo 除了我在文章里介绍的这些，pathlib 模块还提供了非常多有用的方法，强烈建议去 官方文档 详细了解一下。 如果上面这些都不足以让你动心，那么我再多给你一个使用 pathlib 的理由：PEP-519 里定义了一个专门用于“文件路径”的新对象协议，这意味着从该 PEP 生效后的 Python 3.6 版本起，pathlib 里的 Path 对象，可以和以前绝大多数只接受字符串路径的标准库函数兼容使用： 1234&gt;&gt;&gt; p = Path(&apos;/tmp&apos;)# 可以直接对 Path 类型对象 p 进行 join&gt;&gt;&gt; os.path.join(p, &apos;foo.txt&apos;)&apos;/tmp/foo.txt&apos; 所以，无需犹豫，赶紧把 pathlib 模块用起来吧。 Hint: 如果你使用的是更早的 Python 版本，可以尝试安装 pathlib2 模块 。","link":"/2019/12/02/Pythonic-Readding-Note/"},{"title":"用Markdown写公式","text":"在写课堂报告的时候，用Latex会比较笨重，用Word插入公式又太麻烦，用Markdown则恰如其分，因此这篇文章主要涉及如何在Markdown中使用Mathjax，参考LaTeX语法来书写公式。公式可以在Typora里导出成PDF文档。 一、公式使用参考 插入公式 上下标 括号和分隔符 输入分数 输入开方 省略号 输入矢量 输入积分 极限运算 累加、累乘运算 希腊字母 其他特殊字符 字体转换 大括号和行标的使用 其他命令 二、矩阵使用参考 无框矩阵 边框矩阵 带省略符号的矩阵 带分割符号的矩阵 行中矩阵 三、方程式序列使用参考 方程式序列 在一个方程式序列的每一行中注明原因 四、条件表达式使用参考 条件表达式 左侧对齐的条件表达式 使条件表达式适配行高 五、数组与表格使用参考 数组或表格 嵌套的数组或表格 方程组 六、连分数使用参考 连分式 七、交换图表使用参考 交换图表 八、一些特殊的注意事项 Reference 一、公式使用参考插入公式$\\LaTeX{}$的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下方法表示： 1$ 数学公式 $ 独立公式可以用如下方法表示： 1$$ 数学公式 $$ 自动编号的公式可以用如下方法表示： 若需要手动编号，参见 大括号和行标的使用。 1234\\begin{equation}数学公式\\label{eq:当前公式名}\\end{equation} 自动编号后的公式可在全文任意处使用\\eqref{eq:公式名}语句引用。 例： 1$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 行内公式：$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 例： 1$$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ $$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ 例： 123\\begin{equation}E=mc^2 \\text{，自动编号公式示例}\\end{equation} $$\\begin{equation}E=mc^2 \\text{，自动编号公式示例}\\end{equation}$$ 上下标^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例： 1$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ 另外，如果要在左右两边都有上下标，可以用 \\sideset 命令。 例： 1$$ \\sideset{^1_2}{^3_4}\\bigotimes $$ $$ \\sideset{^1_2}{^3_4}\\bigotimes $$ 括号和分隔符()、[] 和 | 表示符号本身，使用 \\{\\} 来表示 {} 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号： 输入 显示 输入 显示 \\langle $\\langle$ \\rangle $\\rangle$ \\lceil $\\lceil$ \\rceil $\\rceil$ \\lfloor $\\lfloor$ \\rfloor $\\rfloor$ \\lbrace $\\lbrace$ \\rbrace $\\rbrace$ 例：1$$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ $$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ 有时候要用 \\left. 或 \\right. 进行匹配而不显示本身。 例：1$$ \\left \\frac{{\\rm d}u}{{\\rm d}x} \\right | _{x=0} $$ 输入分数通常使用 \\frac {分子} {分母} 命令产生一个分数，分数可嵌套。便捷情况可直接输入 \\frac ab 来快速生成一个 $\\frac ab$。如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 例：1$$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ $$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ 输入开方使用 \\sqrt [根指数，省略时为2] {被开方数} 命令输入开方。 例：1$$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ 省略号数学公式中常见的省略号有两种，\\ldots 表示与文本底线对齐的省略号，\\cdots 表示与文本中线对齐的省略号。 例：1$$f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2$$ $$f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2$$ 输入矢量使用 \\vec{矢量} 来自动产生一个矢量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。 例：1$$\\vec{a} \\cdot \\vec{b}=0$$ $$\\vec{a} \\cdot \\vec{b}=0$$ 例：1$$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ $$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ 输入积分使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 例：1$$\\int_0^1 {x^2} \\,{\\rm d}x$$ $$\\int_0^1 {x^2} \\,{\\rm d}x$$ 本例中 \\, 和 {\\rm d} 部分可省略，但建议加入，能使式子更美观。 极限运算使用 \\lim_{变量 \\to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例：1$$ \\lim_{n \\to +\\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} $$ $$\\lim_{n \\to +\\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)}$$ 累加、累乘运算使用 \\sum_{下标表达式}^{上标表达式} {累加表达式} 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集。此类符号在行内显示时上下标表达式将会移至右上角和右下角。 例：1$$\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} R$$ $$\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} R$$ 希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha $\\alpha$ A $A$ \\beta $\\beta$ B $B$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ E $E$ \\zeta $\\zeta$ Z $Z$ \\eta $\\eta$ H $H$ \\theta $\\theta$ \\Theta $\\Theta$ \\iota $\\iota$ I $I$ \\kappa $\\kappa$ K $K$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\mu $\\mu$ M $M$ \\nu $\\nu$ N $N$ \\xi $\\xi$ \\Xi $\\Xi$ o $o$ O $O$ \\pi $\\pi$ \\Pi $\\Pi$ \\rho $\\rho$ P $P$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\tau $\\tau$ T $T$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\phi $\\phi$ \\Phi $\\Phi$ \\chi $\\chi$ X $X$ \\psi $\\psi$ \\Psi $\\Psi$ \\omega $\\omega$ \\Omega $\\Omega$ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon $\\epsilon \\mid E \\mid \\varepsilon$ \\theta \\Theta \\vartheta $\\theta \\mid \\Theta \\mid \\vartheta$ \\rho P \\varrho $\\rho \\mid P \\mid \\varrho$ \\sigma \\Sigma \\varsigma $\\sigma \\mid \\Sigma \\mid \\varsigma$ \\phi \\Phi \\varphi $\\phi \\mid \\Phi \\mid \\varphi$ 其他特殊字符若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。 若找不到需要的符号，使用$\\rm{Detexify^2}$来画出想要的符号。 (1) 关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ (2) 集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ (3) 对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ (4) 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ $30^\\circ$ \\bot $\\bot$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ (5) 微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\iiiint $\\iiiint$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ (6) 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not&lt; $\\not&lt;$ \\not&gt; $\\not&gt;$ \\not= $\\not=$ (7) 戴帽符号 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\check{x} $\\check{x}$ \\breve{y} $\\breve{y}$ \\grave{x} $\\grave{x}$ \\acute{y} $\\acute{y}$ (8) 连线符号 输入 显示 \\fbox{a+b+c+d} $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ (9) 箭头符号 推荐使用符号： 输入 显示 输入 显示 输入 显示 \\to $\\to$ \\mapsto $\\mapsto$ \\implies $\\implies$ \\iff $\\iff$ \\impliedby $\\impliedby$ 其它可用符号： 输入 显示 输入 显示 \\uparrow $\\uparrow$ \\Uparrow $\\Uparrow$ \\downarrow $\\downarrow$ \\Downarrow $\\Downarrow$ \\leftarrow $\\leftarrow$ \\Leftarrow $\\Leftarrow$ \\rightarrow $\\rightarrow$ \\Rightarrow $\\Rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ 字体转换若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 。 示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 $\\rm{Sample}$ \\cal 花体 $\\cal{Sample}$ \\it 意大利体 $\\it{Sample}$ \\Bbb 黑板粗体 $\\Bbb{Sample}$ \\bf 粗体 $\\bf{Sample}$ \\mit 数学斜体 $\\mit{Sample}$ \\sf 等线体 $\\sf{Sample}$ \\scr 手写体 $\\scr{Sample}$ \\tt 打字机体 $\\tt{Sample}$ \\frak 旧德式字体 $\\frak{Sample}$ 转换字体十分常用，例如在积分中： 例：1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array}$$ 注意比较两个式子间$dx$与${\\rm d}x$的不同。使用 \\operatorname 命令也可以达到相同的效果，详见 定义新的符号 \\operatorname 定义新的符号 \\operatorname) 。 大括号和行标的使用使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 。在每个公式末尾前使用 \\tag{行标} 来实现行标。 例：123456789101112131415$$f\\left( \\left[ \\frac{ 1+\\left\\{x,y\\right\\} }{ \\left( \\frac{x}{y}+\\frac{y}{x} \\right) \\left(u+1\\right) }+a \\right]^{3/2}\\right)\\tag{行标}$$ $$f\\left( \\left[ \\frac{ 1+\\left\\{x,y\\right\\} }{ \\left( \\frac{x}{y}+\\frac{y}{x} \\right) \\left(u+1\\right) }+a \\right]^{3/2}\\right)\\tag{行标}$$ 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个”影子”括号： 例：123456$$\\begin{aligned}a=&amp;\\left(1+2+3+ \\cdots \\right. \\\\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end{aligned}$$ $$\\begin{aligned}a=&amp;\\left(1+2+3+ \\cdots \\right. \\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end{aligned}$$ 如果你需要将行内显示的分隔符也变大，可以使用 \\middle 命令： 例：123456789$$\\left\\langle q\\middle\\| \\frac{\\frac{x}{y}}{\\frac{u}{v}}\\middle| p \\right\\rangle$$ $$\\left\\langle q\\middle| \\frac{\\frac{x}{y}}{\\frac{u}{v}}\\middle| p\\right\\rangle$$ 其他命令(1) 定义新的符号 \\operatorname查询 关于此命令的定义 和 关于此命令的讨论 来进一步了解此命令。 例：：1$$ \\operatorname{Symbol} A $$ $$ \\operatorname{Symbol} A $$ (2) 添加注释文字 \\text在 \\text {文字} 中仍可以使用 $公式$ 插入其它公式。 例：：1$$ f(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} $$ $$ f(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} $$ (3) 在字符间加入空格有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 例：：1$$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$ $$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$ 当然，使用 \\text {n个空格} 也可以达到同样效果。 (4) 更改文字颜色使用 \\color{颜色}{文字} 来更改特定的文字颜色。更改文字颜色 需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。 对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black $\\color{black}{text}$ grey $\\color{grey}{text}$ silver $\\color{silver}{text}$ white $\\color{white}{text}$ maroon $\\color{maroon}{text}$ red $\\color{red}{text}$ yellow $\\color{yellow}{text}$ lime $\\color{lime}{text}$ olive $\\color{olive}{text}$ green $\\color{green}{text}$ teal $\\color{teal}{text}$ auqa $\\color{auqa}{text}$ blue $\\color{blue}{text}$ navy $\\color{navy}{text}$ purple $\\color{purple}{text}$ fuchsia $\\color{fuchsia}{text}$ 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持： 输入 \\color #rgb text 来自定义更多的颜色，其中 #rgb 的 r g b 可输入 0-9 和 a-f 来表示红色、绿色和蓝色的纯度（饱和度）。 例：：12345678910111213$$\\begin{array}{|rrrrrrrr|}\\hline\\verb+#000+ &amp; \\color{#000}{text} &amp; &amp; &amp;\\verb+#00F+ &amp; \\color{#00F}{text} &amp; &amp; \\\\&amp; &amp; \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp;&amp; &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\\\verb+#F00+ &amp; \\color{#F00}{text} &amp; &amp; &amp;\\verb+#F0F+ &amp; \\color{#F0F}{text} &amp; &amp; \\\\&amp; &amp; \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp;&amp; &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\\\hline\\end{array}$$ 例：： 1234567891011121314151617181920$$\\begin{array}{|rrrrrrrr|}\\hline\\verb+#000+ &amp; \\color{#000}{text} &amp; \\verb+#005+ &amp; \\color{#005}{text} &amp; \\verb+#00A+ &amp; \\color{#00A}{text} &amp; \\verb+#00F+ &amp; \\color{#00F}{text} \\\\\\verb+#500+ &amp; \\color{#500}{text} &amp; \\verb+#505+ &amp; \\color{#505}{text} &amp; \\verb+#50A+ &amp; \\color{#50A}{text} &amp; \\verb+#50F+ &amp; \\color{#50F}{text} \\\\\\verb+#A00+ &amp; \\color{#A00}{text} &amp; \\verb+#A05+ &amp; \\color{#A05}{text} &amp; \\verb+#A0A+ &amp; \\color{#A0A}{text} &amp; \\verb+#A0F+ &amp; \\color{#A0F}{text} \\\\\\verb+#F00+ &amp; \\color{#F00}{text} &amp; \\verb+#F05+ &amp; \\color{#F05}{text} &amp; \\verb+#F0A+ &amp; \\color{#F0A}{text} &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} \\\\\\hline\\verb+#080+ &amp; \\color{#080}{text} &amp; \\verb+#085+ &amp; \\color{#085}{text} &amp; \\verb+#08A+ &amp; \\color{#08A}{text} &amp; \\verb+#08F+ &amp; \\color{#08F}{text} \\\\\\verb+#580+ &amp; \\color{#580}{text} &amp; \\verb+#585+ &amp; \\color{#585}{text} &amp; \\verb+#58A+ &amp; \\color{#58A}{text} &amp; \\verb+#58F+ &amp; \\color{#58F}{text} \\\\\\verb+#A80+ &amp; \\color{#A80}{text} &amp; \\verb+#A85+ &amp; \\color{#A85}{text} &amp; \\verb+#A8A+ &amp; \\color{#A8A}{text} &amp; \\verb+#A8F+ &amp; \\color{#A8F}{text} \\\\\\verb+#F80+ &amp; \\color{#F80}{text} &amp; \\verb+#F85+ &amp; \\color{#F85}{text} &amp; \\verb+#F8A+ &amp; \\color{#F8A}{text} &amp; \\verb+#F8F+ &amp; \\color{#F8F}{text} \\\\\\hline\\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; \\verb+#0F5+ &amp; \\color{#0F5}{text} &amp; \\verb+#0FA+ &amp; \\color{#0FA}{text} &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\\\verb+#5F0+ &amp; \\color{#5F0}{text} &amp; \\verb+#5F5+ &amp; \\color{#5F5}{text} &amp; \\verb+#5FA+ &amp; \\color{#5FA}{text} &amp; \\verb+#5FF+ &amp; \\color{#5FF}{text} \\\\\\verb+#AF0+ &amp; \\color{#AF0}{text} &amp; \\verb+#AF5+ &amp; \\color{#AF5}{text} &amp; \\verb+#AFA+ &amp; \\color{#AFA}{text} &amp; \\verb+#AFF+ &amp; \\color{#AFF}{text} \\\\\\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; \\verb+#FF5+ &amp; \\color{#FF5}{text} &amp; \\verb+#FFA+ &amp; \\color{#FFA}{text} &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\\\hline\\end{array}$$ (5) 添加删除线使用删除线功能必须声明 $$ 符号。 在公式内使用 \\require{cancel} 来允许 片段删除线 的显示。声明片段删除线后，使用 \\cancel{字符}、\\bcancel{字符}、\\xcancel{字符} 和 \\cancelto{字符} 来实现各种片段删除线效果。 例：：12345678910$$\\require{cancel}\\begin{array}{rl}\\verb|y+\\cancel{x}| &amp; y+\\cancel{x} \\\\\\verb|\\cancel{y+x}| &amp; \\cancel{y+x} \\\\\\verb|y+\\bcancel{x}| &amp; y+\\bcancel{x} \\\\\\verb|y+\\xcancel{x}| &amp; y+\\xcancel{x} \\\\\\verb|y+\\cancelto{0}{x}| &amp; y+\\cancelto{0}{x} \\\\\\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+&amp; \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\\\end{array}$$ $$\\require{cancel}\\begin{array}{rl}\\verb|y+\\cancel{x}| &amp; y+\\cancel{x} \\\\\\verb|\\cancel{y+x}| &amp; \\cancel{y+x} \\\\\\verb|y+\\bcancel{x}| &amp; y+\\bcancel{x} \\\\\\verb|y+\\xcancel{x}| &amp; y+\\xcancel{x} \\\\\\verb|y+\\cancelto{0}{x}| &amp; y+\\cancelto{0}{x} \\\\\\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+&amp; \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\\\end{array}$$ 使用 \\require{enclose} 来允许 整段删除线 的显示。声明整段删除线后，使用 \\enclose{删除线效果}{字符} 来实现各种整段删除线效果。其中，删除线效果有 horizontalstrike、verticalstrike、updiagonalstrike 和 downdiagonalstrike，可叠加使用。 例：：12345678910$$\\require{enclose}\\begin{array}{rl}\\verb|\\enclose{horizontalstrike}{x+y}| &amp; \\enclose{horizontalstrike}{x+y}\\\\\\verb|\\enclose{verticalstrike}{\\frac xy}| &amp; \\enclose{verticalstrike}{\\frac xy}\\\\\\verb|\\enclose{updiagonalstrike}{x+y}| &amp; \\enclose{updiagonalstrike}{x+y}\\\\\\verb|\\enclose{downdiagonalstrike}{x+y}| &amp; \\enclose{downdiagonalstrike}{x+y}\\\\\\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\\\end{array}$$ $$\\require{enclose}\\begin{array}{rl}\\verb|\\enclose{horizontalstrike}{x+y}| &amp; \\enclose{horizontalstrike}{x+y}\\\\\\verb|\\enclose{verticalstrike}{\\frac xy}| &amp; \\enclose{verticalstrike}{\\frac xy}\\\\\\verb|\\enclose{updiagonalstrike}{x+y}| &amp; \\enclose{updiagonalstrike}{x+y}\\\\\\verb|\\enclose{downdiagonalstrike}{x+y}| &amp; \\enclose{downdiagonalstrike}{x+y}\\\\\\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\\\end{array}$$此外， \\enclose 命令还可以产生包围的边框和圆等，参见 MathML Menclose Documentation 以查看更多效果。 二、矩阵使用参考无框矩阵在开头使用 begin{matrix}，在结尾使用 end{matrix}，在中间插入矩阵元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。使用矩阵时必须声明 $ 或 $$ 符号。 例：：1234567$$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix} $$ $$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix}$$ 边框矩阵在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 例：：123456$ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $$ \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{pmatrix} $$ \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{bmatrix} $$ \\begin{Bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Bmatrix} $$ \\begin{vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{vmatrix} $$ \\begin{Vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Vmatrix} $ matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix $ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $ $ \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{pmatrix} $ $ \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{bmatrix} $ $ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $ $ \\begin{vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{vmatrix} $ $ \\begin{Vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Vmatrix} $ 带省略符号的矩阵使用 \\cdots , \\ddots , \\vdots 来输入省略符号。 例：：12345678$$\\begin{pmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\\\end{pmatrix}$$ $$\\begin{pmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\\\end{pmatrix}$$ 带分割符号的矩阵详见”数组使用参考“。 例：：12345678$$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array}\\right]$$ $$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array}\\right]$$ 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 行中矩阵若想在一行内显示矩阵，使用\\bigl(\\begin{smallmatrix} ... \\end{smallmatrix}\\bigr)。 例：：1这是一个行中矩阵的示例 $\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)$ 。 这是一个行中矩阵的示例 $\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)$ 。 三、方程式序列使用参考方程式序列人们经常想要一列整齐且居中的方程式序列。使用 \\begin{align}…\\end{align} 来创造一列方程式，其中在每行结尾处使用 \\\\ 。使用方程式序列无需声明公式符号 $ 或 $$ 。 请注意 {align} 语句是 自动编号 的。 例：：123456789$$\\begin{align}\\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\&amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}$$ $$\\begin{align}\\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\&amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\&amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\&amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\&amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}$$ 本例中每行公式的编号续自 如何插入公式 中的自动编号公式 。 在一个方程式序列的每一行中注明原因在 {align} 中灵活组合 \\text 和 \\tag 语句。\\tag 语句编号优先级高于自动编号。 例：：1234567$$\\begin{align} v + w &amp; = 0 &amp;\\text{Given} \\tag 1\\\\ -w &amp; = -w + 0 &amp; \\text{additive identity} \\tag 2\\\\ -w + 0 &amp; = -w + (v + w) &amp; \\text{equations $(1)$ and $(2)$} \\end{align}$$ $$\\begin{align}v + w &amp; = 0 &amp;\\text{Given} \\tag 1\\\\-w &amp; = -w + 0 &amp; \\text{additive identity} \\tag 2\\\\-w + 0 &amp; = -w + (v + w) &amp; \\text{equations $(1)$ and $(2)$}\\end{align}$$ 本例中第一、第二行的自动编号被 \\tag 语句覆盖，第三行的编号为自动编号。 四、条件表达式使用参考条件表达式使用 begin{cases} 来创造一组条件表达式，在每一行条件中插入 &amp; 来指定需要对齐的内容，并在每一行结尾处使用 \\\\，以 end{cases} 结束。条件表达式无需声明 $ 或 $$ 符号。 例：：1234567$$f(n) = \\begin{cases}n/2, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd} \\end{cases}$$ $$f(n) =\\begin{cases}n/2, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 左侧对齐的条件表达式若想让文字在 左侧对齐显示 ，则有如下方式： 例：：123456789$$\\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n/2\\\\\\text{if $n$ is odd:}&amp;3n+1\\end{array} \\right\\} =f(n)$$ $$\\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n/2\\\\\\text{if $n$ is odd:}&amp;3n+1\\end{array}\\right\\}=f(n)$$ 使条件表达式适配行高在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用 \\\\[2ex] 语句代替该行末尾的 \\\\ 来让编辑器适配。 例：： 不适配[2ex]1234567$$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 适配[2ex]1234567$$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex]3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 不适配[2ex] $$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 适配[2ex] $$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex]3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 一个 [ex] 指一个 “X-Height”，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。其实可以在任何地方使用 \\\\[2ex] 语句，只要你觉得合适。 五、数组与表格使用参考数组或表格通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \\\\ 结尾，最后以 end{array} 结束数组。使用单个数组或表格时无需声明 $ 或 $$ 符号。 例：：123456789$$\\begin{array}{c|lcr}n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i\\end{array}$$ $$\\begin{array}{c|lcr}n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i\\end{array}$$ 嵌套的数组或表格多个数组/表格可 互相嵌套 并组成一组数组/一组表格。使用嵌套前必须声明 $$ 符号。 例：：123456789101112131415161718192021222324252627282930313233343536373839$$% outer vertical array of arrays 外层垂直表格\\begin{array}{c} % inner horizontal array of arrays 内层水平表格 \\begin{array}{cc} % inner array of minimum values 内层&quot;最小值&quot;数组 \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; % inner array of maximum values 内层&quot;最大值&quot;数组 \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} % 内层第一行表格组结束 \\\\ % inner array of delta values 内层第二行Delta值数组 \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array} % 内层第二行表格组结束\\end{array}$$ $$\\begin{array}{c} \\begin{array}{cc} \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} \\\\ \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array}\\end{array}$$ 方程组使用 \\begin{array}…\\end{array} 和 \\left\\{…\\right. 来创建一个方程组。 例：：123456789$$\\left\\{ \\begin{array}{c}a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end{array}\\right. $$ $$\\left\\{\\begin{array}{c}a_1x+b_1y+c_1z=d_1 \\\\a_2x+b_2y+c_2z=d_2 \\\\a_3x+b_3y+c_3z=d_3\\end{array}\\right.$$ 或者使用条件表达式组 \\begin{cases}…\\end{cases} 来实现相同效果： 例：：1234567$$\\begin{cases}a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end{cases}$$ $$\\begin{cases}a_1x+b_1y+c_1z=d_1 \\\\a_2x+b_2y+c_2z=d_2 \\\\a_3x+b_3y+c_3z=d_3\\end{cases}$$ 六、连分数使用参考连分式就像输入分式时使用 \\frac 一样，使用 \\cfrac 来创建一个连分数。 例：： 12345$$x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}}$$ $$x = a_0 + \\cfrac{1^2}{a_1+ \\cfrac{2^2}{a_2+ \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}}$$ 不要使用普通的 \\frac 或 \\over 来创建，否则会看起来 很恶心 。 反例：： 12345$$x = a_0 + \\frac{1^2}{a_1+ \\frac{2^2}{a_2+ \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}}$$ $$x = a_0 + \\frac{1^2}{a_1+ \\frac{2^2}{a_2+ \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}}$$ 当然，你可以使用 \\frac 来表达连分数的 紧缩记法 。 例：： 12345$$x = a_0 + \\frac{1^2}{a_1+} \\frac{2^2}{a_2+} \\frac{3^2}{a_3 +} \\frac{4^4}{a_4 +} \\cdots$$ $$x = a_0 + \\frac{1^2}{a_1+}\\frac{2^2}{a_2+}\\frac{3^2}{a_3 +} \\frac{4^4}{a_4 +} \\cdots$$ 连分数通常都太大以至于不易排版，所以建议在连分数前后声明 $$ 符号，或使用像 [a0;a1,a2,a3,…] 一样的紧缩记法。 七、交换图表使用参考交换图表使用一行 $ \\require{AMScd} $ 语句来允许交换图表的显示。声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。 例：： 123456$\\require{AMScd}$\\begin{CD} A @&gt;&gt;&gt; B\\\\ @VVV @VVV\\\\ C @&gt;&gt;&gt; D\\end{CD} $$$\\require{AMScd}$\\begin{CD}A @&gt;&gt;&gt; B\\\\@VVV @VVV\\\\C @&gt;&gt;&gt; D\\end{CD}$$ 其中，@&gt;&gt;&gt; 代表右箭头、@&lt;&lt;&lt; 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。在 @&gt;&gt;&gt; 的 &gt;&gt;&gt; 之间任意插入文字即代表该箭头的注释文字。 例：： 1234567$$\\begin{CD} A @&gt;&gt;&gt; B @&gt;{\\text{very long label}}&gt;&gt; C \\\\ @. @AAA @| \\\\ D @= E @&lt;&lt;&lt; F\\end{CD}$$ $$\\begin{CD}A @&gt;&gt;&gt; B @&gt;{\\text{very long label}}&gt;&gt; C \\\\@. @AAA @| \\\\D @= E @&lt;&lt;&lt; F\\end{CD}$$ 在本例中， “very long label”自动延长了它所在箭头以及对应箭头的长度。 八、一些特殊的注意事项 These are issues that won’t affect the correctness of formulas, but might make them look significantly better or worse. Beginners should feel free to ignore this advice; someone else will correct it for them, or more likely nobody will care. 现在指出的小问题并不会影响方程式及公式等的正确显示，但能让它们看起来明显更好看。初学者可无视这些建议，自然会有强迫症患者替你们改掉它的，或者更可能地，根本没人发现这些问题。 Don’t use \\frac in exponents or limits of integrals; it looks bad and can be confusing, which is why it is rarely done in professional mathematical typesetting. Write the fraction horizontally, with a slash. 在以e为底的指数函数、极限和积分中尽量不要使用 \\frac 符号：它会使整段函数看起来很怪，而且可能产生歧义。也正是因此它在专业数学排版中几乎从不出现。横着写这些分式，中间使用斜线间隔 / （用斜线代替分数线）。 例：： 12345678$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\\\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\\\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\\\end{array}$$ The | symbol has the wrong spacing when it is used as a divider, for example in set comprehensions. Use \\mid instead. | 符号在被当作分隔符时会产生错误的间隔，因此在需要分隔时最好使用 \\mid 来代替它。 例：： 1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\{x|x^2\\in\\Bbb Z\\} &amp; \\{x\\mid x^2\\in\\Bbb Z\\} \\\\\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\{x|x^2\\in\\Bbb Z\\} &amp; \\{x\\mid x^2\\in\\Bbb Z\\} \\\\\\end{array}$$ For double and triple integrals, don’t use \\int\\int or \\int\\int\\int. Instead use the special forms \\iint and \\iiint. 使用多重积分符号时，不要多次使用 \\int 来声明，直接使用 \\iint 来表示 二重积分 ，使用 \\iiint 来表示 三重积分等。对于无限次积分，可以用 \\int \\cdots \\int 表示。 例：： 12345678$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int\\int_S f(x)\\,dy\\,dx &amp; \\iint_S f(x)\\,dy\\,dx \\\\\\int\\int\\int_V f(x)\\,dz\\,dy\\,dx &amp; \\iiint_V f(x)\\,dz\\,dy\\,dx\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int\\int_S f(x)\\,dy\\,dx &amp; \\iint_S f(x)\\,dy\\,dx \\\\\\int\\int\\int_V f(x)\\,dz\\,dy\\,dx &amp; \\iiint_V f(x)\\,dz\\,dy\\,dx\\end{array}$$ 无限次积分： Use \\,, to insert a thin space before differentials; without this will mash them together. 在微分符号前加入 \\, 来插入一个小的间隔空隙；没有 \\, 符号的话， 将会把不同的微分符号堆在一起。 例：： 1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x &amp; \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x &amp; \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x\\end{array}$$ ReferenceCmd Markdown 简明语法手册","link":"/2018/02/26/Write-Markdown-with-Formulas/"}],"tags":[{"name":"BoP2016","slug":"BoP2016","link":"/tags/BoP2016/"},{"name":"Configuration","slug":"Configuration","link":"/tags/Configuration/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"WPF","slug":"WPF","link":"/tags/WPF/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Python","slug":"Python","link":"/tags/Python/"}],"categories":[{"name":"Creative","slug":"Creative","link":"/categories/Creative/"},{"name":"Basic","slug":"Basic","link":"/categories/Basic/"},{"name":"DanmakuPie","slug":"DanmakuPie","link":"/categories/DanmakuPie/"}]}