{"pages":[{"title":"算法题","text":"Record of my solutions and thoughts to algorithm problems. LeetCode Problems Solutions 771 Jewels and Stones 771. Jewels and Stones 929 Unique Email Address 929. Unique Email Addresses 709 To Lower Case 709. To Lower Case 100 Same Tree 100. Same Tree 961 961. N-Repeated Element in Size 2N Array 961. N-Repeated Element in Size 2N Array 37 37. Sudoku Solver 37. Sudoku Solver POJCodes at Analysis of Algorithms","link":"/algorithms/index.html"},{"title":"About Me","text":"ZhilongMaster of Engineering. TimeLine2018.08 参加DeeCamp夏令营 2017.06 在微软实习 - 2017.08 2016.12 参加 Hackathon Beijing 2016 2016.10 参加微软 Dev Asia 2016 黑客马拉松 - 三等奖 2016.08 参加微软学生夏令营 2016.05 “功夫道场”作为推荐项目参加校大学生创新实践实践展 2015.11 参加微软校园 Hackathon Now在写 DanmakuPie, 主写 Python, JavaScript 和 C#。 在追 Westworld, This is us, Modern Family, We Bare Bears。 在玩 Nintendo Switch。 偶尔会玩 Ingress, 属于 Resistance。 在看 一些奇奇怪怪的书，还有一堆技术书正在落灰。 热爱 《三体》和 The Song of Ice and Fire。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"37 Sudoku Solver","text":"Hard Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character '.'. A sudoku puzzle… …and its solution numbers marked in red. Note: The given board contain only digits 1-9 and the character '.'. You may assume that the given Sudoku puzzle will have a single unique solution. The given board size is always 9x9. 想法这道题想了好久，最后看了网上的答案（sigh），总结了一下，基本就是HashMap+DFS，首先用三个数组存储数独中每一行、每一列、每一个方块中数字的占用情况，然后用回溯法DFS遍历一遍即可。写的过程中遇到好多笔误，调了很多遍才能跑通（sigh）。 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;bool row[9][9];bool column[9][9];bool box[9][9];bool done;void dfs(vector&lt;vector&lt;char&gt; &gt; &amp;board, int i, int j){ if (i &gt; 8) { done = true; return; } if (board[i][j] == '.') { for (int n = 0; n &lt; 9; n++) { if (!(row[i][n] || column[j][n] || box[(i / 3) * 3 + j / 3][n])) { board[i][j] = n + '1'; row[i][n] = column[j][n] = box[(i / 3) * 3 + j / 3][n] = true; if (j &gt;= 8) { dfs(board, i + 1, 0); } else { dfs(board, i, j + 1); } if (done) break; board[i][j] = '.'; row[i][n] = column[j][n] = box[(i / 3) * 3 + j / 3][n] = false; } } } else { if (j &gt;= 8) { dfs(board, i + 1, 0); } else { dfs(board, i, j + 1); } }}void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board){ memset(row, 0, 9 * 9 * sizeof(bool)); memset(column, 0, 9 * 9 * sizeof(bool)); memset(box, 0, 9 * 9 * sizeof(bool)); done = false; int num = 0; //Initialize for (int i = 0; i &lt; 9; i++) { for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { num = board[i][j] - '1'; row[i][num] = true; column[j][num] = true; box[(i / 3) * 3 + j / 3][num] = true; } } } dfs(board, 0, 0);}","link":"/algorithms/leetcode/37-sudoku-solver.html"},{"title":"100 Same Tree","text":"Easy Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: 1234567Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3]Output: true Example 2: 1234567Input: 1 1 / \\ 2 2 [1,2], [1,null,2]Output: false Example 3: 1234567Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2]Output: false 想法难度不高，二叉树遍历。不过刚开始写的时候有点糊涂，弄错了很多边际条件，还写复杂了一点（判断子节点是否为空），后来改正。不过还有提升空间。 解1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool foundResult; bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL) { if (q == NULL) { return true; } else { return false; } } else if (q == NULL) { return false; } else if (p-&gt;val != q-&gt;val){ return false; } else { return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); } }};","link":"/algorithms/leetcode/100-Same-Tree.html"},{"title":"771 Jewels and Stones","text":"Easy You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;. Example 1: 12Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3 Example 2: 12Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 想法第一感觉是两重循环，遍历S的每一个字符，寻找J里面有没有相同的字符，复杂度是$O(n^2)$。后来想了一下，不需要这么高的复杂度，只需要用一个bool数组把字符是否出现存下来就行。复杂度降至$O(n)$。 解123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int numJewelsInStones(string J, string S){ if (J.length() == 0 || S.length() == 0) { return 0; } int ptr[52]; int temp = 0; int res = 0; memset(ptr, 0, sizeof(int) * 52); for (char &amp;c : J) { temp = int(c); if (temp &gt; 96) { ptr[temp - 71] = 1; } else { ptr[temp - 65] = 1; } } for (char &amp;c : S) { temp = int(c); if (temp &gt; 96) { if (ptr[temp - 71] == 1) { res += 1; } } else if(ptr[temp - 65] == 1) { res += 1; } } return res;}int main(void){ cout &lt;&lt; numJewelsInStones(\"aA\", \"aAAbbbb\") &lt;&lt; endl; cout &lt;&lt; endl;}","link":"/algorithms/leetcode/771-Jewels-and-Stones.html"},{"title":"929 Unique Email Addresses","text":"Easy Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain '.'s or '+'s. If you add periods ('.') between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus ('+') in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: 123Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]Output: 2Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one '@' character. 想法一开始看题目这么长有点懵，后面整理一下思路就是遍历一遍按照状态机得到结果即可。主要是注意C++中vector的遍历以及string的遍历。 vector的遍历： 1for (vector&lt;string&gt;::iterator it = v.begin(); it != v.end(); it++) {} string的遍历： 1for(char &amp;c : *ch) {} 解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution {public: int numUniqueEmails(vector&lt;string&gt;&amp; emails) { vector&lt;string&gt; res; for (vector&lt;string&gt;::iterator it = emails.begin(); it != emails.end(); it++) { string s = \"\"; bool localname = true; bool afterplus = false; for (char &amp;c : *it) { switch (c) { case '@': localname = false; s += c; break; case '.': if (!localname) { s += c; } break; case '+': if (localname) { afterplus = true; } else { s += c; } break; default: if (!localname || !afterplus) { s += c; } } } bool equal = false; for (vector&lt;string&gt;::iterator it2 = res.begin(); it2 != res.end(); it2++) { if(s == *it2) { equal = true; break; } } if (!equal) { res.push_back(s); } } return res.size(); }};","link":"/algorithms/leetcode/929-Unique-Email-Addresses.html"},{"title":"709 To Lower Case","text":"Easy Example 1: 12Input: &quot;Hello&quot;Output: &quot;hello&quot; Example 2: 12Input: &quot;here&quot;Output: &quot;here&quot; Example 3: 12Input: &quot;LOVELY&quot;Output: &quot;lovely&quot; 想法两种方式，一种是遍历字符按照ASCII大写变小写即可。另一种是利用C++的内置函数tolower()。不过由于int std::tolower ( int c );的输入是字符，因此需要用std::transform()来进行处理。 12OutputIterator transform (InputIterator first1, InputIterator last1, OutputIterator result, UnaryOperation op) std::transform 简单的程序诠释C++ STL算法系列之十八：transform tolower How to convert std::string to lower case? Why can’t “transform(s.begin(),s.end(),s.begin(),tolower)” be complied successfully? 解1234567class Solution {public: string toLowerCase(string str) { transform(str.begin(), str.end(), str.begin(), ::tolower); return str; }};","link":"/algorithms/leetcode/709-To-Lower-Case.html"},{"title":"961 N-Repeated Element in Size 2N Array","text":"Easy In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: 12Input: [1,2,3,3]Output: 3 Example 2: 12Input: [2,1,2,5,3,2]Output: 2 Example 3: 12Input: [5,1,5,2,5,3,5,4]Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 想法每次都把一个不难的题弄得很难，sigh 实际上就是用set查重，值得注意的是C++里set是用红黑树实现的。 最后就是Range-based for loop，C++11的新特性： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt; int main() { std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5}; for (const int&amp; i : v) // access by const reference std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (auto i : v) // access by value, the type of i is int std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (auto&amp;&amp; i : v) // access by forwarding reference, the type of i is int&amp; std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; const auto&amp; cv = v; for (auto&amp;&amp; i : cv) // access by f-d reference, the type of i is const int&amp; std::cout &lt;&lt; i &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (int n : {0, 1, 2, 3, 4, 5}) // the initializer may be a braced-init-list std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; int a[] = {0, 1, 2, 3, 4, 5}; for (int n : a) // the initializer may be an array std::cout &lt;&lt; n &lt;&lt; ' '; std::cout &lt;&lt; '\\n'; for (int n : a) std::cout &lt;&lt; 1 &lt;&lt; ' '; // the loop variable need not be used std::cout &lt;&lt; '\\n'; } 解123456789101112131415161718#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int repeatedNTimes(vector&lt;int&gt; &amp;A){ set&lt;int&gt; m; for (vector&lt;int&gt;::iterator it = A.begin(); it != A.end(); it++) { if (m.find(*it) != m.end()) { return *it; } else { m.insert(*it); } }} 不过有个更好的做法，在LeetCode上看到的： 123456789101112class Solution {public: int repeatedNTimes(vector&lt;int&gt;&amp; A) { unordered_set&lt;int&gt; seen; for (int a: A) { if (seen.count(a)) return a; seen.insert(a); } return 0; }};","link":"/algorithms/leetcode/961-n-repeated-element-in-size-2-n-array.html"},{"title":"","text":"玛雅历描述上周末，M.A. Ya教授对古老的玛雅有了一个重大发现。从一个古老的节绳（玛雅人用于记事的工具）中，教授发现玛雅人使用了一个一年有365天的叫做Haab的历法。这个Haab历法拥有19个月，在开始的18个月，一个月有20天，月份的名字分别是pop, no, zip, zotz, tzec, xul, yoxkin, mol, chen, yax, zac, ceh, mac, kankin, muan, pax, koyab, cumhu。这些月份中的日期用0到19表示。Haab历的最后一个月叫做uayet，它只有5天，用0到4表示。玛雅人认为这个日期最少的月份是不吉利的，在这个月法庭不开庭，人们不从事交易，甚至没有人打扫屋中的地板。 因为宗教的原因，玛雅人还使用了另一个历法，在这个历法中年被称为Tzolkin(holly年)，一年被分成13个不同的时期，每个时期有20天，每一天用一个数字和一个单词相组合的形式来表示。使用的数字是1~13，使用的单词共有20个，它们分别是：imix, ik, akbal, kan, chicchan, cimi, manik, lamat, muluk, ok, chuen, eb, ben, ix, mem, cib, caban, eznab, canac, ahau。注意：年中的每一天都有着明确唯一的描述，比如，在一年的开始，日期如下描述： 1 imix, 2 ik, 3 akbal, 4 kan, 5 chicchan, 6 cimi, 7 manik, 8 lamat, 9 muluk, 10 ok, 11 chuen, 12 eb, 13 ben, 1 ix, 2 mem, 3 cib, 4 caban, 5 eznab, 6 canac, 7 ahau, ，8 imix, 9 ik, 10 akbal ……也就是说数字和单词各自独立循环使用。Haab历和Tzolkin历中的年都用数字0，1，……表示，数字0表示世界的开始。所以第一天被表示成：Haab: 0. pop 0Tzolkin: 1 imix 0请帮助M.A. Ya教授写一个程序可以把Haab历转化成Tzolkin历。 输入Haab历中的数据由如下的方式表示：日期. 月份 年数输入中的第一行表示要转化的Haab历日期的数据量。下面的每一行表示一个日期，年数小于5000。 输出Tzolkin历中的数据由如下的方式表示：天数字 天名称 年数第一行表示输出的日期数量。下面的每一行表示一个输入数据中对应的Tzolkin历中的日期。 样例输入1234310. zac 00. pop 010. zac 1995 样例输出123433 chuen 01 imix 09 cimi 2801 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int convertMonthToInt(char str[], char habb[][10]){ int res = -1; for (int i = 0; i &lt; 19; i++){ if (strcmp(str, habb[i]) == 0) { res = i; } } return res;}int main(void){ char habb[19][10] = {\"pop\", \"no\", \"zip\", \"zotz\", \"tzec\", \"xul\", \"yoxkin\", \"mol\", \"chen\", \"yax\", \"zac\", \"ceh\", \"mac\", \"kankin\", \"muan\", \"pax\", \"koyab\", \"cumhu\", \"uayet\"}; char tzolkin[20][10] = {\"imix\", \"ik\", \"akbal\", \"kan\", \"chicchan\", \"cimi\", \"manik\", \"lamat\", \"muluk\", \"ok\", \"chuen\", \"eb\", \"ben\", \"ix\", \"mem\", \"cib\", \"caban\", \"eznab\", \"canac\", \"ahau\"}; int count; cin &gt;&gt; count; cout &lt;&lt; count &lt;&lt; endl; char dayStr[10]; int day; char monthStr[10]; int month; int year; for (int i = 0; i &lt; count; i++){ cin &gt;&gt; dayStr &gt;&gt; monthStr &gt;&gt; year; dayStr[strlen(dayStr) - 1] = 0; day = atoi(dayStr); month = convertMonthToInt(monthStr, habb); int totalDay = year * 365 + month * 20 + day; int newYear = totalDay / 260; int dayOfYear = totalDay % 260; int newMonth = dayOfYear % 13 + 1; int newDay = dayOfYear % 20; cout &lt;&lt; newMonth &lt;&lt; ' ' &lt;&lt; tzolkin[newDay] &lt;&lt; ' ' &lt;&lt; newYear &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/1-A 玛雅历.html"},{"title":"","text":"棋盘问题描述在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 输入输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 输出对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 样例输入1234567892 1#..#4 4...#..#..#..#...-1 -1 样例输出1221 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;long cal(char map[][9], int col[], int row[], int n, int k, int i){ if (k == 0){ return 1; } long res = 0; for (int a = i; a &lt;= n - k; a ++){ for (int b = 0; b &lt; n; b ++){ if (map[a][b] == '#' &amp;&amp; col[a] != 1 &amp;&amp; row[b] != 1){ col[a] = 1; row[b] = 1; res += cal(map, col, row, n, k - 1, a + 1); col[a] = 0; row[b] = 0; } } } return res;}int main(void){ char map[9][9]; int n, k; cin &gt;&gt; n &gt;&gt; k; while(n != -1 &amp;&amp; k != -1){ for(int i = 0; i &lt; n; i++){ cin &gt;&gt; map[i]; } int col[8] = {0}; int row[8] = {0}; cout &lt;&lt; cal(map, col, row, n, k, 0) &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; k; } }","link":"/algorithms/POJ/course/1-B 棋盘问题.html"},{"title":"","text":"Til the Cows Come Home描述Bessie is out in the field and wants to get back to the barn to get as much sleep as possible before Farmer John wakes her for the morning milking. Bessie needs her beauty sleep, so she wants to get back as quickly as possible.Farmer John’s field has N (2 &lt;= N &lt;= 1000) landmarks in it, uniquely numbered 1..N. Landmark 1 is the barn; the apple tree grove in which Bessie stands all day is landmark N. Cows travel in the field using T (1 &lt;= T &lt;= 2000) bidirectional cow-trails of various lengths between the landmarks. Bessie is not confident of her navigation ability, so she always stays on a trail from its start to its end once she starts it.Given the trails between the landmarks, determine the minimum distance Bessie must walk to get back to the barn. It is guaranteed that some such route exists. 输入 Line 1: Two integers: T and N Lines 2..T+1: Each line describes a trail as three space-separated integers. The first two integers are the landmarks between which the trail travels. The third integer is the length of the trail, range 1..100. 输出 Line 1: A single integer, the minimum distance that Bessie must travel to get from landmark N to landmark 1. 样例输入1234565 51 2 202 3 303 4 204 5 201 5 100 样例输出190 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int map[1000][1000];int d[1000];bool final[1000];int main (void){ memset(map, 0b01111111, 1000 * 1000 * sizeof(int)); int MAX = map[0][0]; int t, n; cin &gt;&gt; t &gt;&gt; n; int x, y, value; // Input for (int i = 0; i &lt; t; i++){ cin &gt;&gt; x &gt;&gt; y; cin &gt;&gt; value; // HERE: The road may be duplicate. if (value &lt; map[x - 1][y - 1]) { map[x - 1][y - 1] = value; map[y - 1][x - 1] = value; } } // Dijkstra Algorithm for (int i = 0; i &lt; n; i++){ final[i] = false; d[i] = map[0][i]; } d[0] = 0; final[0] = true; for(int i = 1; i &lt; n; i++){ int min = MAX; int v = 0; for (int w = 0; w &lt; n; w++){ if(!final[w]){ if(d[w] &lt; min){ v = w; min = d[w]; } } } final[v] = true; for(int w = 0; w &lt; n; w++){ if(!final[w] &amp;&amp; (min + map[v][w] &lt; d[w])){ d[w] = min + map[v][w]; } } } cout &lt;&lt; d[n - 1] &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/1-C Til the Cows Come Home.html"},{"title":"","text":"仙岛求药描述少年李逍遥的婶婶病了，王小虎介绍他去一趟仙灵岛，向仙女姐姐要仙丹救婶婶。叛逆但孝顺的李逍遥闯进了仙灵岛，克服了千险万难来到岛的中心，发现仙药摆在了迷阵的深处。迷阵由M×N个方格组成，有的方格内有可以瞬秒李逍遥的怪物，而有的方格内则是安全。现在李逍遥想尽快找到仙药，显然他应避开有怪物的方格，并经过最少的方格，而且那里会有神秘人物等待着他。现在要求你来帮助他实现这个目标。下图 显示了一个迷阵的样例及李逍遥找到仙药的路线 输入输入有多组测试数据. 每组测试数据以两个非零整数 M 和 N 开始，两者均不大于20。M 表示迷阵行数, N 表示迷阵列数。接下来有 M 行, 每行包含N个字符,不同字符分别代表不同含义:1) ‘@’：少年李逍遥所在的位置；2) ‘.’：可以安全通行的方格；3) ‘#’：有怪物的方格；4) ‘*’：仙药所在位置。当在一行中读入的是两个零时，表示输入结束。 输出对于每组测试数据，分别输出一行，该行包含李逍遥找到仙药需要穿过的最少的方格数目(计数包括初始位置的方块)。如果他不可能找到仙药, 则输出 -1。 样例输入1234567891011121314151617181920212223242526278 8.@##...##....#.##.#.##....#.###.#.#...#...###.#....#.*...#...###6 5.*.#..#.....##.......#.......@9 6.#..#. .#.*.# .####. ..#... ..#... ..#... ..#... #.@.## .#..#. 0 0 样例输出123108-1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;queue&gt; using namespace std;struct pos{ int x; int y; int layer;};int main (void){ int m, n; cin &gt;&gt; m &gt;&gt; n; char map[20][20]; while(m != 0 &amp;&amp; n != 0){ queue&lt;pos&gt; q; bool res = false; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; map[i]; for(int j = 0; j &lt; n; j++){ if (map[i][j] == '@'){ struct pos p = {i, j, 0}; q.push(p); } } } while(q.size() &gt; 0){ struct pos p = q.front(); q.pop(); if(p.x - 1 &gt;= 0){ if (map[p.x - 1][p.y] == '.'){ struct pos t = {p.x - 1, p.y, p.layer + 1}; q.push(t); } else if(map[p.x - 1][p.y] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.y + 1 &lt; n){ if (map[p.x][p.y + 1] == '.'){ struct pos t = {p.x, p.y + 1, p.layer + 1}; q.push(t); } else if(map[p.x][p.y + 1] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.y - 1 &gt;= 0){ if (map[p.x][p.y - 1] == '.'){ struct pos t = {p.x, p.y - 1, p.layer + 1}; q.push(t); } else if(map[p.x][p.y - 1] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } if(p.x + 1 &lt; m){ if (map[p.x + 1][p.y] == '.'){ struct pos t = {p.x + 1, p.y, p.layer + 1}; q.push(t); } else if(map[p.x + 1][p.y] == '*'){ cout &lt;&lt; p.layer + 1 &lt;&lt; endl; res = true; break; } } map[p.x][p.y] = '!'; } if(!res) { cout &lt;&lt; -1 &lt;&lt; endl; } cin &gt;&gt; m &gt;&gt; n; } return 0;}","link":"/algorithms/POJ/course/1-D 仙岛求药.html"},{"title":"","text":"1-E 二叉树的操作描述给定一棵二叉树，在二叉树上执行两个操作： 节点交换把二叉树的两个节点交换。 前驱询问询问二叉树的一个节点对应的子树最左边的节点。 输入第一行输出一个整数t(t &lt;= 100)，代表测试数据的组数。对于每组测试数据，第一行输入两个整数n m，n代表二叉树节点的个数，m代表操作的次数。随后输入n行，每行包含3个整数X Y Z，对应二叉树一个节点的信息。X表示节点的标识，Y表示其左孩子的标识，Z表示其右孩子的标识。再输入m行，每行对应一次操作。每次操作首先输入一个整数type。当type=1，节点交换操作，后面跟着输入两个整数x y，表示将标识为x的节点与标识为y的节点交换。输入保证对应的节点不是祖先关系。当type=2，前驱询问操作，后面跟着输入一个整数x，表示询问标识为x的节点对应子树最左的孩子。1&lt;=n&lt;=100，节点的标识从0到n-1，根节点始终是0.m&lt;=100 输出对于每次询问操作，输出相应的结果。 样例输入12345678910111213141516171825 50 1 21 -1 -12 3 43 -1 -14 -1 -12 01 1 22 01 3 42 23 20 1 21 -1 -12 -1 -11 1 22 0 样例输出12341342 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;using namespace std;struct node { int parent; int left; int right;};void swap(int a, int b, struct node tree[]){ // Parent if(tree[a].parent == tree[b].parent){ if(tree[tree[a].parent].left == a){ tree[tree[a].parent].left = b; tree[tree[a].parent].right = a; } else{ tree[tree[a].parent].right = b; tree[tree[a].parent].left = a; } } else{ if(tree[tree[a].parent].left == a){ tree[tree[a].parent].left = b; } else{ tree[tree[a].parent].right = b; } int temp = tree[a].parent; tree[a].parent = tree[b].parent; if(tree[tree[b].parent].left == b){ tree[tree[b].parent].left = a; } else { tree[tree[b].parent].right = a; } tree[b].parent = temp; }}int check(int p, struct node tree[]){ while(tree[p].left != -1){ p = tree[p].left; } return p;}void output(struct node tree[], int n){ for(int i = 0; i &lt; n; i++){ cout &lt;&lt; \"Tree: \" &lt;&lt; i &lt;&lt; \" Left: \" &lt;&lt; tree[i].left &lt;&lt; \" Right: \" &lt;&lt; tree[i].right &lt;&lt; \" Parent: \" &lt;&lt; tree[i].parent &lt;&lt; endl; }}int main (void){ struct node tree[100]; int group; cin &gt;&gt; group; for(int g = 0; g &lt; group; g++){ int n, m; cin &gt;&gt; n &gt;&gt; m; tree[0].parent = -1; int tag, left, right; for(int i = 0; i &lt; n; i++){ cin &gt;&gt; tag &gt;&gt; left &gt;&gt; right; tree[tag].left = left; tree[tag].right = right; tree[left].parent = tag; tree[right].parent = tag; } int type; for(int i = 0; i &lt; m; i++){ cin &gt;&gt; type; if(type == 1){ int a, b; cin &gt;&gt; a &gt;&gt; b; swap(a, b, tree); } else if(type == 2){ int p; cin &gt;&gt; p; cout &lt;&lt; check(p, tree) &lt;&lt; endl; } } } return 0;}","link":"/algorithms/POJ/course/1-E 二叉树的操作.html"},{"title":"","text":"1-F 2的幂次方表示描述任何一个正整数都可以用2的幂次方表示。例如： 137=2^7+2^3+2^0 同时约定方次用括号来表示，即ab可表示为a(b)。由此可知，137可表示为： 2(7)+2(3)+2(0) 进一步：7=2^2+2+2^0（2^1用2表示） 3=2+2^0 所以最后137可表示为： 2(2(2)+2+2(0))+2(2+2(0))+2(0) 又如： 1315=2^10+2^8+2^5+2+1 所以1315最后可表示为： 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0) 输入一个正整数n（n≤20000）。 输出一行，符合约定的n的0，2表示（在表示中不能有空格）。 样例输入1137 样例输出12(2(2)+2+2(0))+2(2+2(0))+2(0) 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int max(int num){ int i; for (i = 15; i &gt;= 0; i --) { if (int(pow(2, i) + 0.5) &lt;= num) { return i; } } return 0;}int main(void){ char map[16][30] = {\"(0)\", \"\", \"(2)\", \"(2+2(0))\", \"(2(2))\", \"(2(2)+2(0))\", \"(2(2)+2)\", \"(2(2)+2+2(0))\", \"(2(2+2(0)))\", \"(2(2+2(0))+2(0))\", \"(2(2+2(0))+2)\", \"(2(2+2(0))+2+2(0))\", \"(2(2+2(0))+2(2))\", \"(2(2+2(0))+2(2)+2(0))\", \"(2(2+2(0))+2(2)+2)\",\"(2(2+2(0))+2(2)+2(2)+2+2(0)))\"}; int num; cin &gt;&gt; num; int n = max(num); for(int i = n; i &gt;= 0; i--){ int diff = num - (int)(pow(2, i) + 0.5); if(diff &gt; 0){ cout &lt;&lt; \"2\" &lt;&lt; map[i] &lt;&lt; \"+\"; num = diff; } else if(diff == 0){ cout &lt;&lt; \"2\" &lt;&lt; map[i] &lt;&lt; endl; break; } } return 0;}","link":"/algorithms/POJ/course/1-F 2的幂次方表示.html"},{"title":"","text":"Butterfly描述有一群旅行爱好者，有一天，他们带回了n只蝴蝶回来。他们相信每一只都属于两个不同种类中的一种，为了讨论方便，我们称它们为A与B。他们想把n只标本分成两组——一些属于A且一些属于B——但是直接标记任何一个标本对于他们是非常困难，因此他们决定采用下面的方法。 对每对标本i和j，他们细心地把它们放到一起研究。如果他们以自己的判断足以确信，那么他们把这对蝴蝶标记为“相同”（这意味着他们相信这两只来自同一类）或者是“不同”（这意味着他们相信这两只来自不同的类）。他们也可以对某些标本判断不出来而弃权，在这种情况下，我们称这对标本是不明确的。 现在他们有n只标本的集合，还有对那些没有弃权的标本对的m个判断的集合（“相同”或者“不同”）。他们想知道这个数据与每只蝴蝶来自A和B中的一个类的想法是否一致。更具体地说，如果对每对蝴蝶按照下述方式标记A或B是可能的，即对每个标为“相同”的（i，j）对，就是i与j有相同标记的情况；对每个标为“不同”的（i，j）对，就是i与j有不同标记的情况。那么我们可以说这m个判断是一致的。他们正在冥思苦想自己的判断是否是一致的。请你帮他们设计合理的算法解决该问题。 输入输入包含多组数据，以文件结束符为终止。 每组数据第一行为两个整数，分别是n和m：n为蝴蝶的数量，编号从0到n-1m为关系的数量 接下来是m组关系数据，每组数据占一行，为三个整数，前两个整数表示蝴蝶的编号，第三个整数为关系的种类（相同或者不同）：0为相同，1为不同 1 &lt; n &lt;= 10001 &lt; m &lt;= 100000 输出合理就输出YES不合理就输出NO 样例输入123456783 30 1 01 2 10 2 13 30 1 01 2 10 2 0 样例输出12YESNO 提示注意输出的大写和回车 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct table{ int neighbor; int same; struct table *next;};struct head{ int type; bool visited; struct table *head; struct table *end;};struct connection{ int a; int b; int s;};struct connection conn[100000];struct head h[1000];int main(void){ int m, n; int i = 0; int a = 0; queue&lt;int&gt; q; while (scanf(\"%d %d\", &amp;m, &amp;n) != EOF) { bool res = true; for (i = 0; i &lt; m; i++) { h[i].visited = false; h[i].head = new struct table; h[i].head-&gt;next = NULL; h[i].type = 0; h[i].end = h[i].head; } for (i = 0; i &lt; n; i++) { scanf(\"%d %d %d\", &amp;conn[i].a, &amp;conn[i].b, &amp;conn[i].s); a = conn[i].a; h[a].end-&gt;next = new struct table; h[a].end = h[conn[i].a].end-&gt;next; h[a].end-&gt;neighbor = conn[i].b; h[a].end-&gt;same = conn[i].s; h[a].end-&gt;next = NULL; } for (i = 0; i &lt; m; i++) { if (h[i].visited != true &amp;&amp; h[i].head-&gt;next != NULL) { q.push(i); h[i].visited = true; } while (!q.empty()) { int cur = q.front(); q.pop(); struct table *c = h[cur].head; while (c-&gt;next != NULL) { c = c-&gt;next; if (!h[c-&gt;neighbor].visited) { h[c-&gt;neighbor].visited = true; if (c-&gt;same == 0) { h[c-&gt;neighbor].type = h[cur].type; } else { h[c-&gt;neighbor].type = 1 - h[cur].type; } q.push(c-&gt;neighbor); } } } } for (int i = 0; i &lt; n; i++) { if(conn[i].s == 0){ if(h[conn[i].a].type != h[conn[i].b].type){ res = false; break; } } else{ if(h[conn[i].a].type == h[conn[i].b].type){ res = false; break; } } } if (res) { printf(\"YES\\n\"); } else { printf(\"NO\\n\"); } } return 0;}","link":"/algorithms/POJ/course/2-A Butterfly.html"},{"title":"","text":"Dynamic Median描述设计一个数据结构，初始为空，支持以下操作： （1）增加一个元素，要求在log(n)时间内完成，其中n是该数据结构中当前元素的个数。注意：数据结构中允许有重复的元素。 （2）返回当前元素集合的中位数，要求在常数时间内完成。如果当前元素的个数为偶数，那么返回下中位数（即两个中位数中较小的一个）。 （3）删除中位数，要求在log(n)时间内完成。 输入输入的第一行是一个自然数T，代表测试数据的组数((1 ≤ T ≤ 600))。每组测试数据的第一行是个自然数N，代表操作的次数，1&lt;=N&lt;=10000。后面的N行中的每行代表一个操作，每次操作首先输入一个单字符代表操作的类型： I表示插入，后面跟着输入一个正整数（这是唯一带有输入数值的操作）。Q表示查询，输出当前的中位数（这是唯一产生输出的操作）。D表示删除当前的中位数。 输入保证是正确的：查询时集合保证不为空（即中位数是存在的），删除时保证集合中有足够可供删除的元素。 输出每次查询操作Q时输出的中位数，每次输出单独占一行。 样例输入1234567891018I 4I 3I 5Q DI 10I 2Q 样例输出1243 提示123 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main(void){ int group; scanf(\"%d\", &amp;group); while (group &gt; 0) { priority_queue&lt;int&gt; smallq; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; bigq; int n; int count = 0; scanf(\"%d\", &amp;n); while (n &gt; 0) { char ins; scanf(\"%c\", &amp;ins); while (ins == '\\n' || ins == ' ') { scanf(\"%c\", &amp;ins); } if (ins == 'I') { int num; scanf(\"%d\", &amp;num); count++; // insert if (bigq.size() == 0 || num &gt; bigq.top()) { bigq.push(num); } else if (smallq.size() == 0 || num &lt; smallq.top()) { smallq.push(num); } else if (bigq.size() &gt; smallq.size()) { smallq.push(num); } else { bigq.push(num); } while (((int)bigq.size() - (int)smallq.size()) &gt; 1) { smallq.push(bigq.top()); bigq.pop(); } while (((int)smallq.size() - (int)bigq.size()) &gt; 1) { bigq.push(smallq.top()); smallq.pop(); } } else if (ins == 'Q') { // query if (bigq.size() &gt; smallq.size()) { printf(\"%d\\n\", bigq.top()); } else { printf(\"%d\\n\", smallq.top()); } } else if (ins == 'D') { // delete if (bigq.size() &gt; smallq.size()) { bigq.pop(); } else { smallq.pop(); } } n--; } group--; } return 0;}","link":"/algorithms/POJ/course/2-B Dynamic Median.html"},{"title":"","text":"Yogurt Factory描述The cows have purchased a yogurt factory that makes world-famous Yucky Yogurt. Over the next N (1 &lt;= N &lt;= 10,000) weeks, the price of milk and labor will fluctuate weekly such that it will cost the company C_i (1 &lt;= C_i &lt;= 5,000) cents to produce one unit of yogurt in week i. Yucky’s factory, being well-designed, can produce arbitrarily many units of yogurt each week. Yucky Yogurt owns a warehouse that can store unused yogurt at a constant fee of S (1 &lt;= S &lt;= 100) cents per unit of yogurt per week. Fortuitously, yogurt does not spoil. Yucky Yogurt’s warehouse is enormous, so it can hold arbitrarily many units of yogurt. Yucky wants to find a way to make weekly deliveries of Y_i (0 &lt;= Y_i &lt;= 10,000) units of yogurt to its clientele (Y_i is the delivery quantity in week i). Help Yucky minimize its costs over the entire N-week period. Yogurt produced in week i, as well as any yogurt already in storage, can be used to meet Yucky’s demand for that week. 输入 Line 1: Two space-separated integers, N and S. Lines 2..N+1: Line i+1 contains two space-separated integers: C_i and Y_i. 输出 Line 1: Line 1 contains a single integer: the minimum total cost to satisfy the yogurt schedule. Note that the total might be too large for a 32-bit integer. 样例输入123454 588 20089 40097 30091 500 样例输出1126900 提示OUTPUT DETAILS:In week 1, produce 200 units of yogurt and deliver all of it. In week 2, produce 700 units: deliver 400 units while storing 300 units. In week 3, deliver the 300 units that were stored. In week 4, produce and deliver 500 units. 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main(void){ int n, s; cin &gt;&gt; n &gt;&gt; s; int c, y; int min_price = 6000; long long sum = 0; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c &gt;&gt; y; if (c &lt; (min_price + s)) { min_price = c; sum += (long long)c * (long long)y; } else { min_price = min_price + s; sum += (long long)min_price * (long long)y; } } printf(\"%lld\\n\", sum); return 0;}","link":"/algorithms/POJ/course/2-C Yogurt Factory.html"},{"title":"","text":"The Unique MST描述Given a connected undirected graph, tell if its minimum spanning tree is unique. Definition 1 (Spanning Tree): Consider a connected, undirected graph G = (V, E). A spanning tree of G is a subgraph of G, say T = (V’, E’), with the following properties: V’ = V. T is connected and acyclic. Definition 2 (Minimum Spanning Tree): Consider an edge-weighted, connected, undirected graph G = (V, E). The minimum spanning tree T = (V, E’) of G is the spanning tree that has the smallest total cost. The total cost of T means the sum of the weights on all the edges in E’. 输入The first line contains a single integer t (1 &lt;= t &lt;= 20), the number of test cases. Each case represents a graph. It begins with a line containing two integers n and m (1 &lt;= n &lt;= 100), the number of nodes and edges. Each of the following m lines contains a triple (xi, yi, wi), indicating that xi and yi are connected by an edge with weight = wi. For any two nodes, there is at most one edge connecting them. 输出For each input, if the MST is unique, print the total cost of it, or otherwise print the string ‘Not Unique!’. 样例输入1234567891023 31 2 12 3 23 1 34 41 2 22 3 23 4 24 1 2 样例输出123Not Unique! 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct edge { int x; int y; int w; int sign; edge(int x, int y, int w) : x(x), y(y), w(w), sign(0) {} // Implement &lt; and &gt; for sort bool operator&lt;(const edge &amp;e) const { return (w &lt; e.w); } bool operator&gt;(const edge &amp;e) const { return (w &gt; e.w); }};int find_parent(int x, int parent[]){ if (x != parent[x]) { parent[x] = find_parent(parent[x], parent); } return parent[x];}int main(void){ int parent[100]; int t; cin &gt;&gt; t; while (t-- &gt; 0) { bool has_signed_point = false; int m, n; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } // Input - Kruskal vector&lt;edge&gt; edge_v; int x, y, w; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; edge_v.push_back(edge(x, y, w)); } sort(edge_v.begin(), edge_v.end()); // 如果 the edge has the same weight，标记为1 int last_w = -1; for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++){ if (last_w == it-&gt;w) { it--; it-&gt;sign = 1; // has the same weight it++; it-&gt;sign = 1; } last_w = it-&gt;w; } // 通过并查集来实现Kruskal // 如果用到的sign = 1的边，则改为sign = 2 int sum = 0; for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++) { if (find_parent(it-&gt;x, parent) != find_parent(it-&gt;y, parent)) { if (it-&gt;sign == 1) { has_signed_point = true; it-&gt;sign = 2; // should be deleted } sum += it-&gt;w; parent[it-&gt;y] = it-&gt;x; } } if (has_signed_point) { // 对于每一条sign = 2的边，尝试删掉这条边，然后重新跑一遍Kruskal，如果最小生成树的总长是一样的，说明不是Unique for (vector&lt;edge&gt;::iterator it = edge_v.begin(); it != edge_v.end(); it++) { if (it-&gt;sign == 2) { int sum_2 = 0; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } for (vector&lt;edge&gt;::iterator it_2 = edge_v.begin(); it_2 != edge_v.end(); it_2++) { if (it_2 != it) { if (find_parent(it_2-&gt;x, parent) != find_parent(it_2-&gt;y, parent)) { sum_2 += it_2-&gt;w; parent[it_2-&gt;y] = it_2-&gt;x; } } } if (sum == sum_2) { sum = -1; break; } } } } if (sum == -1) { cout &lt;&lt; \"Not Unique!\" &lt;&lt; endl; } else { cout &lt;&lt; sum &lt;&lt; endl; } } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct edge { int x; int y; int w; int sign; edge(int x, int y, int w, int s) : x(x), y(y), w(w), sign(s) {} bool operator&lt;(const edge &amp;e) const { return w &lt; e.w; } bool operator&gt;(const edge &amp;e) const { return w &gt; e.w; }};int n, m;int parent[110];int find_parent(int loc){ if (parent[loc] != loc) { parent[loc] = find_parent(parent[loc]); } return parent[loc];}int main(void){ int t; cin &gt;&gt; t; while (t-- &gt; 0) { cin &gt;&gt; n &gt;&gt; m; int x, y, w, s; vector&lt;edge&gt; v; edge *last_e = NULL; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; if (last_e != NULL &amp;&amp; last_e-&gt;w == w) { s = 1; last_e-&gt;sign = s; } else { s = 0; } v.push_back(edge(x, y, w, s)); last_e = &amp;v.back(); } sort(v.begin(), v.end()); for (int i = 1; i &lt;= n; i++) { parent[i] = i; } int sum = 0; for (vector&lt;edge&gt;::iterator it = v.begin(); it != v.end(); it++) { // cout &lt;&lt; \"X: \" &lt;&lt; it-&gt;x &lt;&lt; \" Y: \" &lt;&lt; it-&gt;y &lt;&lt; \" W: \" &lt;&lt; it-&gt;w &lt;&lt; \" S: \" &lt;&lt; it-&gt;sign &lt;&lt; endl; if (find_parent(it-&gt;x) != find_parent(it-&gt;y)) { sum += it-&gt;w; // HERE: Combine two sets parent[it-&gt;y] = it-&gt;x; if (it-&gt;sign == 1) { it-&gt;sign = 2; } } } bool res = true; for (vector&lt;edge&gt;::iterator it = v.begin(); it != v.end(); it++) { int sum_1 = 0; for (int i = 1; i &lt;= n; i++) { parent[i] = i; } if (it-&gt;sign == 2) { it-&gt;sign = 3; for (vector&lt;edge&gt;::iterator it_1 = v.begin(); it_1 != v.end(); it_1++) { if (it_1-&gt;sign != 3 &amp;&amp; find_parent(it_1-&gt;x) != find_parent(it_1-&gt;y)) { sum_1 += it_1-&gt;w; parent[it_1-&gt;y] = it_1-&gt;x; } } if (sum_1 == sum) { res = false; break; } it-&gt;sign = 2; } } if (res) { cout &lt;&lt; sum &lt;&lt; endl; } else { cout &lt;&lt; \"Not Unique!\" &lt;&lt; endl; } } return 0;}","link":"/algorithms/POJ/course/2-D The Unique MST.html"},{"title":"","text":"Subway描述You have just moved from a quiet Waterloo neighbourhood to a big, noisy city. Instead of getting to ride your bike to school every day, you now get to walk and take the subway. Because you don’t want to be late for class, you want to know how long it will take you to get to school.You walk at a speed of 10 km/h. The subway travels at 40 km/h. Assume that you are lucky, and whenever you arrive at a subway station, a train is there that you can board immediately. You may get on and off the subway any number of times, and you may switch between different subway lines if you wish. All subway lines go in both directions. 输入Input consists of the x,y coordinates of your home and your school, followed by specifications of several subway lines. Each subway line consists of the non-negative integer x,y coordinates of each stop on the line, in order. You may assume the subway runs in a straight line between adjacent stops, and the coordinates represent an integral number of metres. Each line has at least two stops. The end of each subway line is followed by the dummy coordinate pair -1,-1. In total there are at most 200 subway stops in the city. 输出Output is the number of minutes it will take you to get to school, rounded to the nearest minute, taking the fastest route. 样例输入1230 0 10000 10000 200 5000 200 7000 200 -1 -1 2000 600 5000 600 10000 600 -1 -1 样例输出121 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;double a[250];double b[250];double map[250][250];double d[250];bool final[250];int main(void){ scanf(\"%lf %lf %lf %lf\", &amp;a[0], &amp;b[0], &amp;a[1], &amp;b[1]); int c = 2; double x, y; bool start_of_new_line = true; double distance; // Read the input and calculate the distance of subway line while (scanf(\"%lf %lf\", &amp;x, &amp;y) != EOF) { if (x &gt; -1 &amp;&amp; y &gt; -1) { a[c] = x; b[c] = y; if (!start_of_new_line) { distance = sqrt(pow((x - a[c - 1]), 2) + pow((y - b[c - 1]), 2)); map[c][c - 1] = distance; map[c - 1][c] = distance; } start_of_new_line = false; c += 1; } else { start_of_new_line = true; } } // Calculate the distance of walking for (int i = 0; i &lt; c; i++) { map[i][i] = INT_MAX; for (int j = i + 1; j &lt; c; j++) { if (!(map[i][j] &gt; 0)) { distance = 4 * sqrt(pow((a[i] - a[j]), 2) + pow((b[i] - b[j]), 2)); map[i][j] = distance; map[j][i] = distance; } } } // Dijkstra - Preparation for (int i = 0; i &lt; c; i++) { final[i] = false; d[i] = map[0][i]; } // Dijkstra - Greedy Part d[0] = 0; final[0] = true; for (int i = 1; i &lt; c; i++) { double min = INT_MAX; int v = 0; for (int w = 0; w &lt; c; w++) { if (!final[w]) { if (d[w] &lt; min) { v = w; min = d[w]; } } } final[v] = true; for (int w = 0; w &lt; c; w++) { if (!final[w] &amp;&amp; (min + map[v][w] &lt; d[w])) { d[w] = min + map[v][w]; } } } // The goal is at point 1 double t = d[1] / 1000 / 40 * 60; int time = (int)(t + 0.5); printf(\"%d\\n\", time); return 0;}","link":"/algorithms/POJ/course/2-E Subway.html"},{"title":"","text":"2-F All Discs Considered描述Operating systems are large software artefacts composed of many packages, usually distributed on several media, e.g., discs. You probably remember the time when your favourite operating system was delivered on 21 floppy discs, or, a few years later, on 6 CDs. Nowadays, it will be shipped on several DVDs, each containing tens of thousands of packages. The installation of certain packages may require that other packages have been installed previously. Therefore, if the packages are distributed on the media in an unsuitable way, the installation of the complete system requires you to perform many media changes, provided that there is only one reading device available, e.g., one DVD-ROM drive. Since you have to start the installation somehow, there will of course be one or more packages that can be installed independently of all other packages. Given a distribution of packages on media and a list of dependences between packages, you have to calculate the minimal number of media changes required to install all packages. For your convenience, you may assume that the operating system comes on exactly 2 DVDs. 输入The input contains several test cases. Every test case starts with three integers N1, N2, D. You may assume that 1&lt;=N1,N2&lt;=50000 and 0&lt;=D&lt;=100000. The first DVD contains N1 packages, identified by the numbers 1, 2, …, N1. The second DVD contains N2 packages, identified by the numbers N1+1, N1+2, …, N1+N2. Then follow D dependence specifications, each consisting of two integers xi, yi. You may assume that 1&lt;=xi,yi&lt;=N1+N2 for 1&lt;=i&lt;=D. The dependence specification means that the installation of package xi requires the previous installation of package yi. You may assume that there are no circular dependences. The last test case is followed by three zeros. 输出For each test case output on a line the minimal number of DVD changes required to install all packages. By convention, the DVD drive is empty before the installation and the initial insertion of a disc counts as one change. Likewise, the final removal of a disc counts as one change, leaving the DVD drive empty after the installation. 样例输入123456783 2 11 22 2 21 34 22 1 11 30 0 0 样例输出123343 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;struct point { int in_1; int in_2; vector&lt;int&gt; dep;};struct point disc[100010];int main(void){ int m, n, d; int x, y; scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;d); while (m != 0 || n != 0 || d != 0) { int insert_1 = 0; queue&lt;int&gt; q[2]; for (int i = 1; i &lt;= m + n; i++) { disc[i].in_1 = 0; disc[i].in_2 = 0; disc[i].dep.clear(); } for (int i = 0; i &lt; d; i++) { scanf(\"%d %d\", &amp;x, &amp;y); disc[y].dep.push_back(x); disc[x].in_1 += 1; disc[x].in_2 += 1; } for (int i = 1; i &lt;= m; i++) { if (disc[i].in_1 == 0) { q[0].push(i); } } for (int i = m + 1; i &lt;= m + n; i++) { if (disc[i].in_1 == 0) { q[1].push(i); } } int u = 0; while (q[u].size() &gt; 0 || q[1 - u].size() &gt; 0) { while (q[u].size() &gt; 0) { int t = q[u].front(); q[u].pop(); for (vector&lt;int&gt;::iterator it = disc[t].dep.begin(); it &lt; disc[t].dep.end(); it++) { disc[*it].in_1 -= 1; if (disc[*it].in_1 &lt;= 0) { if (*it &lt;= m) { q[0].push(*it); } else { q[1].push(*it); } } } } u = 1 - u; insert_1++; } insert_1++; int insert_2 = 0; for (int i = 1; i &lt;= m; i++) { if (disc[i].in_2 == 0) { q[0].push(i); } } for (int i = m + 1; i &lt;= m + n; i++) { if (disc[i].in_2 == 0) { q[1].push(i); } } u = 1; while (q[u].size() &gt; 0 || q[1 - u].size() &gt; 0) { while (q[u].size() &gt; 0) { int t = q[u].front(); q[u].pop(); for (vector&lt;int&gt;::iterator it = disc[t].dep.begin(); it &lt; disc[t].dep.end(); it++) { disc[*it].in_2 -= 1; if (disc[*it].in_2 &lt;= 0) { if (*it &lt;= m) { q[0].push(*it); } else { q[1].push(*it); } } } } u = 1 - u; insert_2++; } insert_2++; if (insert_1 &gt; insert_2) { printf(\"%d\\n\", insert_2); } else{ printf(\"%d\\n\", insert_1); } scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;d); } return 0;}","link":"/algorithms/POJ/course/2-F All Discs Considered.html"},{"title":"","text":"求逆序对数描述对于一个长度为N的整数序列A，满足i &lt; j 且 Ai &gt; Aj.的数对(i,j)称为整数序列A的一个逆序请求出整数序列A的所有逆序对个数 输入输入包含多组测试数据，每组测试数据有两行第一行为整数N(1 &lt;= N &lt;= 20000)，当输入0时结束第二行为N个整数，表示长为N的整数序列 输出每组数据对应一行，输出逆序对的个数 样例输入123456751 2 3 4 555 4 3 2 1110 样例输出1230100 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int src[100000];int dst[100000];int res;void mergesort(int a, int b){ if ((b - a) &lt;= 1) { return; } mergesort(a, (a + b + 1) / 2); mergesort((a + b + 1) / 2, b); int x = a; int y = (a + b + 1) / 2; int z = a; while ((x &lt; (a + b + 1) / 2) &amp;&amp; (y &lt; b)) { // 最重要的一步: Count if (src[x] &gt; src[y]) { // x以及x之后的都是逆序对 res += (a + b + 1) / 2 - x; dst[z++] = src[y++]; } else { dst[z++] = src[x++]; } } // 后面的不可能再有逆序对了，因为前面都算过了 while (x &lt; (a + b + 1) / 2) { dst[z++] = src[x++]; } while (y &lt; b) { dst[z++] = src[y++]; } // 复制一下 for (int i = a; i &lt; b; i++) { src[i] = dst[i]; }}int main(void){ int n; scanf(\"%d\", &amp;n); while (n &gt; 0) { res = 0; for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;src[i]); } mergesort(0, n); printf(\"%d\\n\", res); scanf(\"%d\", &amp;n); } return 0;}","link":"/algorithms/POJ/course/3-A 求逆序对数.html"},{"title":"","text":"Raid描述After successive failures in the battles against the Union, the Empire retreated to its last stronghold. Depending on its powerful defense system, the Empire repelled the six waves of Union’s attack. After several sleepless nights of thinking, Arthur, General of the Union, noticed that the only weakness of the defense system was its energy supply. The system was charged by N nuclear power stations and breaking down any of them would disable the system. The general soon started a raid to the stations by N special agents who were paradroped into the stronghold. Unfortunately they failed to land at the expected positions due to the attack by the Empire Air Force. As an experienced general, Arthur soon realized that he needed to rearrange the plan. The first thing he wants to know now is that which agent is the nearest to any power station. Could you, the chief officer, help the general to calculate the minimum distance between an agent and a station? 输入The first line is a integer T representing the number of test cases.Each test case begins with an integer N (1 ≤ N ≤ 1000).The next N lines describe the positions of the stations. Each line consists of two integers X (0 ≤ X ≤ 1000000000) and Y (0 ≤ Y ≤ 1000000000) indicating the positions of the station.The next following N lines describe the positions of the agents. Each line consists of two integers X (0 ≤ X ≤ 1000000000) and Y (0 ≤ Y ≤ 1000000000) indicating the positions of the agent. 输出For each test case output the minimum distance with precision of three decimal placed in a separate line. 样例输入12345678910111213141516171819240 00 11 01 12 22 33 23 340 00 00 00 00 00 00 00 0 样例输出121.4140.000 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;double MAX = 100000000000;struct point { int x; int y; bool type; // true: station; false: agent;};struct point p[1050];int y[1050];int t[1050];int area[1050];bool compareByX(const point &amp;a, const point &amp;b){ return a.x &lt; b.x;}bool compareByY(const point &amp;a, const point &amp;b){ return a.y &lt; b.x;}int minInt(int a, int b){ return a &lt; b ? a : b;}double minDouble(double a, double b){ return a &lt; b ? a : b;}int MERGE(int start, int end, double left, double right){ int start1 = start, end1 = (start + end) / 2; int start2 = (start + end) / 2 + 1, end2 = end; int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) t[k++] = p[y[start1]].y &lt; p[y[start2]].y ? y[start1++] : y[start2++]; while (start1 &lt;= end1) t[k++] = y[start1++]; while (start2 &lt;= end2) t[k++] = y[start2++]; int i = 0; for (k = start; k &lt;= end; k++){ if(p[t[k]].x &gt;= left &amp;&amp; p[t[k]].x &lt;= right){ area[i++] = t[k]; } y[k] = t[k]; } return i;}double dist(point &amp;a, point &amp;b){ if (a.type == b.type) { return MAX; } else { return sqrt(pow((double)(a.x - b.x), 2) + pow((double)(a.y - b.y), 2)); }}double closestPair(int start, int end){ if ((end - start) &lt;= 0) { y[start] = start; return MAX; } else if ((end - start) == 1) { if (p[start].y &lt; p[end].y) { y[start] = start; y[end] = end; } else { y[start] = end; y[end] = start; } return dist(p[start], p[start + 1]); } // 分治为左边和右边（已经基于X坐标排序过） double min = minDouble(closestPair(start, (start + end) / 2), closestPair((start + end) / 2 + 1, end)); // 然后划分中间区域 double left = (double)(p[(start + end) / 2].x) - min; double right = (double)(p[(start + end) / 2].x) + min; // int areaLen = MERGE(start, end, left, right); for (int i = 0; i &lt; areaLen; i++) { for (int j = i + 1; j &lt; areaLen; j++) { if (p[area[j]].y &gt;= p[area[i]].y + min){ break; } double d = dist(p[area[i]], p[area[j]]); if (d &lt; min) { min = d; } } } return min;}int main(void){ int t; scanf(\"%d\", &amp;t); while (t--) { int n; int x, y; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d\", &amp;p[i].x, &amp;p[i].y); p[i].type = true; } for (int i = n + 1; i &lt;= 2 * n; i++) { scanf(\"%d %d\", &amp;p[i].x, &amp;p[i].y); p[i].type = false; } // 基于X坐标排序 sort(p + 1, p + 2 * n + 1, compareByX); printf(\"%.3lf\\n\", closestPair(1, 2 * n)); } return 0;}","link":"/algorithms/POJ/course/3-B Raid.html"},{"title":"","text":"Longest Ordered Subsequence描述A numeric sequence of ai is ordered if a1 &lt; a2 &lt; … &lt; aN. Let the subsequence of the given numeric sequence (a1, a2, …, aN) be any sequence (ai1, ai2, …, aiK), where 1 &lt;= i1 &lt; i2 &lt; … &lt; iK &lt;= N. For example, sequence (1, 7, 3, 5, 9, 4, 8) has ordered subsequences, e. g., (1, 7), (3, 4, 8) and many others. All longest ordered subsequences are of length 4, e. g., (1, 3, 5, 8). Your program, when given the numeric sequence, must find the length of its longest ordered subsequence. 输入The first line of input file contains the length of sequence N. The second line contains the elements of sequence - N integers in the range from 0 to 10000 each, separated by spaces. 1 &lt;= N &lt;= 1000 输出Output file must contain a single integer - the length of the longest ordered subsequence of the given sequence. 样例输入1271 7 3 5 9 4 8 样例输出14 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int res[1000];int num[1000];int n;int findLongestSeq(){ for (int i = 0; i &lt; n; i++) { int max = 1; for (int j = 0; j &lt; i; j++) { if (num[i] &gt; num[j]) { if (max &lt; (res[j] + 1)) { max = res[j] + 1; } } } res[i] = max; } int max = 0; for (int i = 0; i &lt; n; i++) { if (max &lt; res[i]) { max = res[i]; } } return max;}int main(void){ scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); } printf(\"%d\\n\", findLongestSeq()); return 0;} 代码 21234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[1010];int res[1010];int main(void){ cin &gt;&gt; n; memset(res, 0, sizeof(res)); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; num[i]; } for (int i = 0; i &lt; n; i++) { res[i] = 1; for (int j = 0; j &lt; i; j++) { if (num[i] &gt; num[j]) { res[i] = max(res[i], res[j] + 1); } } } int max_value = 0; for (int i = 0; i &lt; n; i++) { max_value = max(max_value, res[i]); } cout &lt;&lt; max_value &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/3-C Longest Ordered Subsequence.html"},{"title":"","text":"Common Subsequence描述A subsequence of a given sequence is the given sequence with some elements (possible none) left out. Given a sequence X = &lt; x1, x2, …, xm &gt; another sequence Z = &lt; z1, z2, …, zk &gt; is a subsequence of X if there exists a strictly increasing sequence &lt; i1, i2, …, ik &gt; of indices of X such that for all j = 1,2,…,k, xij = zj. For example, Z = &lt; a, b, f, c &gt; is a subsequence of X = &lt; a, b, c, f, b, c &gt; with index sequence &lt; 1, 2, 4, 6 &gt;. Given two sequences X and Y the problem is to find the length of the maximum-length common subsequence of X and Y. 输入The program input is from the std input. Each data set in the input contains two strings representing the given sequences. The sequences are separated by any number of white spaces. The input data are correct. 输出For each set of data the program prints on the standard output the length of the maximum-length common subsequence from the beginning of a separate line. 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;string a;string b;int cache[20000][20000];int max(int a, int b){ return (a &gt; b) ? a : b;}int findCommonSeq(int m, int n){ if (m &gt;= a.length() || n &gt;= b.length()) { return 0; } if (cache[m][n] == -1) { if (a[m] == b[n]) { cache[m][n] = 1 + findCommonSeq(m + 1, n + 1); } else { cache[m][n] = max(findCommonSeq(m, n + 1), findCommonSeq(m + 1, n)); } } return cache[m][n];}int main(void){ while (cin &gt;&gt; a &gt;&gt; b) { for (int i = 0; i &lt; a.length(); i++) { for (int j = 0; j &lt; b.length(); j++) { cache[i][j] = -1; } } cout &lt;&lt; findCommonSeq(0, 0) &lt;&lt; endl; } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233#include &lt;cstring&gt;#include &lt;iostream&gt;#define SIZE 500using namespace std;int dp[SIZE][SIZE];char a[SIZE];char b[SIZE];int m, n;int main(void){ while (cin &gt;&gt; a &gt;&gt; b) { m = strlen(a); n = strlen(b); for (int i = m; i &gt;= 0; i--) { for (int j = n; j &gt;= 0; j--) { if (i == m || j == n) { dp[i][j] = 0; } else if (a[i] == b[j]) { dp[i][j] = dp[i + 1][j + 1] + 1; } else { dp[i][j] = max(dp[i + 1][j], dp[i][j + 1]); } } } cout &lt;&lt; dp[0][0] &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/3-D Common Subsequence.html"},{"title":"","text":"月度开销描述农夫约翰是一个精明的会计师。他意识到自己可能没有足够的钱来维持农场的运转了。他计算出并记录下了接下来 N (1 ≤ N ≤ 100,000) 天里每天需要的开销。 约翰打算为连续的M (1 ≤ M ≤ N) 个财政周期创建预算案，他把一个财政周期命名为fajo月。每个fajo月包含一天或连续的多天，每天被恰好包含在一个fajo月里。 约翰的目标是合理安排每个fajo月包含的天数，使得开销最多的fajo月的开销尽可能少。 输入第一行包含两个整数N,M，用单个空格隔开。接下来N行，每行包含一个1到10000之间的整数，按顺序给出接下来N天里每天的开销。 输出一个整数，即最大月度开销的最小值。 样例输入123456787 5100400300100500101400 样例输出1500 提示若约翰将前两天作为一个月，第三、四两天作为一个月，最后三天每天作为一个月，则最大月度开销为500。其他任何分配方案都会比这个值更大。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int num[100000];int m, n;long long solve(long long left, long long right){ if(left == right){ return left; } else{ long long mid = (left + right) / 2; int month = 0; long long cost = 0; for(int i = 0; i &lt; n; i++){ if(cost + (long long)num[i] &lt;= mid){ cost += (long long)num[i]; } else if((long long)num[i] &lt;= mid){ month += 1; cost = (long long)num[i]; if(month &gt; m){ break; } } else{ break; } } if(month &lt; m){ return solve(left, mid); } else{ return solve(mid + 1, right); } }}int main(void){ long long left = 0; long long right = 0; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++){ scanf(\"%d\", &amp;num[i]); if(left &lt; num[i]){ left = (long long)num[i]; } right += (long long)num[i]; } printf(\"%lld\", solve(left, right)); return 0;}","link":"/algorithms/POJ/course/3-E 月度开销.html"},{"title":"","text":"LITTLE SHOP OF FLOWERS描述You want to arrange the window of your flower shop in a most pleasant way. You have F bunches of flowers, each being of a different kind, and at least as many vases ordered in a row. The vases are glued onto the shelf and are numbered consecutively 1 through V, where V is the number of vases, from left to right so that the vase 1 is the leftmost, and the vase V is the rightmost vase. The bunches are moveable and are uniquely identified by integers between 1 and F. These id-numbers have a significance: They determine the required order of appearance of the flower bunches in the row of vases so that the bunch i must be in a vase to the left of the vase containing bunch j whenever i &lt; j. Suppose, for example, you have bunch of azaleas (id-number=1), a bunch of begonias (id-number=2) and a bunch of carnations (id-number=3). Now, all the bunches must be put into the vases keeping their id-numbers in order. The bunch of azaleas must be in a vase to the left of begonias, and the bunch of begonias must be in a vase to the left of carnations. If there are more vases than bunches of flowers then the excess will be left empty. A vase can hold only one bunch of flowers. Each vase has a distinct characteristic (just like flowers do). Hence, putting a bunch of flowers in a vase results in a certain aesthetic value, expressed by an integer. The aesthetic values are presented in a table as shown below. Leaving a vase empty has an aesthetic value of 0. According to the table, azaleas, for example, would look great in vase 2, but they would look awful in vase 4. To achieve the most pleasant effect you have to maximize the sum of aesthetic values for the arrangement while keeping the required ordering of the flowers. If more than one arrangement has the maximal sum value, any one of them will be acceptable. You have to produce exactly one arrangement. 输入The first line contains two numbers: F, V.The following F lines: Each of these lines contains V integers, so that Aij is given as the jth number on the (i+1)st line of the input file. 1 &lt;= F &lt;= 100 where F is the number of the bunches of flowers. The bunches are numbered 1 through F.F &lt;= V &lt;= 100 where V is the number of vases.-50 &lt;= Aij &lt;= 50 where Aij is the aesthetic value obtained by putting the flower bunch i into the vase j. 输出The first line will contain the sum of aesthetic values for your arrangement. 样例输入12343 57 23 -5 -24 165 21 -4 10 23-21 5 -4 -20 20 样例输出153 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int MIN = -100000;int F, V;int val[100][100];int res[100][100];int max(int a, int b){ return a &gt; b ? a : b;}int solve(int f, int v){ if(f &gt;= F || v &gt;= V){ return 0; } if (res[f][v] == MIN) { int max = 0; for (int i = 0; f + i &lt; F; i++) { max += val[f + i][v + i]; } for (int i = v; i &lt;= V - F + f; i++) { int sum = val[f][i] + solve(f + 1, i + 1); if (sum &gt; max) { max = sum; } } res[f][v] = max; } return res[f][v];}int main(void){ scanf(\"%d %d\", &amp;F, &amp;V); for (int i = 0; i &lt; F; i++) { for (int j = 0; j &lt; V; j++) { scanf(\"%d\", &amp;val[i][j]); res[i][j] = MIN; } } printf(\"%d\\n\", solve(0, 0)); return 0;}","link":"/algorithms/POJ/course/3-F LITTLE SHOP OF FLOWERS.html"},{"title":"","text":"Arbitrage描述Arbitrage is the use of discrepancies in currency exchange rates to transform one unit of a currency into more than one unit of the same currency. For example, suppose that 1 US Dollar buys 0.5 British pound, 1 British pound buys 10.0 French francs, and 1 French franc buys 0.21 US dollar. Then, by converting currencies, a clever trader can start with 1 US dollar and buy 0.5 10.0 0.21 = 1.05 US dollars, making a profit of 5 percent. Your job is to write a program that takes a list of currency exchange rates as input and then determines whether arbitrage is possible or not. 输入The input will contain one or more test cases. Om the first line of each test case there is an integer n (1&lt;=n&lt;=30), representing the number of different currencies. The next n lines each contain the name of one currency. Within a name no spaces will appear. The next line contains one integer m, representing the length of the table to follow. The last m lines each contain the name ci of a source currency, a real number rij which represents the exchange rate from ci to cj and a name cj of the destination currency. Exchanges which do not appear in the table are impossible.Test cases are separated from each other by a blank line. Input is terminated by a value of zero (0) for n. 输出For each test case, print one line telling whether arbitrage is possible or not in the format “Case case: Yes” respectively “Case case: No”. 样例输入123456789101112131415161718192021223USDollarBritishPoundFrenchFranc3USDollar 0.5 BritishPoundBritishPound 10.0 FrenchFrancFrenchFranc 0.21 USDollar3USDollarBritishPoundFrenchFranc6USDollar 0.5 BritishPoundUSDollar 4.9 FrenchFrancBritishPound 10.0 FrenchFrancBritishPound 1.99 USDollarFrenchFranc 0.09 BritishPoundFrenchFranc 0.19 USDollar0 样例输出12Case 1: YesCase 2: No 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct currency { double value; int source; currency(double n, int s) : value(n), source(s) {}};int n = 0;int m = 0;string name[35];int count[35];vector&lt;currency&gt; cur[35];double d[35];int t[35];int t_max;bool in_queue[35];queue&lt;int&gt; q;int find_money(string a){ for (int i = 0; i &lt; n; i++) { if (!a.compare(name[i])) { return i; } } return -1;}int main(void){ cin &gt;&gt; n; string a, b; double c; int case_number = 0; while (n != 0) { bool res = false; case_number ++; // Read value for (int i = 0; i &lt; n; i++) { cin &gt;&gt; name[i]; cur[i].clear(); } cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; c &gt;&gt; b; cur[find_money(b)].push_back(currency(c, find_money(a))); } //SPFA for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { t[j] = 0; d[j] = 0; in_queue[j] = false; } t_max = 0; q.push(i); t[i] = 1; d[i] = 1; in_queue[i] = true; while ((!q.empty()) &amp;&amp; (t_max &lt; n)) { int cur_node = q.front(); q.pop(); in_queue[cur_node] = false; for (vector&lt;currency&gt;::iterator it = cur[cur_node].begin(); it != cur[cur_node].end(); it++) { if (d[it-&gt;source] &lt; d[cur_node] * it-&gt;value) { d[it-&gt;source] = d[cur_node] * it-&gt;value; if (!in_queue[it-&gt;source]) { q.push(it-&gt;source); if ((++t[it-&gt;source]) &gt; t_max) { t_max = t[it-&gt;source]; } in_queue[it-&gt;source] = true; } } } } if (t_max &gt;= n) { res = true; } while (!q.empty()) { q.pop(); } } if(res){ cout &lt;&lt; \"Case \" &lt;&lt; case_number &lt;&lt; \": Yes\" &lt;&lt; endl; } else{ cout &lt;&lt; \"Case \" &lt;&lt; case_number &lt;&lt; \": No\" &lt;&lt; endl; } cin &gt;&gt; n; } return 0;} 代码 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#define SIZE 35using namespace std;struct edge { int s; // source double v; // value edge(int s, double v) : s(s), v(v) {}};char money_name[SIZE][200];int n, m;int money(char name[]){ for (int i = 0; i &lt; n; i++) { if (!strcmp(name, money_name[i])) { return i; } } return -1;}int main(void){ int case_num = 0; cin &gt;&gt; n; while (n != 0) { case_num++; vector&lt;edge&gt; cur[SIZE]; // ========== Input ========== for (int i = 0; i &lt; n; i++) { cin &gt;&gt; money_name[i]; } cin &gt;&gt; m; char src[200], dest[200]; double value; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; src &gt;&gt; value &gt;&gt; dest; cur[money(dest)].push_back(edge(money(src), value)); } // ========== SPFA =========== bool res = false; // HERE: Run n times to avoid isolated points for (int i = 0; i &lt; n; i++) { // Variables for SPFA queue&lt;int&gt; q; double d[SIZE]; bool in_queue[SIZE]; int successor[SIZE]; int t[SIZE]; // Init for (int j = 0; j &lt; n; j++) { t[j] = 0; d[j] = 0; in_queue[j] = false; successor[j] = j; } int t_max = 0; // Start point t[i] = 1; d[i] = 1; q.push(i); in_queue[i] = true; // Begin while (!q.empty() &amp;&amp; t_max &lt;= n) { int c = q.front(); q.pop(); in_queue[c] = false; for (vector&lt;edge&gt;::iterator it = cur[c].begin(); it != cur[c].end(); it++) { // source &lt; (source-&gt;dest) * dest if (d[it-&gt;s] &lt; d[c] * it-&gt;v) { d[it-&gt;s] = d[c] * it-&gt;v; successor[it-&gt;s] = c; // If not in queue, then push it if (!in_queue[it-&gt;s]) { q.push(it-&gt;s); in_queue[it-&gt;s] = true; if (++t[it-&gt;s] &gt; t_max) { t_max = t[it-&gt;s]; } } } } } // Negative cycle detect if (t_max &gt;= n) { res = true; break; } } cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \"; if (res) { cout &lt;&lt; \"Yes\" &lt;&lt; endl; } else { cout &lt;&lt; \"No\" &lt;&lt; endl; } cin &gt;&gt; n; } return 0;}","link":"/algorithms/POJ/course/4-A Arbitrage.html"},{"title":"","text":"Drainage Ditches描述Every time it rains on Farmer John’s fields, a pond forms over Bessie’s favorite clover patch. This means that the clover is covered by water for awhile and takes quite a long time to regrow. Thus, Farmer John has built a set of drainage ditches so that Bessie’s clover patch is never covered in water. Instead, the water is drained to a nearby stream. Being an ace engineer, Farmer John has also installed regulators at the beginning of each ditch, so he can control at what rate water flows into that ditch.Farmer John knows not only how many gallons of water each ditch can transport per minute but also the exact layout of the ditches, which feed out of the pond and into each other and stream in a potentially complex network.Given all this information, determine the maximum rate at which water can be transported out of the pond and into the stream. For any given ditch, water flows in only one direction, but there might be a way that water can flow in a circle. 输入The input includes several cases. For each case, the first line contains two space-separated integers, N (0 &lt;= N &lt;= 200) and M (2 &lt;= M &lt;= 200). N is the number of ditches that Farmer John has dug. M is the number of intersections points for those ditches. Intersection 1 is the pond. Intersection point M is the stream. Each of the following N lines contains three integers, Si, Ei, and Ci. Si and Ei (1 &lt;= Si, Ei &lt;= M) designate the intersections between which this ditch flows. Water will flow through this ditch from Si to Ei. Ci (0 &lt;= Ci &lt;= 10,000,000) is the maximum rate at which water will flow through the ditch. 输出For each case, output a single integer, the maximum rate at which water may emptied from the pond. 样例输入1234565 41 2 401 4 202 4 202 3 303 4 10 样例输出150 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000001;int m, n;// m: count of points; (1 -&gt; m)// n: count of roads; (0 -&gt; n-1)int capacity[210][210];int former[210];int inqueue[210];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == m) { return true; } for (int i = 1; i &lt;= m; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ while (cin &gt;&gt; n &gt;&gt; m) { int max_flow = 0; memset(capacity, 0, sizeof(capacity)); int a, b, c; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; capacity[a][b] += c; } while (bfs()) { int bottleneck = MAX_VALUE; for (int i = m; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = m; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/4-C Drainage Ditches.html"},{"title":"","text":"Multiplication Puzzle描述The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row. The goal is to take cards in such order as to minimize the total number of scored points. For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring10*1*50 + 50*20*5 + 10*50*5 = 500+5000+2500 = 8000 If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be1*50*20 + 1*20*5 + 10*1*5 = 1000+100+50 = 1150. 输入The first line of the input contains the number of cards N (3 &lt;= N &lt;= 100). The second line contains N integers in the range from 1 to 100, separated by spaces. 输出Output must contain a single integer - the minimal score. 样例输入12610 1 50 50 20 5 样例输出13650 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;climits&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int c[110];int d[110][110];int rec(int a, int b){ if (d[a][b] &lt; 0) { if ((b - a) == 1) { d[a][b] = 0; } else { int min = INT_MAX; for (int i = a + 1; i &lt; b; i++) { int l = rec(a, i); int r = rec(i, b); if (min &gt; l + r + c[a] * c[i] * c[b]) { min = l + r + c[a] * c[i] * c[b]; } } d[a][b] = min; } } return d[a][b];}int main(void){ cin &gt;&gt; n; memset(d, -1, sizeof(d)); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; c[i]; } cout &lt;&lt; rec(0, n - 1) &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/4-B Multiplication Puzzle.html"},{"title":"","text":"The Perfect Stall描述Farmer John completed his new barn just last week, complete with all the latest milking technology. Unfortunately, due to engineering problems, all the stalls in the new barn are different. For the first week, Farmer John randomly assigned cows to stalls, but it quickly became clear that any given cow was only willing to produce milk in certain stalls. For the last week, Farmer John has been collecting data on which cows are willing to produce milk in which stalls. A stall may be only assigned to one cow, and, of course, a cow may be only assigned to one stall.Given the preferences of the cows, compute the maximum number of milk-producing assignments of cows to stalls that is possible. 输入The input includes several cases. For each case, the first line contains two integers, N (0 &lt;= N &lt;= 200) and M (0 &lt;= M &lt;= 200). N is the number of cows that Farmer John has and M is the number of stalls in the new barn. Each of the following N lines corresponds to a single cow. The first integer (Si) on the line is the number of stalls that the cow is willing to produce milk in (0 &lt;= Si &lt;= M). The subsequent Si integers on that line are the stalls in which that cow is willing to produce milk. The stall numbers will be integers in the range (1..M), and no stall will be listed twice for a given cow. 输出For each case, output a single line with a single integer, the maximum number of milk-producing stall assignments that can be made. 样例输入1234565 52 2 53 2 3 42 1 53 1 2 51 2 样例输出14 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000;int m, n;int dist;// n -&gt; cow; m -&gt; stall;int capacity[410][410];int road_count[210];int former[410];int inqueue[410];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == dist) { return true; } for (int i = 1; i &lt;= dist; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ while (cin &gt;&gt; n &gt;&gt; m) { dist = 1 + n + m + 1; int max_flow = 0; memset(capacity, 0, sizeof(capacity)); int stall; for (int i = 2; i &lt;= n + 1; i++) { cin &gt;&gt; road_count[i]; for(int j = 0; j &lt; road_count[i]; j++){ cin &gt;&gt; stall; capacity[i][1 + n + stall] = MAX_VALUE; } capacity[1][i] = 1; } for (int i = 1; i &lt;= m; i++){ capacity[1 + n + i][dist] = 1; } while (bfs()) { int bottleneck = 2 * MAX_VALUE ; for (int i = dist; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = dist; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; } return 0;}","link":"/algorithms/POJ/course/4-D The Perfect Stall.html"},{"title":"","text":"Dual Core CPU描述As more and more computers are equipped with dual core CPU, SetagLilb, the Chief Technology Officer of TinySoft Corporation, decided to update their famous product - SWODNIW. The routine consists of N modules, and each of them should run in a certain core. The costs for all the routines to execute on two cores has been estimated. Let’s define them as Ai and Bi. Meanwhile, M pairs of modules need to do some data-exchange. If they are running on the same core, then the cost of this action can be ignored. Otherwise, some extra cost are needed. You should arrange wisely to minimize the total cost. 输入There are two integers in the first line of input data, N and M (1 ≤ N ≤ 20000, 1 ≤ M ≤ 200000) .The next N lines, each contains two integer, Ai and Bi.In the following M lines, each contains three integers: a, b, w. The meaning is that if module a and module b don’t execute on the same core, you should pay extra w dollars for the data-exchange between them. 输出Output only one integer, the minimum total cost. 样例输入123453 11 102 1010 32 3 1000 样例输出113 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;struct edge { int dest; int capacity;} edge_set[100000000];vector&lt;int&gt; source[200000];int n, m;int level[200000];int edge_count = 0;void addedge(int u, int v, int capacity){ edge_set[edge_count].dest = v; edge_set[edge_count].capacity = capacity; source[u].push_back(edge_count++); edge_set[edge_count].dest = u; edge_set[edge_count].capacity = 0; source[v].push_back(edge_count++);}bool bfs(){ memset(level, 0, sizeof(level)); queue&lt;int&gt; bfs_queue; level[0] = 1; bfs_queue.push(0); while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == n + 1) { return true; } for (int i = 0; i &lt; source[cur].size(); i++) { int dest = edge_set[source[cur][i]].dest; if (level[dest] == 0 &amp;&amp; edge_set[source[cur][i]].capacity &gt; 0) { level[dest] = level[cur] + 1; bfs_queue.push(dest); } } } return false;}int dfs(int s, int t, int max_f){ if (s == t) return max_f; int ret = 0; for (int i = 0; i &lt; source[s].size(); i++) { int src = source[s][i]; int v = edge_set[src].dest, f = edge_set[src].capacity; if (level[s] + 1 == level[v] &amp;&amp; f &gt; 0) { int min_n = min(max_f - ret, f); f = dfs(v, t, min_n); if (src % 2 == 0) { edge_set[src].capacity -= f; edge_set[src + 1].capacity += f; } else { edge_set[src].capacity -= f; edge_set[src - 1].capacity += f; } ret += f; if (ret == max_f) return ret; } } return ret;}int main(void){ scanf(\"%d%d\", &amp;n, &amp;m); int a, b, c; for (int i = 1; i &lt;= n; i++) { scanf(\"%d%d\", &amp;a, &amp;b); addedge(0, i, a); addedge(i, n + 1, b); } for (int i = 0; i &lt; m; i++) { scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c); addedge(a, b, c); addedge(b, a, c); } int max_flow = 0; // for(int i = 1; i &lt;= n + 2; i ++){ // cout &lt;&lt; \"Source: \" &lt;&lt; i &lt;&lt; endl; // for(vector&lt;int&gt;::iterator it = source[i].begin(); it != source[i].end(); it++){ // cout &lt;&lt; edge_set[*it].dest &lt;&lt; '\\t' &lt;&lt; edge_set[*it].capacity &lt;&lt; endl; // } // } while (bfs()) { max_flow += dfs(0, n + 1, INF); } printf(\"%d\\n\", max_flow); return 0;}","link":"/algorithms/POJ/course/4-E Dual Core CPU.html"},{"title":"","text":"Dining描述Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others. Farmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible. Farmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both. Each dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2). 输入Line 1: Three space-separated integers: N, F, and DLines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink. 输出Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes 样例输入123454 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3 样例输出13 提示One way to satisfy three cows is:Cow 1: no mealCow 2: Food #2, Drink #2Cow 3: Food #1, Drink #1Cow 4: Food #3, Drink #3The pigeon-hole principle tells us we can do no better since there are only three kinds of food or drink. Other test data sets are more challenging, of course. 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int MAX_VALUE = 10000;int n, f, d;int dist;// n -&gt; cow; m -&gt; stall;int capacity[410][410];int former[410];int inqueue[410];queue&lt;int&gt; bfs_queue;bool bfs(){ memset(inqueue, 0, sizeof(inqueue)); memset(former, 0, sizeof(former)); while (!bfs_queue.empty()) { bfs_queue.pop(); } bfs_queue.push(1); inqueue[1] = 1; while (!bfs_queue.empty()) { int cur = bfs_queue.front(); bfs_queue.pop(); if (cur == dist) { return true; } for (int i = 1; i &lt;= dist; i++) { if (inqueue[i] == 0 &amp;&amp; capacity[cur][i] &gt; 0) { bfs_queue.push(i); inqueue[i] = 1; former[i] = cur; } } } return false;}int main(void){ cin &gt;&gt; n &gt;&gt; f &gt;&gt; d; int fi, di, food, drink; dist = 1 + f + n * 2 + d + 1; memset(capacity, 0, sizeof(capacity)); for (int cow = 1; cow &lt;= n; cow++) { cin &gt;&gt; fi &gt;&gt; di; for (int i = 0; i &lt; fi; i++) { cin &gt;&gt; food; capacity[1 + food][1 + f + cow] = 1; } for (int i = 0; i &lt; di; i++) { cin &gt;&gt; drink; capacity[1 + f + n + cow][1 + f + n * 2 + drink] = 1; } capacity[1 + f + cow][1 + f + n + cow] = 1; } for (int i = 1; i &lt;= f; i++) { capacity[1][1 + i] = 1; } for (int i = 1; i &lt;= d; i++) { capacity[1 + f + n * 2 + i][dist] = 1; } // cout &lt;&lt; \" S 1 2 3 1 2 3 4 1 2 3 4 1 2 3 E\" &lt;&lt; endl; // char ch[] = {' ', 'S', '1', '2', '3', '1', '2', '3', '4', '1', '2', '3', '4', '1', '2', '3', 'E'}; // for (int i = 1; i &lt;= dist; i++) { // cout &lt;&lt; ch[i] &lt;&lt; ' '; // for (int j = 1; j &lt;= dist; j++) { // cout &lt;&lt; capacity[i][j] &lt;&lt; ' '; // } // cout &lt;&lt; endl; // } int max_flow = 0; while (bfs()) { // for (int i = dist; i &gt; 1; i = former[i]) { // cout &lt;&lt; i &lt;&lt; ' '; // } // cout &lt;&lt; endl; int bottleneck = 2 * MAX_VALUE; for (int i = dist; i &gt; 1; i = former[i]) { if (bottleneck &gt; capacity[former[i]][i]) { bottleneck = capacity[former[i]][i]; } } for (int i = dist; i &gt; 1; i = former[i]) { capacity[former[i]][i] -= bottleneck; capacity[i][former[i]] += bottleneck; } max_flow += bottleneck; } cout &lt;&lt; max_flow &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/4-F Dining.html"},{"title":"","text":"To Europe! To Europe!描述Almost everyone in the candidate states wants to “go to Europe”, although most of the people have very vague ideas about what this actually means. Anyway, immediately after the borders are open, the inhabitants will take their cars and trucks and will “go to Europe”. This can cause many troubles, as the roads will be suddenly overloaded by vehicles of various types. You are to help to solve some of these traffic jams. Assume a convoy of vehicles has lined up in front of a single lane and one-way bridge over a river. Note that since the street is single lane, no vehicle can overtake any other. The bridge can sustain a given maximum load. To control the traffic on the bridge, operators are stationed on either end of the bridge. The convoy of vehicles is to be divided into groups, such that all the vehicles in any group can cross the bridge together. When a group reaches the other side, the operator on that side of the bridge uses a telephone to inform the operator on this side that the next group can start its journey over the bridge. The weight of each vehicle is known. The sum of the weights of the vehicles in any group cannot exceed the maximum load sustainable by the bridge. Associated with each vehicle is the maximum speed with which it can travel over the bridge. The time taken by a group of vehicles is calculated as the time taken by the slowest vehicle in the group to cross the bridge. The problem is to find the minimum amount of time in which the entire convoy can cross the bridge. 输入The input consists of several test cases. The first line of each test case contains three positive integers (separated by blanks): the first one represents the maximum load that the bridge can sustain b (in tonnes); the second one represents the length of the bridge l (in kms); and the third one is the number of vehicles (n) in the convoy. Each of the next n lines of input contains a pair of positive integers, wi and si (separated by blanks), where wi is the weight of the vehicle (in tonnes) and si is the maximum speed (in kmph) with which this vehicle can travel over the bridge. The weights and speeds of the vehicles are specified in the same order as the order in which the vehicles are queued up. You can assume that 1 &lt;= n,b,l,s &lt;= 1000 and any i in [1..n]: wi &lt;= b. After the last vehicle, the next test case description begins. The last test case is followed by a line containing three zeros. 输出The output of the program should be a single real number specifying the minimum time in minutes in which the convoy can cross the bridge. The number should be displayed with one digit after the decimal point. 样例输入123456789101112100 5 1040 2550 2050 2070 1012 509 7049 3038 2527 5019 700 0 0 样例输出175.0 代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#define NUM 1010using namespace std;int w[NUM];int s[NUM];double t[NUM];int main(void){ int b, l, n; scanf(\"%d %d %d\", &amp;b, &amp;l, &amp;n); while (b != 0 &amp;&amp; l != 0 &amp;&amp; n != 0) { l *= 60; for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d\", &amp;w[i], &amp;s[i]); } t[0] = 0; for (int i = 1; i &lt;= n; i++) { int slowest_speed = s[i]; int load = w[i]; t[i] = (double)l / (double)s[i] + t[i - 1]; for (int j = i - 1; j &gt;= 1; j--) { load += w[j]; if (load &gt; b) { break; } slowest_speed = slowest_speed &lt; s[j] ? slowest_speed : s[j]; t[i] = (t[i] &lt; (t[j - 1] + (double)l / (double)slowest_speed)) ? t[i]: (t[j - 1] + (double)l / (double)slowest_speed); } } printf(\"%.1lf\\n\", t[n]); scanf(\"%d %d %d\", &amp;b, &amp;l, &amp;n); } return 0;}","link":"/algorithms/POJ/course/M-A To Europe! To Europe!.html"},{"title":"","text":"Radar Installation描述Assume the coasting is an infinite straight line. Land is in one side of coasting, sea in the other. Each small island is a point locating in the sea side. And any radar installation, locating on the coasting, can only cover d distance, so an island in the sea can be covered by a radius installation, if the distance between them is at most d. We use Cartesian coordinate system, defining the coasting is the x-axis. The sea side is above x-axis, and the land side below. Given the position of each island in the sea, and given the distance of the coverage of the radar installation, your task is to write a program to find the minimal number of radar installations to cover all the islands. Note that the position of an island is represented by its x-y coordinates. Figure A Sample Input of Radar Installations 输入The input consists of several test cases. The first line of each case contains two integers n (1&lt;=n&lt;=1000) and d, where n is the number of islands in the sea and d is the distance of coverage of the radar installation. This is followed by n lines each containing two integers representing the coordinate of the position of each island. Then a blank line follows to separate the cases. The input is terminated by a line containing pair of zeros 输出For each test case output one line consisting of the test case number followed by the minimal number of radar installations needed. “-1” installation means no solution for that case. 样例输入1234567893 21 2-3 12 11 20 20 0 样例输出12Case 1: 2Case 2: 1 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int d, n;struct point { int x, y; double start, end; // Here we assume y is always smaller than d // We'll check whether y is larger than d when input point(int x, int y) : x(x), y(y) { double range = sqrt(pow(double(d), 2.0) - pow(double(y), 2.0)); start = double(x) - range; end = double(x) + range; } bool operator&lt;(const point &amp;p) const { return start &lt; p.start; } bool operator&gt;(const point &amp;p) const { return start &gt; p.start; }};int main(void){ cin &gt;&gt; n &gt;&gt; d; int case_num = 0; while (n != 0 &amp;&amp; d != 0) { case_num++; vector&lt;point&gt; v; int x, y; bool has_result = true; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x &gt;&gt; y; if (y &gt; d) { has_result = false; } v.push_back(point(x, y)); } if (!has_result) { cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \" &lt;&lt; -1 &lt;&lt; endl; } else { sort(v.begin(), v.end()); double radar_x = -1000000000; int radar_num = 0; for (vector&lt;point&gt;::iterator it = v.begin(); it != v.end(); it++) { if (it-&gt;start &gt; radar_x) { radar_num++; radar_x = it-&gt;end; } else { if (it-&gt;end &lt; radar_x) { radar_x = it-&gt;end; } } } cout &lt;&lt; \"Case \" &lt;&lt; case_num &lt;&lt; \": \" &lt;&lt; radar_num &lt;&lt; endl; } cin &gt;&gt; n &gt;&gt; d; } return 0;}","link":"/algorithms/POJ/course/M-B Radar Installation.html"},{"title":"","text":"Percolation描述定义一个N行N列的矩阵，矩阵中的每个元素是个方格，每个方格有两种可能的状态：开通的或关闭的。初始时，所有方格都是关闭的。输入数据的每一步会指定矩阵中某个原来关闭的方格变成开通的。要求编写程序判断当前是否存在从矩阵中最上面一行的任何一个开着的方格走到最下面一行的任何一个开着的方格的路径。如果存在的话，输出当前的步数。比如走到第14步时，矩阵变成上下通透的，那么就输出14。注意：输入数据中只会把矩阵中的一部分方格打开。如果所有步骤都执行完了，矩阵仍然不是上下通透的，那么输出-1。显然，矩阵变成上下通透的一个必要条件是：最上面一行和最下面一行都至少要有一个方格是打开的。 在矩阵中行走时，只能横着走或竖着走，不能斜着走，也不能走出矩阵的边界。 输入输入的第一行是一个自然数T(1≤T≤10)，代表测试数据的组数。每组测试数据的第一行有两个自然数N和M，其中N（1≤N≤1,000）代表方阵的维度，M（1≤M≤N*N）代表本组测试中打开的方格数目。随后的M行中每行有两个自然数，分别代表所打开的方格的行、列下标。注意：本题中矩阵的下标从1开始，即所有下标的取值都是[1, N]区间中的正整数。 输出每组测试数据输出一个自然数K，表示打开第K个方格后，矩阵变成上下通透的。如果M个方格都打开后，矩阵仍然不是上下通透的，那么输出-1。 样例输入12345678910111214 10 2 23 14 24 41 22 32 13 23 43 1 样例输出18 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstring&gt;#include &lt;iostream&gt;int parent[1000060];int map[1005][1005];int n, m, t;int find_parent(int loc){ //int loc = (x - 1) * n + y; if (parent[loc] == -1) { parent[loc] = loc; } if (loc != parent[loc]) { parent[loc] = find_parent(parent[loc]); } return parent[loc];}int calc_loc(int x, int y){ return (x - 1) * n + y;}int main(void){ scanf(\"%d\", &amp;t); while (t-- &gt; 0) { memset(parent, -1, sizeof(parent)); memset(map[0], 0, 1005 * 1005 * sizeof(int)); scanf(\"%d %d\", &amp;n, &amp;m); int result = -1; int x, y, ancestor, loc; for (int i = 1; i &lt;= m; i++) { scanf(\"%d %d\", &amp;x, &amp;y); if (result == -1) { map[x][y] = 1; loc = calc_loc(x, y); if (x &gt; 1 &amp;&amp; map[x - 1][y] == 1) { ancestor = find_parent(calc_loc(x - 1, y)); parent[ancestor] = find_parent(loc); } if (x == 1) { ancestor = find_parent(0); parent[ancestor] = find_parent(loc); } if (x &lt; n &amp;&amp; map[x + 1][y] == 1) { ancestor = find_parent(calc_loc(x + 1, y)); parent[ancestor] = find_parent(loc); } if (x == n) { ancestor = find_parent(n * n + 1); parent[ancestor] = find_parent(loc); } if (y &gt; 1 &amp;&amp; map[x][y - 1] == 1) { ancestor = find_parent(calc_loc(x, y - 1)); parent[ancestor] = find_parent(loc); } if (y &lt; n &amp;&amp; map[x][y + 1] == 1) { ancestor = find_parent(calc_loc(x, y + 1)); parent[ancestor] = find_parent(loc); } if (find_parent(0) == find_parent(n * n + 1)) { result = i; } } } printf(\"%d\\n\", result); } return 0;}","link":"/algorithms/POJ/course/M-C Percolation.html"},{"title":"","text":"Palindrome描述A palindrome is a symmetrical string, that is, a string read identically from left to right as well as from right to left. You are to write a program which, given a string, determines the minimal number of characters to be inserted into the string in order to obtain a palindrome. As an example, by inserting 2 characters, the string “Ab3bd” can be transformed into a palindrome (“dAb3bAd” or “Adb3bdA”). However, inserting fewer than 2 characters does not produce a palindrome. 输入Your program is to read from standard input. The first line contains one integer: the length of the input string N, 3 &lt;= N &lt;= 5000. The second line contains one string with length N. The string is formed from uppercase letters from ‘A’ to ‘Z’, lowercase letters from ‘a’ to ‘z’ and digits from ‘0’ to ‘9’. Uppercase and lowercase letters are to be considered distinct. 输出Your program is to write to standard output. The first line contains one integer, which is the desired minimal number. 样例输入125Ab3bd 样例输出12 代码12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100000using namespace std;char str[5050];int n;int dp[5050][5050];int main(void){ cin &gt;&gt; n &gt;&gt; str; int k = 0; for (int i = n - 1; i &gt;= 0; i--) { for (int j = i; j &lt; n; j++) { if (i == j) { dp[i][j] = 0; } else if (str[i] == str[j]) { dp[i][j] = dp[i + 1][j - 1]; } else { dp[i][j] = min(dp[i + 1][j] + 1, dp[i][j - 1] + 1); } } k = 1 - k; } cout &lt;&lt; dp[0][n - 1] &lt;&lt; endl; return 0;} 改进版本12345678910111213141516171819202122232425262728293031#include &lt;cstring&gt;#include &lt;iostream&gt;#define MAX 100000using namespace std;char str[5050];int n;int dp[2][5050];int main(void){ cin &gt;&gt; n &gt;&gt; str; int k = 0; for (int i = n - 1; i &gt;= 0; i--) { for (int j = i; j &lt; n; j++) { if (i == j) { dp[k][j] = 0; } else if (str[i] == str[j]) { dp[k][j] = dp[1 - k][j - 1]; } else { dp[k][j] = min(dp[1 - k][j] + 1, dp[k][j - 1] + 1); } } k = 1 - k; } cout &lt;&lt; dp[1 - k][n - 1] &lt;&lt; endl; return 0;}","link":"/algorithms/POJ/course/M-D Palindrome.html"},{"title":"","text":"重要逆序对描述给定N个数的序列a1,a2,…aN，定义一个数对(ai, aj)为“重要逆序对”的充要条件为 i &lt; j 且 ai &gt; 2aj。求给定序列中“重要逆序对”的个数。 输入本题有多个测试点，每个测试点分为两行：第一行为序列中数字的个数N（1 ≤ N ≤ 200000），第二行为序列a1, a2 … aN(0 ≤a ≤ 10000000)，由空格分开。N=0表示输入结束。 输出每个测试点一行，输出一个整数，为给序列中“重要逆序对”的个数。 样例输入123100 9 8 7 6 5 4 3 2 10 样例输出116 提示请注意答案范围，如果使用printf输出long long类型，请用%lld 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[10000010];int temp[10000010];long long mergesort(int a, int b) { long long sum = 0; if ((b - a) &lt;= 0) { return sum; } sum += mergesort(a, (a + b) / 2); sum += mergesort((a + b) / 2 + 1, b); int x = a; int y = (a + b) / 2 + 1; int mid = (a + b) / 2; // 重要逆序对，要求i &lt; j 且 ai &gt; 2aj // 所以先算一遍有多少ai &gt; 2aj while (x &lt;= (a + b) / 2 &amp;&amp; y &lt;= b) { if (num[x] &gt; 2 * num[y]) { sum += mid - x + 1; y++; } else { x++; } } // 然后再做Merge Sort x = a; y = (a + b) / 2 + 1; int i = a; while (x &lt;= (a + b) / 2 &amp;&amp; y &lt;= b) { if (num[x] &lt; num[y]) { temp[i++] = num[x++]; } else { temp[i++] = num[y++]; } } // 同样，后面不用再算了，因为前面都已经算过了 while (x &lt;= (a + b) / 2) { temp[i++] = num[x++]; } while (y &lt;= b) { temp[i++] = num[y++]; } for (int i = a; i &lt;= b; i++) { num[i] = temp[i]; } return sum;}int main(void) { long long res; scanf(\"%d\", &amp;n); while (n &gt; 0) { for (int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num[i]); } res = mergesort(0, n - 1); printf(\"%lld\\n\", res); scanf(\"%d\", &amp;n); } return 0;}","link":"/algorithms/POJ/course/M-E 重要逆序对.html"},{"title":"","text":"昂贵的聘礼描述年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。 输入输入第一行是两个整数M，N（1 &lt;= N &lt;= 100），依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。 输出输出最少需要的金币数。 样例输入1234567891 410000 3 22 80003 50001000 2 14 2003000 2 14 20050 2 0 样例输出15250 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#define SIZE 200using namespace std;int map[SIZE][SIZE];int l[SIZE];int m, n;int final[SIZE];int d[SIZE];int main(void){ fill(map[0], map[0] + SIZE * SIZE, INT_MAX); scanf(\"%d %d\", &amp;m, &amp;n); int x, t, v; for (int i = 1; i &lt;= n; i++) { scanf(\"%d %d %d\", &amp;map[0][i], &amp;l[i], &amp;x); for (int j = 0; j &lt; x; j++) { scanf(\"%d %d\", &amp;t, &amp;v); map[t][i] = v; } } int min_result = INT_MAX; for (int bound = 0; bound &lt;= m; bound++) { int upper_bound = l[1] + bound; int lower_bound = upper_bound - m; for (int i = 0; i &lt;= n; i++) { final[i] = false; d[i] = map[0][i]; } final[0] = true; d[0] = 0; for (int i = 1; i &lt;= n; i++) { int min_v = INT_MAX; int min_w = 0; for (int w = 1; w &lt;= n; w++) { if (!final[w] &amp;&amp; min_v &gt; d[w] &amp;&amp; l[w] &gt;= lower_bound &amp;&amp; l[w] &lt;= upper_bound) { min_v = d[w]; min_w = w; } } final[min_w] = true; for (int w = 1; w &lt;= n; w++) { if (map[min_w][w] &lt; INT_MAX &amp;&amp; l[w] &gt;= lower_bound &amp;&amp; l[w] &lt;= upper_bound) { d[w] = min(d[w], d[min_w] + map[min_w][w]); } } } min_result = min(min_result, d[1]); } printf(\"%d\\n\", min_result); return 0;}","link":"/algorithms/POJ/course/M-G 昂贵的聘礼.html"},{"title":"算法分析与复杂性理论","text":"第一次上机作业 玛雅历 棋盘问题 Til the Cows Come Home (Dijkstra) 仙岛求药 (BFS) 二叉树的操作 (Divide and Conquer) 2的幂次方表示 (Divide and Conquer) 第二次上机作业 Butterfly (Bipartite Graph) Dynamic Median (Priority Queue) Yogurt Factory (Greedy) The Unique MST (Minimum Spanning Tree) Subway (Dijkstra) All Discs Considered (Topological Sort) 第三次上机作业 求逆序对数 (Divide and Conquer) Raid (The Closest Pairs) Longest Ordered Subsequence (Longest Increasing Subsequence) Common Subsequence (Longest Common Subsequence) 月度开销 (Divide and Conquer, Binary Search) LITTLE SHOP OF FLOWERS (Dynamic Programming) 第四次上机作业 Arbitrage (SPFS, Negative Cycle Detect) Multiplication Puzzle (Matrix Multiplication) Drainage Ditches (Maximum Net Flow) The Perfect Stall (Maximum Net Flow) Dual Core CPU (Maximum Net Flow) Dining (Maximum Net Flow) 模拟考试 To Europe! To Europe! (Dynamic Programming) Radar Installation (Greedy) Percolation (Disjoint Set Union) Palindrome (Dynamic Programming) 重要逆序对 (Divide and Conquer) 昂贵的聘礼 (SPFS, Negative Cycle Detect)","link":"/algorithms/POJ/course/index.html"}],"posts":[{"title":"用编程展现绘画之美","text":"一个想法——通过Coding来画画。 这篇文章用于参加2016编程之美设计赛。 用编程展现绘画之美概述我们都知道，编程可以帮助我们更好地去探索动听的旋律： 我们也知道，编程可以帮助我们更好地吟诗作对，探索语言的魅力： 那么，编程可以帮助我们更好地去一览色彩的神奇吗？ 不妨和我一起试试，用Xaml语言来作一幅画吧。 教程首先，打开Visual Studio 2020，然后选择新建项目，在“新建项目”的对话框中选择“绘画”，在这里我们把作品命名为 Starry Night 在绘画之前，我们要准备好绘画用的材料以及想好自己想画的内容，跟着向导我们可以设定画的基本属性： 跟着向导完成初始化操作以后，我们可以看到接下来让我们挥洒灵感的地方： 而作品的标题、风格等信息已经定义好。 当然我们可以通过编写Xaml来绘画————例如，我们将画布涂上蓝色，再将整幅画按照黄金分割比例进行分隔：","link":"/2016/04/30/BoP/"},{"title":"在Ubuntu Server上配置CUDA环境","text":"在配置Ubuntu Server的CUDA和TensorFlow的过程中，遇到了很多问题（驱动无法正常运行、CUDA无法正常配置等等），在网上找了很多资料，最终正确安装驱动、CUDA、cuDNN和TensorFlow（GPU版本），因此将安装过程记录下来，方便以后再配环境。 版本要求： Ubuntu 16.04 LTS CUDA 9.0 cuDNN v7 Python 3.6 TensorFlow r1.10 PyTorch 0.4.1 1 准备工作1.1 检查GPU是否符合CUDA运行要求在Shell中运行命令： 1lspci | grep -i nvidia 查看GPU型号，然后在https://developer.nvidia.com/cuda-gpus页面中查找设备的GPU是否在支持CUDA的列表中。 1.2 检查GCC版本1gcc --version 对于Ubuntu 16.04来说，gcc版本需要&gt;5.4.0。 1.3 检查Kernel版本1uname -r 对于Ubuntu 16.04来说，内核版本需要&gt;4.4.0。 然后需要安装对应版本的Kernel Header： 1sudo apt-get install linux-headers-$(uname -r) 1.4 安装对应的库1234sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev \\ libboost-all-dev libhdf5-serial-dev libgflags-dev libgoogle-glog-dev liblmdb-dev \\ protobuf-compiler g++ freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev \\ libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 2 安装CUDA2.1 首先安装显卡驱动（选做，CUDA自带的驱动可能会无法正常运行）(1) 禁用Nouveau运行命令： 1lsmod | grep nouveau 如果有显示内容，则说明Nouveau驱动正在运行，需要根据教程关闭Nouveau。 (2) 卸载之前的显卡驱动(3) 下载并安装驱动在NVIDIA驱动下载页面按照自己的GPU型号、系统以及CUDA版本选择驱动并进行下载，得到诸如nvidia-diag-driver-local-repo-ubuntu1604_3XY.AB-1_amd64.deb的文件（XY.AB需要根据下载版本进行修改）。 然后运行以下命令： 1234sudo dpkg -i nvidia-diag-driver-local-repo-ubuntu1604_3XY.AB-1_amd64.deb（XY.AB需要根据下载版本进行修改）sudo apt-get updatesudo apt-get install cuda-driverssudo reboot 运行后系统会进行重启，在运行命令前请保存所有正在运行的工作。 重启后运行： 1sudo nvidia-smi 如果正常输出显卡状态说民驱动安装成功。 2.2 安装CUDA在CUDA下载页面下载Runfile形式的CUDA安装包，形式为cuda_9.0.176_384.81_linux.run。 具体CUDA和cuDNN版本参考TensorFlow安装要求，对于r1.10版本来说支持的CUDA版本为9.0。 (Optional) 对于有GUI的系统来说，需要在启动时按下Ctrl + Alt + F1/F4进入tty1/tty4模式，然后运行： 1sudo service lightdm stop 停止GUI运行。 开始安装CUDA。 1sudo sh cuda_9.0.176_384.81_linux.run 一路按空格，输入accept同意用户协议 安装程序询问是否安装驱动，输入no 询问是否安装CUDA Toolkit，输入yes 更改CUDA Toolkit安装位置，这里不作修改 是否创建/usr/local/cuda符号链接，如果只安装一个CUDA版本，输入yes 询问是否安装CUDA Samples，输入yes 更改CUDA Samples安装位置，这里不作修改 如果没有报错，则说明安装成功。如果提示： Installing the CUDA Toolkit in /usr/local/cuda-8.0 … Missing recommended library: libGLU.so Missing recommended library: libX11.so Missing recommended library: libXi.so Missing recommended library: libXmu.so 则需要安装依赖库： 1sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev 然后重新运行CUDA安装程序即可。 2.3 配置环境变量运行： 1sudo vi /etc/profile 用vi编辑启动脚本。用方向键将光标定位至文件末尾然后按i插入以下内容： 12export PATH=$PATH:/usr/local/cuda-9.0/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64:/usr/local/cuda-9.0/extras/CUPTI/lib64 在Shell中运行： 12export PATH=$PATH:/usr/local/cuda-9.0/binexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-9.0/lib64:/usr/local/cuda-9.0/extras/CUPTI/lib64 2.4 验证CUDA是否安装成功(1) 验证驱动版本运行： 1cat /proc/driver/nvidia/version 查看驱动版本。 (2) 查看nvcc版本运行： 1nvcc -V i 查看nvcc版本。 (3) 运行示例（选做）按照教程运行示例。 3 安装cuDNN在cuDNN下载页面下载TensorFlow支持的cuDNN版本，目前支持的是cuDNN v7。在下载时需要注册NVIDIA账号和开发者账号。 下载后得到一个诸如cudnn-9.0-linux-x64-v7.tgz的压缩包。 运行： 1tar -xvzf cudnn-9.0-linux-x64-v7.tgz 进行解压，在当前目录得到cuda文件夹。 然后运行 123sudo cp cuda/include/cudnn.h /usr/local/cuda/includesudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 将cuDNN拷贝至CUDA目录中。 可以按照官方教程来验证cuDNN的安装。 4 安装Tensorflow如果没安装pip，则需要安装pip： 1sudo apt-get install python3-pip python3-dev 然后尝试从官方源下载安装TensorFlow： 1pip3 install tensorflow-gpu 如果安装缓慢或者网络错误，请尝试切换至清华大学提供的镜像源： 1pip3 install tensorflow-gpu -i https://pypi.tuna.tsinghua.edu.cn/simple 接下来验证安装，在Shell或者IDE中运行代码： 12345# Python Codeimport tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello)) 等待，如果能够正常输出 1Hello, TensorFlow! 说明安装成功。如果输出错误信息，可以参考官方文档解决。 5 安装PyTorch运行： 1conda install pytorch torchvision -c pytorch 安装完成后，在Shell或者IDE里运行： 1234# Python Codeimport torchprint('CUDA support for Pytorch: ', torch.cuda.is_available())print('You are using device: ', torch.cuda.get_device_name(0)) 如果看到True和显卡名称，说明安装成功。 参考文档ubuntu16.04安装nvidia driver + cuda + cudnn (1) TensorFlow官方文档 CUDA安装文档（英文） cuDNN安装文档（英文） Ubuntu 14.04 上安装 CUDA 7.5/8.0 超详细教程","link":"/2018/08/15/Install-CUDA-on-Ubuntu-Server/"},{"title":"浅谈BackgroundWorker的使用","text":"这是弹幕派开发文档系列的第一篇！在开发弹幕派的过程中，通过网上的资料、MSDN学习到了很多WPF和C#的相关知识，在这里一并写出来，希望能够帮助到C#特别是WPF开发者。弹幕派是我们开发的一个桌面弹幕小程序，说它小，但是它的开发周期可不短，在开发过程中学到了很多东西，今天我要说的便是第一个，如何运用后台进程连接网络。 浅谈BackgroundWorker在WPF中的使用弹幕派在刚开始UI的渲染（即弹幕的产生和刷新）以及弹幕内容的获取都是在一个进程中完成的，这样导致一个问题就在于每当从网络获取数据时就会出现明显卡顿，如果网络失去连接就会导致程序假死无法继续进行。很明显这样是不行的，因此必须要引入多线程，通过后台线程获取数据，再将数据更新到UI中。 在WPF中，为了保证线程安全，Windows只允许创建UI元素的线程访问这些元素。如果在其他线程中尝试修改UI元素的属性，就会触发STA错误，导致程序崩溃。这样做是为了保证内容渲染的一致性。但是也会导致一个问题——我们无法通过后台线程直接修改UI元素的属性。WPF通过Dispatcher机制解决了这一问题。WPF为UI渲染设置了一个Dispatcher，这个Dispatcher我们可以理解为调度员，它与UI渲染相关的事件排成一个队列，按优先级对其队列中的元素进行排序，并且按序执行，这样可以保证UI在渲染时只执行一个任务，保证UI内容的一致性。如果我们的后台线程需要对界面元素的属性进行修改，可以请求UI线程代替它完成这一操作。那么如何请求UI线程帮忙呢？通过向Dispatcher注册工作项，将想要执行的任务加入队列，这个任务会在某个时间由Dispatcher完成，后台进程无需插手UI渲染。 Dispatcher类提供两种调用方法，一种是Invoke同步调用，调用方必须等待UI进程完成这一任务才会返回并继续下面的操作；另一种是BeginInvoke异步调用，调用方在调用后会立即返回。在弹幕派原有的代码中对这一部分有所使用。原本弹幕派刷新弹幕是通过每秒钟定时修改所有弹幕TextBlock的Margin属性的值达到移动弹幕的效果，那么在计时器Timer的Elapse事件触发的函数中，如果直接修改这些Margin会触发STA错误。因此需要通过BeginInvoke来执行这一操作。 12345private delegate void DispatcherDelegateTimer(); // 声明委托private void OnTimedEvent(object sender, EventArgs e) { this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new DispatcherDelegateTimer(UpdateUI)); //通过BeginInvoke注册} 使用后台进程有三种方式，第一种是Task，第二种是Thread，第三种就是我们今天要介绍的BackgroundWorker了。这三种方法各有千秋，但是BackgroundWorker更适合用于实现后台连接网络下载，因此在弹幕派的弹幕获取、自动更新等地方都主要使用了BackgroundWorker。 那么如何用BackgroundWorker实现后台连接网络获取数据呢？首先我们需要引入命名空间 1using System.ComponentModel; 之后我们需要添加BackgroundWorker组件，这一组件可以从Xaml界面添加——从工具箱中的“组件”选项卡中，添加BackgroundWorker组件；也可以在代码中声明： 1private BackgroundWorker fetchBW = new BackgroundWorker(); 之后在初始化过程中设置BackgroundWorker的属性，可以在构造函数中，也可以在Loaded函数中。 12345fetchBW.WorkerReportsProgress = true; //是否报告工作进度fetchBW.WorkerSupportsCancellation = true; //是否允许异步取消工作fetchBW.DoWork += new DoWorkEventHandler(FetchBW_DoWork); //这里声明要做的工作fetchBW.ProgressChanged += new ProgressChangedEventHandler(FetchBW_ProgressChanged); //当工作进度改变时更新界面fetchBW.RunWorkerCompleted += new RunWorkerCompletedEventHandler(FetchBW_RunWorkerCompleted); //当工作完成时处理工作结果 首先要设置是否报告工作进度，如果WorkerReportsProgress为true，则可以在ProgressChanged事件的函数中处理进度条等信息。当然Progress的数值要自行在DoWork函数中利用ReportProgress设置数值的变化（例如获取已经下载的进度并更新进度条）。 1234567891011121314151617181920212223private void backgroundWorker1_DoWork(object sender, DoWorkEventArgs e){ BackgroundWorker worker = sender as BackgroundWorker; for (int i = 1; i &lt;= 10; i++) { if (worker.CancellationPending == true) { e.Cancel = true; break; } else { // Perform a time consuming operation and report progress. System.Threading.Thread.Sleep(500); worker.ReportProgress(i * 10); } }}private void backgroundWorker1_ProgressChanged(object sender, ProgressChangedEventArgs e){ resultLabel.Text = (e.ProgressPercentage.ToString() + \"%\");} 如果允许异步取消（WorkerSupportsCancellation = false），则通过CancelAsync可以取消工作。此时CancellationPending = true。之后再绑定DoWork、ProgressChanged、RunWorkerCompleted事件。DoWork里写明主要功能，同时需要回报进度和处理取消事件。ProgressChanged里根据进度处理事件（修改进度条等），RunWorkerCompleted事件处理DoWork的结果。 那么如何在RunWorkerCompleted中获取DoWork的结果呢？ 1234567891011121314151617181920212223242526private void FetchBW_DoWork(Object sender, DoWorkEventArgs e) { BackgroundWorker backgroundWorker = sender as BackgroundWorker; //sender即源BackgroundWorker //...... // 将获得的结果进行封装，然后将解析结果保存至e.Result中供RunWorkerCompleted使用 fetchedData result = new fetchedData(num, contentList); e.Result = result; backgroundWorker.ReportProgress(100); // 当Dowork完成时直接将进度设为100%，触发RunWorkerCompleted事件}private void FetchBW_ProgressChanged(object sender, ProgressChangedEventArgs e) { return;}private void FetchBW_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e) { if (e.Cancelled == false &amp;&amp; e.Error == null) { fetchedData result = e.Result as fetchedData; danmuStorage.AddRange(result.contentList); result.contentList.Clear(); } else { Debug.WriteLine(\"获取时出现错误\"); } bwTimer.Stop();} 将结果保存至DoWork的e.Result中，之后可以在RunWorkerCompleted的e.Result中获取到结果。处理结果时要处理Cancelled（取消事件）和Error（错误事件）。这里要注意的是，对于网络访问等操作来说，很有可能会出现网络连接中断导致超时，因此这个时候需要我们设置一个定时器，在开始处理事件前启动定时器，然后在定时器超时时调用CancelAsync即可。 BackgroundWorker不仅可以在WPF中调用，在WinForm中也可以。BackgroundWorker最适合的场景便是后台下载，通过DoWork、ReportProgress和RunWorkerCompleted三者分开，可以明确地划分执行工作、更新界面、处理结果三个部分，与定时器Timer和按钮Button结合使用还可以保证程序不会由于网络连接中断等原因一直卡住。 参考资料wpf 多线程 线程处理模型 如何：使用后台辅助线程 如何：在后台下载文件 如何：在后台运行操作 BackgroundWorker Dispatcher类 委托 delegate","link":"/2016/08/29/BackgroundWorker/"},{"title":"在Electron上实现始终置顶且可调整大小的二维码窗口","text":"弹幕派正在筹划使用Electron+Vue.js+Element来重构之前的桌面客户端，在重构过程中需要基于Electron的特性对之前的功能进行调整。其中要实现在弹幕窗口上显示一个始终置顶且可以手动调整大小以及移动位置，在实现过程中遇到一些问题并加以解决，在此进行分享。 怎样展现二维码第一个问题，是怎样展现二维码。由于二维码叠加在弹幕窗口之上，因此有两种可选方案：一是在原有的弹幕窗口上添加一个Vue组件，将二维码展现上去即可；二是新建一个窗口，单独用于显示二维码。 第一种方案需要手动实现二维码的位置移动和大小调整，但是由于是随着弹幕窗口一起显示，开启和关闭状态的管理较为简单，同时由于在同一窗口内，二维码地址等参数传递方便；第二种方案需要新开一个窗口，因此需要手动管理窗口的状态，且参数传递需要通过主进程进行传递，实现复杂度有所提升，好处在于位置移动和大小调整使用原生实现即可。首先基于第一种方式进行了实现。 与弹幕在同一窗口显示二维码组件的实现整体较为简单，显示一张二维码图片即可。由于需要手动实现窗口的调整大小和关闭，因此添加两个按钮，分别对应关闭和调整大小，代码如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id=&quot;QRCode&quot; :style=&quot;location&quot;&gt; &lt;el-button circle class=&quot;close&quot;&gt; &lt;font-awesome-icon icon=&quot;times&quot;/&gt; &lt;/el-button&gt; &lt;el-button circle class=&quot;resize&quot;&gt; &lt;font-awesome-icon icon=&quot;expand-arrows-alt&quot;/&gt; &lt;/el-button&gt; &lt;img :src=&quot;src&quot; alt=&quot;QRCode&quot; class=&quot;QRCode&quot; :height=&quot;size&quot; :width=&quot;size&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import {remote} from &apos;electron&apos; export default { name: &quot;QRCode&quot;, data() { return { size: Math.floor(document.body.clientHeight / 2), location: { top: `${Math.floor(document.body.clientHeight / 4)}px`, left: `${Math.floor(document.body.clientWidth / 2 - document.body.clientHeight / 4)}px` } } }, props: { display: { type: Boolean }, src: { type: String } } }&lt;/script&gt; 值得注意的是初始显示位置和大小需要手动计算。 调整z-index接下来调整CSS样式。原本弹幕窗口的属性已经是始终置顶，下一步所需要做的是保证二维码在弹幕上方显示即可，通过设置z-index大于弹幕层的z-index即可，并设置position属性保证z-index生效。紧接着调整两个按钮的样式，设置position: absolute同时设置top和right值使其固定位置，在组件大小调整时仍然保持在窗口右上角/右下角即可。为了避免窗口过小时按钮遮挡住二维码，设置二维码的padding为1.5em并设置两个按钮的height和width为3em，这样可以跟随组件大小进行变化。最终CSS样式为： 1234567891011121314151617181920212223div { display: inline-block; position: absolute; padding: 1.5em; z-index: 4; } .close { position: absolute; top: 0; right: 0; height: 3em; width: 3em; } .resize { position: absolute; bottom: 0; right: 0; height: 3em; width: 3em; }} 全屏透明窗口的部分穿透完成以后运行可以看到二维码效果。接下来需要实现二维码的调整大小和关闭。然而这时会发现一个问题，和WPF不同的是，Electron不支持透明窗口的部分穿透。什么意思呢？由于我们的弹幕是全屏播放，因此为了保证不影响正常操作，需要在初始化窗口时设置window.setIgnoreMouseEvents(true)使得鼠标点击穿透到其他程序中。但是这样就导致没有办法通过点击按钮来调整二维码大小，也没有办法通过拖放来调整二维码显示的位置。而设置window.setIgnoreMouseEvents(false)又会导致其他窗口无法响应鼠标操作。在electron的官方GitHub Issue Support click-through of transparency #1335 有许多人遇到了同样的问题。简而言之，早期人们通过主进程捕捉当前鼠标位置像素点来决定是否发送事件给Renderer，非常复杂；在Electron 3.0.0版本后加入了setWindowShape API，如果是开发小部件（Gadget）的话使用这一API是非常得当的，直接将窗口大小设置为小部件的大小即可；但是由于弹幕需要全屏显示，因此需要其他方式来解决这一问题。 在Issue的最后有人提出一种解决方案，目前官方文档也已经写明：通过在元素上添加mouseenter和mouseleave事件，在鼠标进入二维码时设置window.setIgnoreMouseEvents(false)，捕捉鼠标事件；在鼠标离开元素时设置window.setIgnoreMouseEvents(true)释放鼠标事件，在本例中由于只有二维码一个元素需要处理鼠标事件，因此不会显得过于冗杂。完整实现为： 12345678let win = require('electron').remote.getCurrentWindow()let el = document.getElementById('QRCode')el.addEventListener('mouseenter', () =&gt; { win.setIgnoreMouseEvents(false)})el.addEventListener('mouseleave', () =&gt; { win.setIgnoreMouseEvents(true, { forward: true })}) 经过实现以后发现一个问题： 由于弹幕是Canvas动画，在鼠标移入/移出二维码时会导致明显的动画卡顿，在低性能设备上表现尤为明显，因此决定将这一方案弃置，转为用新窗口打开。 新窗口打开新窗口打开在实现上会比前一方案简单一点（并不），Vue组件基本和之前一样，不过由于调整二维码大小用的是原生的调整窗口大小，因此去掉resize按钮，同时把location、width和height等属性去掉即可。 接下来需要在主进程中实现二维码窗口，在主进程中创建createQRCodeWindow方法，通过传入screen.getAllDisplays()方法返回的screen对象获得窗口大小和位置进而调整每一个二维码窗口的显示；然后设置窗口属性（setAlwaysOnTop、loadURL等等）即可。值得注意的是需要在Vue Router里面配置QRCode.vue的路由。紧接着ipcMain中注册两个事件，一个是创建，另一个是关闭，传入参数为screen列表，根据列表在不同屏幕创建窗口即可。在渲染进程中通过按钮/开关等方式注册事件通过ipcRenderer触发事件并将当前已开启弹幕的屏幕的screen对象作为参数传入即可。 值得注意的是，为了避免窗口出错关闭后不断调用空引用提示错误，可以用try...catch...进行处理： 12345678910arg.forEach((idx) =&gt; { if (QRCodeWindows[idx]) { try { QRCodeWindows[idx].close() QRCodeWindows[idx] = null } catch (e) { danmakuWindows[idx] = null } } }) 如何传递参数打开窗口后我们要考虑两件事：一是如何使Vue页面知道自己所属的窗口，进而在调用ipcMain的关闭事件时指定自己所属的窗口；二是如何将二维码图片的地址从主进程传递到渲染进程中。一种方案是通过Vue Router的路由参数传递，另一种是通过ipcRenderer传递。前一种方案实现简单，但是将地址作为参数写入路由中总觉得会使地址过于丑陋，因此尝试第二种方案。 第二种方案在创建完窗口的同时通过调用window.webContents.send(channel, arguments)将参数传递过去，然后在Vue页面created环节通过注册ipcRender事件接收参数。但是实现后发现，参数并没有按照预期传递过去。这是由于我们在创建窗口并LoadURL后Vue生命周期还没有执行到created环节事件已经发出，渲染进程也就无法接收到参数。 那么为了保证事件可以被接收到，我们可以将发送参数作为一个事件放到ipcMain注册的事件中，等待渲染进程中Vue初始化完成了再进行调用，这样就确保渲染进程可以接收到参数。实现细节为： 主进程： 1234567891011121314ipcMain.on('initQRCode', () =&gt; { for (let k in QRCodeWindows) { if (QRCodeWindows.hasOwnProperty(k) &amp;&amp; QRCodeWindows[k]) { try { QRCodeWindows[k].webContents.send('initQRCode', { idx: k, src: 'http://static.danmakupie.com/qrcodes/VqUkcCq4Oj2ZmLDiROw3GA.png' }) } catch (e) { QRCodeWindows[k] = null } } }}) 渲染进程： 12345678created() { this.loading = true ipcRenderer.once('initQRCode', (event, arg) =&gt; { this.idx = arg.idx this.src = arg.src }) ipcRenderer.send('initQRCode', {})} 也就是说，等到Vue页面加载至created环节，注册事件监听后，再去触发主进程事件使其发送参数即可。但是这样有个问题是，渲染进程仍然不知道自己所在的窗口，因此主进程需要遍历所有的窗口逐一发送参数：如果窗口已经打开，那么窗口将接收参数；窗口没有打开则没有影响。这样会导致一个新问题：所有窗口初始化页面时都会触发主进程的事件，导致之前已经初始化过的窗口会不断响应并更新参数，这当然不是我们想要的，因此在渲染进程注册事件时使用once而非on方法，当触发时即注销事件，这样可以避免多次更新。 细节优化Loading界面由于二维码是从远端服务器获取图片，可能会出现图片加载时间过长，为了优化用户体验，可以加一个Loading界面。Element中提供了Loading界面，直接在div元素添加v-loading然后绑定一个Boolean变量即可。当开始载入页面时将loading变量设置为true，然后在图片加载完成时将loading变量设置为false即可。Vue中提供了图片加载完成事件v-on:load（简写为@load），直接绑定函数即可。 居中显示接下来要保证二维码图片始终居中显示。横向居中直接让div的属性设置为： 1234.container { text-align: center; margin: auto;} 即可。纵向居中稍微麻烦一点，具体可参考： CSS设置居中的方案总结-超全 和 盘点8种CSS实现垂直居中水平居中的绝对定位居中技术 由于是在Electron中实现，不需要考虑兼容性问题，因此这里使用兼容性比较差但是实现较为简单的flex，即添加一个父div，然后设置父div属性为： 1234#QRCodeParentContainer { display: flex; align-items: center;} 这样就能保证垂直居中和水平居中同时实现了。 等比例缩放但实际上这时会遇到一个问题，就是二维码并不是和窗口大小等比例缩放，且窗口没有办法等比例缩放。由官方Issue#8036可知目前Electron提供的API window.setAspectRatio(aspectRatio, extraSize: {width: float, height: float})只适用于macOS而非Windows，而Issue中提供的解决方案都不能很好地解决这一问题，因此接下来着重于保证二维码能够和窗口等比例缩放且按照最短边来显示，保证显示完整，不会出现滚动条。 首先设置图片的CSS样式为： 12345.QRCode { display: block; height: 100%; widht: 100%} 然后设置包含图片的子div的样式为： 1234#QRCodeChildContainer { width: 100vmin; height: 100vmin;} 其中vmin是指视口高度和宽度之间的最小值的 1/100。视口高度是指浏览器当前文档可见部分的高度，视口宽度同理。CSS引入了vh表示视口高度的 1/100，vw表示视口宽度的 1/100，vmin表示视口高度和宽度之间的最小值的 1/100，vmax表示视口高度和宽度之间的最大值的 1/100。在这里我们用100vmin就可以保证图片的大小始终是最短边来显示，不会出现滚动条。接着设置包含子div的父div格式为： 1234#QRCodeParentContainer { height: 100vh; width: 100vw;} 这样就可以保证二维码能够跟随窗口进行大小变化。 参考： 纯css实现容器高度随宽度等比例变化的四种解决方案 vh,vw单位你知道多少？ - MDN 文档 拖拽拖拽移动的实现非常简单，在div上添加属性-webkit-app-region: drag即可。为了防止拖拽override掉按钮点击事件，需要在按钮上添加属性-webkit-app-region: no-drag： 1234567#QRCodeChildContainer { -webkit-app-region: drag;}.close { -webkit-app-region: no-drag} 总结看似简单的二维码窗口却花了很长时间去调整和实现，本次实现主要涉及到以下一些知识点： 设置position使得z-index生效 Electron中透明窗口的部分穿透 Electron中如何用ipc从主进程向渲染进程传递初始化参数 Element中的Loading控制 CSS中元素的居中显示 CSS中元素等比例缩放 CSS实现Electron窗口拖拽","link":"/2019/02/06/An-always-on-top-window-based-on-electron/"},{"title":"如何快速掌握Markdown语法？","text":"Markdown 是一种轻量级标记语言。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。掌握Markdown语法的基本语法，只需要十点就够了。 Q: 有哪些网站可以用来写Markdown呢？ A: Github、简书都支持Markdown，Github中可以一边写Markdown一边预览。 Q: 有哪些Markdown编辑器呢？ A: 近似全能的新兴编辑器Visual Studio Code、MarkdownPad都可以用来写Markdown，你可以用他们来进行练习。 在Gist中，用Github账号登录以后即可建立一个Gist（可以理解为文章），在里面编辑Markdown文档可以直接点击Preview查看效果。 在Visual Studio Code中新建一个Markdown文档（即新建文档 -&gt; 另存为 文件名.md），在编辑时点击右上角预览按钮可以实时预览效果。 目录 一、段落和换行 二、标题 三、列表 四、链接 五、图片 六、粗体和斜体 七、代码 八、引用 九、反斜杠 十、分割线 Tips 一、段落和换行在Markdown里，一个换行不会另起一行，只有两个（及以上）的换行会另起一行。这是为了保证书写格式的整齐。 每一行的行首不能有空格和缩进。 二、标题用 # 来标记标题，# 越多，标题级别越小。# 后面要有一个空格，表明这个#是标题的意思。 12345# Head 1## Head 2### Head 3#### Head 4##### Head 5 Head 1Head 2Head 3Head 4Head 5三、列表用 * 来标记无序列表的项目，* 后面要有空格，缩进可以调整项目级别。 12345* Item 1* Item 2* Item 3 * Item 3.1 * Item 3.2 Item 1 Item 2 Item 3 Item 3.1 Item 3.2 用 1.、2.、3.（数字后面加一个点）标记有序列表的项目，标号后面要有空格。 12341. Item 12. Item 23. Item 34. Item 4 Item 1 Item 2 Item 3 Item 4 四、链接用方括号和圆括号表示链接。方括号括起 网址的标题或描述， 圆括号括起 网址。就像这样： 1[弹幕派](www.danmakupie.com) 弹幕派 五、图片图片和链接比较像，只不过图片要在前面加一个感叹号（!），方括号括起 图片的标题或描述，圆括号括起图片地址。 1![弹幕派Logo](http://7xr64j.com1.z0.glb.clouddn.com/blog/howtowritemarkdown/danmakupie-logo.png) 六、粗体和斜体用**和*分别标记粗体和斜体。 1**粗体** *斜体* 粗体 斜体 七、代码代码分为两种，一种是大段文字里掺杂一些代码，用`（键盘左上角的反引号）标记。 1在写C语言之前，要引入`#include &lt;stdio.h&gt;`才能正常编译。 在写C语言之前，要引入#include &lt;stdio.h&gt;才能正常编译。 另外一种是大块代码，用三个`（反引号）标记。 ``` #include int main(void){return 0;}``` 12345#include &lt;stdio.h&gt; int main(void){ return 0;} 我们还可以将代码行都缩进一个Tab，从而将这些行标记为代码（这也就是为什么不要在普通文字前面缩进）。 12345[Tab] #include &lt;stdio.h&gt;[Tab] [Tab] int main(void){[Tab] return 0;[Tab] } 12345#include &lt;stdio.h&gt; int main(void){ return 0;} 八、引用有的时候我们需要标明一段话是引用自其他文章的，我们用&gt;标记。 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 九、反斜杠（转义字符）上面可以看到，有很多字符都用来当标记符了。那么如果我们需要输入这些字符怎么办呢？答案就是反斜杠，用反斜杠来转义这些字符。 1\\*literal asterisks\\* *literal asterisks* Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： 123456789101112\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 十、分割线在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 1234567* * *********- - - Tips:1. 如果想要添加一个发送电子邮件的链接该怎么办？1[联系我们](mailto:danmakupie@outlook.com) 联系我们 1[联系我们](mailto:danmakupie@outlook.com?subject=弹幕派意见反馈) 联系我们 2. 链接可以跳转到本页面的另一个地方吗？在Github里是支持跳转到页面里的另一个标题的：1[八、引用](#八、引用) 八、引用 这样就可以跳转到“八、引用”这个标题了。这可以用来做目录。 所有用#标记的标题都可以。GitHub对中文的支持不太好。 3. 参考式链接一些链接可能要在文档里重复多次，每次都要写一遍链接太费事了。因此就有参考式链接。参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记： 1This is [an example][1] reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 1[1]: http://www.danmakupie.com \"弹幕派\" This is an example reference-style link. 4. 引用可以嵌套引用吗？可以，通过多个&gt;可以不断嵌套： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. This is the first level of quoting. This is nested blockquote. Back to the first level. 引用里还可以有其他标记： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 5. 如何输入上标和下标？用&lt;sub&gt;和&lt;/sub&gt;包括下标文字： 1H&lt;sub&gt;2&lt;/sub&gt;O H2O 用&lt;sup&gt;和&lt;/sup&gt;包括上标文字： 1X&lt;sup&gt;2&lt;/sup&gt;+2x+1 = 0 X2+2x+1 = 0 6. 代码块如何进行语法高亮？在```之后加上语言的标记，例如： ``` c 可以标记C语言。 具体各语言高亮支持请查看highlight.js - CSS classes reference 参考资料http://wowubuntu.com/markdown/ 延伸阅读Learning-Markdown (Markdown 入门参考) 这里有讲怎么用Markdown画表格（虽然我从来没画出来过）。","link":"/2016/11/01/How-to-Write-Markdown/"},{"title":"用Hexo搭建一个GitHub个人Blog","text":"不知道有没有人像我一样，想要建立个人主页，可是对JaveScript和PHP都不了解。不过现在好了，基于开源的Hexo，只需1小时，即可在GitHub搭建一个简单又美观的个人主页，并在上面发表你的第一篇文章。Here we go. 目录 准备 配置Git 安装Hexo 部署Hexo 下载主题 个性化你的博客 部署你的Blog 写文章 更多配置 添加站长统计和SiteMap 支持数学公式 添加RSS订阅 节点分流 准备 Node.js Git 选装 Markdown Pad 2 - Markdown编辑器 Visual Studio Code - Markdown编辑器 配置Git首先在GitHub上注册免费账号。接着在账户界面选择+ New repository，在Repository Name中填入用户名.github.io，选择Public，点击Create Respository创建一个目录。这个目录就是你的网站的存储空间。 接下来打开Git Bash，在Git Bash中输入 1cd ~/. ssh 以检查本机的ssh密钥。如果提示：’No such file or directory 说明你是第一次使用Git。 生成新的SSH Key： 123ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;此处直接回车&gt; 这里邮箱地址要填入注册邮箱地址。 然后设置密码： 12Enter passphrase (empty for no passphrase):&lt;输入加密串&gt;Enter same passphrase again:&lt;再次输入加密串&gt; 在回车中会提示你输入一个密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。注意：输入密码的时候没有*字样的，你直接输入就可以了。 最后看到这样的界面，就成功设置SSH Key了： 在本机设置SSH Key后，需要添加SSH Key到GitHub上，为之后的从本地向GitHub上提交网站做准备。 用文本编辑器打开C:\\Users\\用户名.ssh\\id_rsa.pub，里面是刚才生成的密钥。 登录GitHub，在右上角的头像选择Settings -&gt; SSH Key -&gt; New SSH Key，然后将文件中的内容拷贝至Key中即可。Title为这个SSH Key的名称，可以自定。 测试设置结果： 1$ ssh -T git@github.com 如果得到如下反馈： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 此时输入yes即可。然后会看到： 1Hi thesharing! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 说明SSH Key已经设置成功，这台设备的Git Bash已经可以访问你的GitHub了。 接下来需要设置登录信息： 12$ git config --global user.name &quot;你的用户名&quot;$ git config --global user.email &quot;你的注册邮箱&quot; 到这一步，Git Bash就配置完毕了。 安装HexoHexo 是一个快速、简洁且高效的博客框架。在安装完以上的软件以后，在命令提示行中使用npm命令即可完成安装。 1npm install -g hexo-cli 可能会有网络错误，可以重新执行命令安装。 接下来执行 1npm install 以安装所需的依赖包。 部署Hexo指定一个文件夹作为你的博客存放的文件夹，然后从此文件夹打开命令行，开始部署： 1hexo init 等待一段时间，Hexo会在这个文件夹下建立工作目录。现在本地博客已经建立完毕，执行以下命令： 12hexo generatehexo server 然后在浏览器中访问localhost:4000即可看到初始化的博客内容。 下载主题在Hexo的官方网站Themes|Hexo 上有一些主题可供使用，在Hexo的GitHub主页Themes - hexojs/hexo上提供了更多的主题链接可供下载。你可以选择用Git将主题Clone到本地，以获得主题的实时更新，也可以通过Download Zip将主题下载到本地的hexo文件夹/theme/使用。针对不同主题会有不同的设置项，一般主题的GitHub主页会提供Wiki来帮助设置主页。本次以PPOffice开发的Icarus为例进行主题方面的设置。 个性化你的博客首先要配置你的站点信息，用Visual Studio Code等文本编辑器（不推荐使用记事本，存在一些格式上的问题）打开hexo/_config.yml开始配置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Site 站点信息设置title: Zhilong's Blog # 站点标题subtitle: Have a try # 副标题description: Zhilong's personal blog on github # 给搜索引擎看的，对站点的描述，可以自定义author: Thesharing # 网站作者：在站点下方可以看到language: zh-CN # 语言：简体中文 # URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://thesharing.github.io/ #站点地址root: / #站点的根目录permalink: :year/:month/:day/:title/ #文章默认存放位置的格式，这里表示目录结构为：year/month/day/title.md# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render: [readme.md, \"*.html\", \"*.htm\"] # Writing 文章布局、写作格式的定义new_post_name: :title.md # 新文章的文章名，这里是用文章标题作为文件名default_layout: post # 默认的布局，详情查看https://hexo.io/zh-cn/docs/writing.html以获得更多信息auto_spacing: true # 是否在中文字符和英文字符之间自动添加空格titlecase: false # 是否将标题大写external_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true backtick_code_block: true line_number: true tab_replace: # 目录和标签default_category: uncategorized # 默认目录category_map:tag_map:sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml# Archives 默认值为2，这里都修改为1，相应页面就只会列出标题，而非全文## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server 本地服务器信息## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: falselogger_format: # Date / Time format 日期、时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss # Pagination 每页显示文章数，可以自定义## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions 配置站点所用主题和插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themestheme: icarus # 主题 # Deployment 站点部署到github的设置## 官方文档：https://hexo.io/zh-cn/docs/deployment.htmldeploy: type: git repository: https://github.com/thesharing/thesharing.github.io.git # Repository地址 branch: master 可以将其直接复制入你的_config.yml文件中使用。下面解释各项如何修改。 Site按照说明修改即可。 URL将url改为你的博客首地址，可以到GoDaddy上购买域名进行绑定，那么这里就应该改成你的域名而非GitHub.io地址。 Writing - Pagination均不必修改，如自定义请参考官方Doc进行修改。 Theme将Theme修改为你下载的主题的主题名，要注意，theme文件夹下的主题文件夹也要对应名称。 Deploy将repository改为https://github.com/你的用户名/你的用户名.github.io.git，branch不变。 此时第一个配置文件设置结束，我们打开主题的配置文件来配置主题样式。这里以icarus为例，打开hexo/themes/icarus/_config.yml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235# Version of the Icarus theme that is currently usedversion: 2.3.0# Path or URL to the website's iconfavicon: /images/favicon.png# Path or URL to RSS atom.xmlrss: rss.xml# Path or URL to the website's logo to be shown on the left of the navigation bar or footerlogo: /images/logo.png# Open Graph metadata# https://hexo.io/docs/helpers.html#open-graphopen_graph: # Facebook App ID fb_app_id: # Facebook Admin ID fb_admins: # Twitter ID twitter_id: # Twitter site twitter_site: # Google+ profile link google_plus: # Navigation bar link settingsnavbar: # Navigation bar menu links menu: 首页: / 归档: /archives 关于: /about # Navigation bar links to be shown on the right links: GitHub: icon: fab fa-github url: 'http://github.com/thesharing/'# Footer section link settingsfooter: # Links to be shown on the right of the footer section links: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/'# Article display settingsarticle: # Code highlight theme # https://github.com/highlightjs/highlight.js/tree/master/src/styles highlight: pojoaque # Whether to show article thumbnail images thumbnail: false # Whether to show estimate article reading time readtime: true# Search plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Search-Pluginssearch: # Name of the search plugin type: insight# Comment plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Comment-Pluginscomment: # Name of the comment plugin type: disqus shortname: thesharing# Donation entries# http://ppoffice.github.io/hexo-theme-icarus/categories/Donation/donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: '/images/alipay.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: '/images/wechat.jpg' # - # # Donation entry name # type: paypal # # Paypal business ID or email address # business: '' # # Currency code # currency_code: USD # - # # Donation entry name # type: patreon # # URL to the Patreon page # url: ''# Share plugin settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Configuration/Share-Pluginsshare: # Share plugin name type: sharejs# Sidebar settings.# Please be noted that a sidebar is only visible when it has at least one widgetsidebar: # left sidebar settings left: # Whether the left sidebar is sticky when page scrolls # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false # right sidebar settings right: # Whether the right sidebar is sticky when page scrolls # http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/make-a-sidebar-sticky-when-page-scrolls/ sticky: false# Sidebar widget settings# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: - # Widget name type: profile # Where should the widget be placed, left or right position: left # Author name to be shown in the profile widget author: Your Name # Title of the author to be shown in the profile widget author_title: Your Title # Author's current location to be shown in the profile widget location: Your Location # Path or URL to the avatar to be shown in the profile widget avatar: /images/avatar.png # Email address for the Gravatar to be shown in the profile widget gravatar: # Whether to show avatar image rounded or square avatar_rounded: true # Path or URL for the follow button follow_link: 'http://github.com/thesharing/' # Links to be shown on the bottom of the profile widget social_links: Github: icon: fab fa-github url: '' StackOverflow: icon: fab fa-stack-overflow url: '' Steam: icon: fab fa-steam url: '' Instagram: icon: fab fa-instagram url: '' Weibo: icon: fab fa-weibo url: '' Facebook: icon: fab fa-facebook url: '' Twitter: icon: fab fa-twitter url: '' - # Widget name type: toc # Where should the widget be placed, left or right position: right - # Widget name type: links # Where should the widget be placed, left or right position: left # Links to be shown in the links widget links: GitHub - Thesharing: http://github.com/thesharing/ - # Widget name type: recent_posts # Where should the widget be placed, left or right position: right - # Widget name type: archive # Where should the widget be placed, left or right position: right - # Widget name type: category # Where should the widget be placed, left or right position: right - # Widget name type: tag # Where should the widget be placed, left or right position: right - # Widget name type: tagcloud # Where should the widget be placed, left or right position: left# Other plugin settingsplugins: # Enable page animations animejs: true # Enable the lightGallery and Justified Gallery plugins # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/gallery-plugin/ gallery: true # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated-browser: true # Enable the MathJax plugin # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/mathjax-plugin/ mathjax: true # Show the back to top button on mobile devices back-to-top: true # Google Analytics plugin settings # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Google-Analytics google-analytics: # Google Analytics tracking id tracking_id: # Baidu Analytics plugin settings # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Baidu-Analytics baidu-analytics: # Baidu Analytics tracking id tracking_id: # Hotjar user feedback plugin # http://ppoffice.github.io/hexo-theme-icarus/Plugins/General/site-analytics-plugin/#Hotjar # hotjar: # # Hotjar site id # site_id: # Show a loading progress bar at top of the page progressbar: true # Show the copy button in the highlighted code area clipboard: true # BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: false# CDN provider settings# http://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL of the JavaScript and/or stylesheet CDN provider cdn: unpkg # Name or URL of the webfont CDN provider fontcdn: google # Name or URL of the webfont Icon CDN provider iconcdn: fontawesome 可配置项 在配置的navbar部分中按照页面名: 页面目录的格式可以自行添加页面。 logo中可以设置Logo以及Logo大小。建议直接替换而非自定目录。 avatar中设置资料页的头像，author为作者名，author_title为作者介绍，location为地区，follow为“关注我”指向的地址。 highlight为语法高亮的主题 sidebar为资料页的位置（左、右） thumbnail设置是否显示缩略图 favicon设置网站图标 social_links设置社交图标 comment设置评论系统，disqus后填入论坛名即可 plugin中设置Google站长分析等插件信息 Disqus进入Disqus完成注册以后，点击右上角的“设置”，选择“Add Disqus To Site”，然后按照向导进行设置即可。这里要注意，Disqus URL中填写的就是上面设置文件中要填写的论坛名。 生成并预览设置完成后，在hexo文件夹下打开命令行输入 12hexo generatehexo server 如果运行成功，那么输入localhost:4000即可打开你的个人主页。 部署你的Blog之前我们一直在本地运行，接下来我们要把个人主页部署到GitHub上去。在每一次对设置的修改以及写文章之后都要用hexo generate命令重新生成一次。然后右击hexo文件夹，选择Git Bash Here，打开Git Bash，在Git Bash中输入 1$ npm install hexo-deployer-git --save 等待安装完成以后，再执行： 1$ hexo deploy 有可能会提示输入邮箱和密码，按照之前设置的输入即可。如果失败可能是网络问题，重新尝试一下。 提示成功以后可以在你的GitHub的该Repository下看到Commit成功+1，说明服务器已经接受了你的提交，一般等待3-5分钟以后，你的Blog便会被刷新。此时用你的用户名.github.io即可访问到你的Blog，怎么样，是不是很Coooool？ 写文章那么说了这么多，个人主页已经建好，接下来就是充实内容了。内容怎么充实呢？写文章咯。 在hexo文件夹下打开命令行，输入： 1hexo new [layout] &lt;title&gt; 这里[layout]是指你所用的模板名称，所有模板都在hexo\\scaffolds\\文件夹下存放，关于模板的更多信息，请访问官方Doc，里面有很详尽的解释。 title则是文章的标题，可以为中文。 在执行完命令后，到hexo\\source\\_posts\\文件夹下可以找到生成的Markdown文件。用MarkdownPad 2或者Visual Studio Code打开Markdown文件即可开始书写你的文章，正如我现在所做。至于Markdown文法，又是一个大坑。 对于图片，我们需要将文章中要用到的图片上传至图床然后引用外链。图床是指存放图片的云存储空间，我个人正在使用的是七牛，可以找一个适合自己的图床一直用下去。 在写完文章以后，再次hexo generate然后部署就可以了。 Markdown教程：如何快速掌握Markdown语法？ Hexo中支持的语法高亮：highlight.js - CSS classes reference 更多配置添加站长统计和SiteMap为了提升在搜索引擎中的搜索权重，可以通过添加站长统计以及提交SiteMap进一步优化SEO。 首先注册百度站长统计和 Google Analytics，获得追踪ID。对于百度站长统计来说，只需要在管理后台的新版统计代码获取页面复制追踪ID至icarus的baidu-analytics - tracking_id即可。对于Google Analytics来说，只需要在管理后台的媒体资源设置页面复制跟踪 ID至icarus的google-analytics - tracking_id即可。 然后需要生成SiteMap。在Hexo根目录下执行： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 安装完成后在Hexo文件夹中的_config.yml中添加： 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 然后运行hexo -g即可生成sitemap.xml和baidusitemap.xml文件。 在生成了SiteMap文件后需要进行提交。 百度提交方式为： 访问链接提交|百度搜索资源平台并用百度账号登录，然后选择自动提交 - sitemap方式填入baidusitemap.xml的地址即可。 Google提交方式为： 访问Search Console，用Google账号登录，下载Google验证网页，将其放入hexo/source文件夹中，同时在Hexo的_config.yml文件中设置渲染排除项： 1skip_render: [readme.md, \"*.html\", \"*.htm\"] 然后运行hexo generate并运行hexo deploy。接着在Search Console的抓取 - 站点地图部分指定sitemap.xml的地址即可。 可参考hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌） 支持数学公式目前主流的数学公式库为MathJax，对于icarus这样直接支持MathJax的主题，在其_config.yml文件的plugin部分设置mathjax: true即可。 对于不支持MathJax的主题来说，在Hexo根目录下运行： 1npm install --save hexo-math 然后在Hexo的_config.yml文件中设置MathJax： 123456math: engine: 'mathjax' mathjax: src: custom_mathjax_source config: # MATHJAX CONFIG 可参考hexo中插入数学公式 添加RSS订阅首先在Hexo根目录下运行： 1npm install --save hexo-generator-feed 然后在Hexo的_config.yml文件中添加配置： 1234567feed: type: atom path: rss.xml limit: 0 hub: content: true order_by: -date 接着在icarus的_config.yml文件中添加RSS的入口，可以在Navbar部分添加RSS链接： 1234567navbar: # Navigation bar menu links menu: 首页: / 归档: /archives 关于: /about RSS: /rss.xml 也可以在Social Links部分添加： 1234social_links: RSS: icon: fab fa-rss url: '/rss.xml' 可参考为hexo博客添加RSS订阅功能 节点分流如果你已经将你的个人主页挂靠在自己申请的域名上，那么你可以通过域名解析进行节点分流，国外用户访问GitHub，国内用户访问coding.net，从而解决GitHub在国内访问速度慢的问题。 首先在coding.net（现在又称腾讯云开发者平台）注册账号，并新建一个项目，然后在项目设置中开启Pages服务。然后在Hexo的_config.xml文件中设置deploy到多个仓库中： 12345deploy: type: git repository: github: git@github.com:abc/abc.github.io.git tencent: git@git.dev.tencent.com:abc/abc.git 接下来运行hexo d将页面分别部署到两个仓库中。访问coding.net / GitHub提供的原始网址，保证可以正常访问。 再在云服务商的域名解析页面进行设置，添加CNAME记录，境外线路指向abc.github.io，境内线路指向abc.coding.me。等待DNS刷新后就可以进行节点分流了。 推荐阅读 与 参考资料文档 | Hexo Hexo系列教程 - 2 如何搭建一个独立博客——简明Github Pages与Hexo教程 Hexo你的博客 Hexo的GitHub文档（英文） Markdown 语法 问题 Markdown Pad 2 无法正常预览怎么办？ 按照官网提示，安装Awesomium 1.6.6 SDK以及Microsoft’s DirectX End-User Runtimes (June 2010)以后可以解决。","link":"/2016/02/23/Build-a-Github-Blog-with-Hexo/"},{"title":"用Markdown写公式","text":"在写课堂报告的时候，用Latex会比较笨重，用Word插入公式又太麻烦，用Markdown则恰如其分，因此这篇文章主要涉及如何在Markdown中使用Mathjax，参考LaTeX语法来书写公式。公式可以在Typora里导出成PDF文档。 一、公式使用参考 插入公式 上下标 括号和分隔符 输入分数 输入开方 省略号 输入矢量 输入积分 极限运算 累加、累乘运算 希腊字母 其他特殊字符 字体转换 大括号和行标的使用 其他命令 二、矩阵使用参考 无框矩阵 边框矩阵 带省略符号的矩阵 带分割符号的矩阵 行中矩阵 三、方程式序列使用参考 方程式序列 在一个方程式序列的每一行中注明原因 四、条件表达式使用参考 条件表达式 左侧对齐的条件表达式 使条件表达式适配行高 五、数组与表格使用参考 数组或表格 嵌套的数组或表格 方程组 六、连分数使用参考 连分式 七、交换图表使用参考 交换图表 八、一些特殊的注意事项 Reference 一、公式使用参考插入公式$\\LaTeX{}$的数学公式有两种：行中公式和独立公式。行中公式放在文中与其它文字混编，独立公式单独成行。 行中公式可以用如下方法表示： 1$ 数学公式 $ 独立公式可以用如下方法表示： 1$$ 数学公式 $$ 自动编号的公式可以用如下方法表示： 若需要手动编号，参见 大括号和行标的使用。 1234\\begin{equation}数学公式\\label{eq:当前公式名}\\end{equation} 自动编号后的公式可在全文任意处使用\\eqref{eq:公式名}语句引用。 例： 1$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 行内公式：$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ 例： 1$$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ $$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ 例： 123\\begin{equation}E=mc^2 \\text{，自动编号公式示例}\\end{equation} $$\\begin{equation}E=mc^2 \\text{，自动编号公式示例}\\end{equation}$$ 上下标^ 表示上标, _ 表示下标。如果上下标的内容多于一个字符，需要用 {} 将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例： 1$$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ 另外，如果要在左右两边都有上下标，可以用 \\sideset 命令。 例： 1$$ \\sideset{^1_2}{^3_4}\\bigotimes $$ $$ \\sideset{^1_2}{^3_4}\\bigotimes $$ 括号和分隔符()、[] 和 | 表示符号本身，使用 \\{\\} 来表示 {} 。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。 一些特殊的括号： 输入 显示 输入 显示 \\langle $\\langle$ \\rangle $\\rangle$ \\lceil $\\lceil$ \\rceil $\\rceil$ \\lfloor $\\lfloor$ \\rfloor $\\rfloor$ \\lbrace $\\lbrace$ \\rbrace $\\rbrace$ 例：1$$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ $$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ 有时候要用 \\left. 或 \\right. 进行匹配而不显示本身。 例：1$$ \\left \\frac{{\\rm d}u}{{\\rm d}x} \\right | _{x=0} $$ 输入分数通常使用 \\frac {分子} {分母} 命令产生一个分数，分数可嵌套。便捷情况可直接输入 \\frac ab 来快速生成一个 $\\frac ab$。如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 例：1$$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ $$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ 输入开方使用 \\sqrt [根指数，省略时为2] {被开方数} 命令输入开方。 例：1$$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ 省略号数学公式中常见的省略号有两种，\\ldots 表示与文本底线对齐的省略号，\\cdots 表示与文本中线对齐的省略号。 例：1$$f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2$$ $$f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2$$ 输入矢量使用 \\vec{矢量} 来自动产生一个矢量。也可以使用 \\overrightarrow 等命令自定义字母上方的符号。 例：1$$\\vec{a} \\cdot \\vec{b}=0$$ $$\\vec{a} \\cdot \\vec{b}=0$$ 例：1$$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ $$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ 输入积分使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 例：1$$\\int_0^1 {x^2} \\,{\\rm d}x$$ $$\\int_0^1 {x^2} \\,{\\rm d}x$$ 本例中 \\, 和 {\\rm d} 部分可省略，但建议加入，能使式子更美观。 极限运算使用 \\lim_{变量 \\to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例：1$$ \\lim_{n \\to +\\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} $$ $$\\lim_{n \\to +\\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)}$$ 累加、累乘运算使用 \\sum_{下标表达式}^{上标表达式} {累加表达式} 来输入一个累加。与之类似，使用 \\prod \\bigcup \\bigcap 来分别输入累乘、并集和交集。此类符号在行内显示时上下标表达式将会移至右上角和右下角。 例：1$$\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} R$$ $$\\sum_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\prod_{i=1}^n \\frac{1}{i^2} \\quad and \\quad \\bigcup_{i=1}^{2} R$$ 希腊字母输入 \\小写希腊字母英文全称 和 \\首字母大写希腊字母英文全称 来分别输入小写和大写希腊字母。对于大写希腊字母与现有字母相同的，直接输入大写字母即可。 输入 显示 输入 显示 输入 显示 输入 显示 \\alpha $\\alpha$ A $A$ \\beta $\\beta$ B $B$ \\gamma $\\gamma$ \\Gamma $\\Gamma$ \\delta $\\delta$ \\Delta $\\Delta$ \\epsilon $\\epsilon$ E $E$ \\zeta $\\zeta$ Z $Z$ \\eta $\\eta$ H $H$ \\theta $\\theta$ \\Theta $\\Theta$ \\iota $\\iota$ I $I$ \\kappa $\\kappa$ K $K$ \\lambda $\\lambda$ \\Lambda $\\Lambda$ \\mu $\\mu$ M $M$ \\nu $\\nu$ N $N$ \\xi $\\xi$ \\Xi $\\Xi$ o $o$ O $O$ \\pi $\\pi$ \\Pi $\\Pi$ \\rho $\\rho$ P $P$ \\sigma $\\sigma$ \\Sigma $\\Sigma$ \\tau $\\tau$ T $T$ \\upsilon $\\upsilon$ \\Upsilon $\\Upsilon$ \\phi $\\phi$ \\Phi $\\Phi$ \\chi $\\chi$ X $X$ \\psi $\\psi$ \\Psi $\\Psi$ \\omega $\\omega$ \\Omega $\\Omega$ 部分字母有变量专用形式，以 \\var- 开头。 小写形式 大写形式 变量形式 显示 \\epsilon E \\varepsilon $\\epsilon \\mid E \\mid \\varepsilon$ \\theta \\Theta \\vartheta $\\theta \\mid \\Theta \\mid \\vartheta$ \\rho P \\varrho $\\rho \\mid P \\mid \\varrho$ \\sigma \\Sigma \\varsigma $\\sigma \\mid \\Sigma \\mid \\varsigma$ \\phi \\Phi \\varphi $\\phi \\mid \\Phi \\mid \\varphi$ 其他特殊字符若需要显示更大或更小的字符，在符号前插入 \\large 或 \\small 命令。 若找不到需要的符号，使用$\\rm{Detexify^2}$来画出想要的符号。 (1) 关系运算符 输入 显示 输入 显示 输入 显示 输入 显示 \\pm $\\pm$ \\times $\\times$ \\div $\\div$ \\mid $\\mid$ \\nmid $\\nmid$ \\cdot $\\cdot$ \\circ $\\circ$ \\ast $\\ast$ \\bigodot $\\bigodot$ \\bigotimes $\\bigotimes$ \\bigoplus $\\bigoplus$ \\leq $\\leq$ \\geq $\\geq$ \\neq $\\neq$ \\approx $\\approx$ \\equiv $\\equiv$ \\sum $\\sum$ \\prod $\\prod$ \\coprod $\\coprod$ \\backslash $\\backslash$ (2) 集合运算符 输入 显示 输入 显示 输入 显示 \\emptyset $\\emptyset$ \\in $\\in$ \\notin $\\notin$ \\subset $\\subset$ \\supset $\\supset$ \\subseteq $\\subseteq$ \\supseteq $\\supseteq$ \\bigcap $\\bigcap$ \\bigcup $\\bigcup$ \\bigvee $\\bigvee$ \\bigwedge $\\bigwedge$ \\biguplus $\\biguplus$ (3) 对数运算符 输入 显示 输入 显示 输入 显示 \\log $\\log$ \\lg $\\lg$ \\ln $\\ln$ (4) 三角运算符 输入 显示 输入 显示 输入 显示 30^\\circ $30^\\circ$ \\bot $\\bot$ \\angle A $\\angle A$ \\sin $\\sin$ \\cos $\\cos$ \\tan $\\tan$ \\csc $\\csc$ \\sec $\\sec$ \\cot $\\cot$ (5) 微积分运算符 输入 显示 输入 显示 输入 显示 \\int $\\int$ \\iint $\\iint$ \\iiint $\\iiint$ \\iiiint $\\iiiint$ \\oint $\\oint$ \\prime $\\prime$ \\lim $\\lim$ \\infty $\\infty$ \\nabla $\\nabla$ (6) 逻辑运算符 输入 显示 输入 显示 输入 显示 \\because $\\because$ \\therefore $\\therefore$ \\forall $\\forall$ \\exists $\\exists$ \\not\\subset $\\not\\subset$ \\not&lt; $\\not&lt;$ \\not&gt; $\\not&gt;$ \\not= $\\not=$ (7) 戴帽符号 输入 显示 输入 显示 \\hat{xy} $\\hat{xy}$ \\widehat{xyz} $\\widehat{xyz}$ \\tilde{xy} $\\tilde{xy}$ \\widetilde{xyz} $\\widetilde{xyz}$ \\check{x} $\\check{x}$ \\breve{y} $\\breve{y}$ \\grave{x} $\\grave{x}$ \\acute{y} $\\acute{y}$ (8) 连线符号 输入 显示 \\fbox{a+b+c+d} $\\fbox{a+b+c+d}$ \\overleftarrow{a+b+c+d} $\\overleftarrow{a+b+c+d}$ \\overrightarrow{a+b+c+d} $\\overrightarrow{a+b+c+d}$ \\overleftrightarrow{a+b+c+d} $\\overleftrightarrow{a+b+c+d}$ \\underleftarrow{a+b+c+d} $\\underleftarrow{a+b+c+d}$ \\underrightarrow{a+b+c+d} $\\underrightarrow{a+b+c+d}$ \\underleftrightarrow{a+b+c+d} $\\underleftrightarrow{a+b+c+d}$ \\overline{a+b+c+d} $\\overline{a+b+c+d}$ \\underline{a+b+c+d} $\\underline{a+b+c+d}$ \\overbrace{a+b+c+d}^{Sample} $\\overbrace{a+b+c+d}^{Sample}$ \\underbrace{a+b+c+d}_{Sample} $\\underbrace{a+b+c+d}_{Sample}$ \\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0} $\\overbrace{a+\\underbrace{b+c}_{1.0}+d}^{2.0}$ \\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}} $\\underbrace{a\\cdot a\\cdots a}_{b\\text{ times}}$ (9) 箭头符号 推荐使用符号： 输入 显示 输入 显示 输入 显示 \\to $\\to$ \\mapsto $\\mapsto$ \\implies $\\implies$ \\iff $\\iff$ \\impliedby $\\impliedby$ 其它可用符号： 输入 显示 输入 显示 \\uparrow $\\uparrow$ \\Uparrow $\\Uparrow$ \\downarrow $\\downarrow$ \\Downarrow $\\Downarrow$ \\leftarrow $\\leftarrow$ \\Leftarrow $\\Leftarrow$ \\rightarrow $\\rightarrow$ \\Rightarrow $\\Rightarrow$ \\leftrightarrow $\\leftrightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\longleftarrow $\\longleftarrow$ \\Longleftarrow $\\Longleftarrow$ \\longrightarrow $\\longrightarrow$ \\Longrightarrow $\\Longrightarrow$ \\longleftrightarrow $\\longleftrightarrow$ \\Longleftrightarrow $\\Longleftrightarrow$ 字体转换若要对公式的某一部分字符进行字体转换，可以用 {\\字体 {需转换的部分字符}} 命令，其中 \\字体 部分可以参照下表选择合适的字体。一般情况下，公式默认为意大利体 。 示例中 全部大写 的字体仅大写可用。 输入 说明 显示 输入 说明 显示 \\rm 罗马体 $\\rm{Sample}$ \\cal 花体 $\\cal{Sample}$ \\it 意大利体 $\\it{Sample}$ \\Bbb 黑板粗体 $\\Bbb{Sample}$ \\bf 粗体 $\\bf{Sample}$ \\mit 数学斜体 $\\mit{Sample}$ \\sf 等线体 $\\sf{Sample}$ \\scr 手写体 $\\scr{Sample}$ \\tt 打字机体 $\\tt{Sample}$ \\frak 旧德式字体 $\\frak{Sample}$ 转换字体十分常用，例如在积分中： 例：1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int_0^1 x^2 dx &amp; \\int_0^1 x^2 \\,{\\rm d}x\\end{array}$$ 注意比较两个式子间$dx$与${\\rm d}x$的不同。使用 \\operatorname 命令也可以达到相同的效果，详见 定义新的符号 \\operatorname 定义新的符号 \\operatorname) 。 大括号和行标的使用使用 \\left 和 \\right 来创建自动匹配高度的 (圆括号)，[方括号] 和 {花括号} 。在每个公式末尾前使用 \\tag{行标} 来实现行标。 例：123456789101112131415$$f\\left( \\left[ \\frac{ 1+\\left\\{x,y\\right\\} }{ \\left( \\frac{x}{y}+\\frac{y}{x} \\right) \\left(u+1\\right) }+a \\right]^{3/2}\\right)\\tag{行标}$$ $$f\\left( \\left[ \\frac{ 1+\\left\\{x,y\\right\\} }{ \\left( \\frac{x}{y}+\\frac{y}{x} \\right) \\left(u+1\\right) }+a \\right]^{3/2}\\right)\\tag{行标}$$ 如果你需要在不同的行显示对应括号，可以在每一行对应处使用 \\left. 或 \\right. 来放一个”影子”括号： 例：123456$$\\begin{aligned}a=&amp;\\left(1+2+3+ \\cdots \\right. \\\\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end{aligned}$$ $$\\begin{aligned}a=&amp;\\left(1+2+3+ \\cdots \\right. \\&amp; \\cdots+ \\left. \\infty-2+\\infty-1+\\infty\\right)\\end{aligned}$$ 如果你需要将行内显示的分隔符也变大，可以使用 \\middle 命令： 例：123456789$$\\left\\langle q\\middle\\| \\frac{\\frac{x}{y}}{\\frac{u}{v}}\\middle| p \\right\\rangle$$ $$\\left\\langle q\\middle| \\frac{\\frac{x}{y}}{\\frac{u}{v}}\\middle| p\\right\\rangle$$ 其他命令(1) 定义新的符号 \\operatorname查询 关于此命令的定义 和 关于此命令的讨论 来进一步了解此命令。 例：：1$$ \\operatorname{Symbol} A $$ $$ \\operatorname{Symbol} A $$ (2) 添加注释文字 \\text在 \\text {文字} 中仍可以使用 $公式$ 插入其它公式。 例：：1$$ f(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} $$ $$ f(n)= \\begin{cases} n/2, &amp; \\text {if $n$ is even} \\\\ 3n+1, &amp; \\text{if $n$ is odd} \\end{cases} $$ (3) 在字符间加入空格有四种宽度的空格可以使用： \\,、\\;、\\quad 和 \\qquad 。 例：：1$$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$ $$ a \\, b \\mid a \\; b \\mid a \\quad b \\mid a \\qquad b $$ 当然，使用 \\text {n个空格} 也可以达到同样效果。 (4) 更改文字颜色使用 \\color{颜色}{文字} 来更改特定的文字颜色。更改文字颜色 需要浏览器支持 ，如果浏览器不知道你所需的颜色，那么文字将被渲染为黑色。 对于较旧的浏览器（HTML4与CSS2），以下颜色是被支持的： 输入 显示 输入 显示 black $\\color{black}{text}$ grey $\\color{grey}{text}$ silver $\\color{silver}{text}$ white $\\color{white}{text}$ maroon $\\color{maroon}{text}$ red $\\color{red}{text}$ yellow $\\color{yellow}{text}$ lime $\\color{lime}{text}$ olive $\\color{olive}{text}$ green $\\color{green}{text}$ teal $\\color{teal}{text}$ auqa $\\color{auqa}{text}$ blue $\\color{blue}{text}$ navy $\\color{navy}{text}$ purple $\\color{purple}{text}$ fuchsia $\\color{fuchsia}{text}$ 对于较新的浏览器（HTML5与CSS3），额外的124种颜色将被支持： 输入 \\color #rgb text 来自定义更多的颜色，其中 #rgb 的 r g b 可输入 0-9 和 a-f 来表示红色、绿色和蓝色的纯度（饱和度）。 例：：12345678910111213$$\\begin{array}{|rrrrrrrr|}\\hline\\verb+#000+ &amp; \\color{#000}{text} &amp; &amp; &amp;\\verb+#00F+ &amp; \\color{#00F}{text} &amp; &amp; \\\\&amp; &amp; \\verb+#0F0+ &amp; \\color{#0F0}{text} &amp;&amp; &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\\\verb+#F00+ &amp; \\color{#F00}{text} &amp; &amp; &amp;\\verb+#F0F+ &amp; \\color{#F0F}{text} &amp; &amp; \\\\&amp; &amp; \\verb+#FF0+ &amp; \\color{#FF0}{text} &amp;&amp; &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\\\hline\\end{array}$$ 例：： 1234567891011121314151617181920$$\\begin{array}{|rrrrrrrr|}\\hline\\verb+#000+ &amp; \\color{#000}{text} &amp; \\verb+#005+ &amp; \\color{#005}{text} &amp; \\verb+#00A+ &amp; \\color{#00A}{text} &amp; \\verb+#00F+ &amp; \\color{#00F}{text} \\\\\\verb+#500+ &amp; \\color{#500}{text} &amp; \\verb+#505+ &amp; \\color{#505}{text} &amp; \\verb+#50A+ &amp; \\color{#50A}{text} &amp; \\verb+#50F+ &amp; \\color{#50F}{text} \\\\\\verb+#A00+ &amp; \\color{#A00}{text} &amp; \\verb+#A05+ &amp; \\color{#A05}{text} &amp; \\verb+#A0A+ &amp; \\color{#A0A}{text} &amp; \\verb+#A0F+ &amp; \\color{#A0F}{text} \\\\\\verb+#F00+ &amp; \\color{#F00}{text} &amp; \\verb+#F05+ &amp; \\color{#F05}{text} &amp; \\verb+#F0A+ &amp; \\color{#F0A}{text} &amp; \\verb+#F0F+ &amp; \\color{#F0F}{text} \\\\\\hline\\verb+#080+ &amp; \\color{#080}{text} &amp; \\verb+#085+ &amp; \\color{#085}{text} &amp; \\verb+#08A+ &amp; \\color{#08A}{text} &amp; \\verb+#08F+ &amp; \\color{#08F}{text} \\\\\\verb+#580+ &amp; \\color{#580}{text} &amp; \\verb+#585+ &amp; \\color{#585}{text} &amp; \\verb+#58A+ &amp; \\color{#58A}{text} &amp; \\verb+#58F+ &amp; \\color{#58F}{text} \\\\\\verb+#A80+ &amp; \\color{#A80}{text} &amp; \\verb+#A85+ &amp; \\color{#A85}{text} &amp; \\verb+#A8A+ &amp; \\color{#A8A}{text} &amp; \\verb+#A8F+ &amp; \\color{#A8F}{text} \\\\\\verb+#F80+ &amp; \\color{#F80}{text} &amp; \\verb+#F85+ &amp; \\color{#F85}{text} &amp; \\verb+#F8A+ &amp; \\color{#F8A}{text} &amp; \\verb+#F8F+ &amp; \\color{#F8F}{text} \\\\\\hline\\verb+#0F0+ &amp; \\color{#0F0}{text} &amp; \\verb+#0F5+ &amp; \\color{#0F5}{text} &amp; \\verb+#0FA+ &amp; \\color{#0FA}{text} &amp; \\verb+#0FF+ &amp; \\color{#0FF}{text} \\\\\\verb+#5F0+ &amp; \\color{#5F0}{text} &amp; \\verb+#5F5+ &amp; \\color{#5F5}{text} &amp; \\verb+#5FA+ &amp; \\color{#5FA}{text} &amp; \\verb+#5FF+ &amp; \\color{#5FF}{text} \\\\\\verb+#AF0+ &amp; \\color{#AF0}{text} &amp; \\verb+#AF5+ &amp; \\color{#AF5}{text} &amp; \\verb+#AFA+ &amp; \\color{#AFA}{text} &amp; \\verb+#AFF+ &amp; \\color{#AFF}{text} \\\\\\verb+#FF0+ &amp; \\color{#FF0}{text} &amp; \\verb+#FF5+ &amp; \\color{#FF5}{text} &amp; \\verb+#FFA+ &amp; \\color{#FFA}{text} &amp; \\verb+#FFF+ &amp; \\color{#FFF}{text} \\\\\\hline\\end{array}$$ (5) 添加删除线使用删除线功能必须声明 $$ 符号。 在公式内使用 \\require{cancel} 来允许 片段删除线 的显示。声明片段删除线后，使用 \\cancel{字符}、\\bcancel{字符}、\\xcancel{字符} 和 \\cancelto{字符} 来实现各种片段删除线效果。 例：：12345678910$$\\require{cancel}\\begin{array}{rl}\\verb|y+\\cancel{x}| &amp; y+\\cancel{x} \\\\\\verb|\\cancel{y+x}| &amp; \\cancel{y+x} \\\\\\verb|y+\\bcancel{x}| &amp; y+\\bcancel{x} \\\\\\verb|y+\\xcancel{x}| &amp; y+\\xcancel{x} \\\\\\verb|y+\\cancelto{0}{x}| &amp; y+\\cancelto{0}{x} \\\\\\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+&amp; \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\\\end{array}$$ $$\\require{cancel}\\begin{array}{rl}\\verb|y+\\cancel{x}| &amp; y+\\cancel{x} \\\\\\verb|\\cancel{y+x}| &amp; \\cancel{y+x} \\\\\\verb|y+\\bcancel{x}| &amp; y+\\bcancel{x} \\\\\\verb|y+\\xcancel{x}| &amp; y+\\xcancel{x} \\\\\\verb|y+\\cancelto{0}{x}| &amp; y+\\cancelto{0}{x} \\\\\\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+&amp; \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\\\end{array}$$ 使用 \\require{enclose} 来允许 整段删除线 的显示。声明整段删除线后，使用 \\enclose{删除线效果}{字符} 来实现各种整段删除线效果。其中，删除线效果有 horizontalstrike、verticalstrike、updiagonalstrike 和 downdiagonalstrike，可叠加使用。 例：：12345678910$$\\require{enclose}\\begin{array}{rl}\\verb|\\enclose{horizontalstrike}{x+y}| &amp; \\enclose{horizontalstrike}{x+y}\\\\\\verb|\\enclose{verticalstrike}{\\frac xy}| &amp; \\enclose{verticalstrike}{\\frac xy}\\\\\\verb|\\enclose{updiagonalstrike}{x+y}| &amp; \\enclose{updiagonalstrike}{x+y}\\\\\\verb|\\enclose{downdiagonalstrike}{x+y}| &amp; \\enclose{downdiagonalstrike}{x+y}\\\\\\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\\\end{array}$$ $$\\require{enclose}\\begin{array}{rl}\\verb|\\enclose{horizontalstrike}{x+y}| &amp; \\enclose{horizontalstrike}{x+y}\\\\\\verb|\\enclose{verticalstrike}{\\frac xy}| &amp; \\enclose{verticalstrike}{\\frac xy}\\\\\\verb|\\enclose{updiagonalstrike}{x+y}| &amp; \\enclose{updiagonalstrike}{x+y}\\\\\\verb|\\enclose{downdiagonalstrike}{x+y}| &amp; \\enclose{downdiagonalstrike}{x+y}\\\\\\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\\\end{array}$$此外， \\enclose 命令还可以产生包围的边框和圆等，参见 MathML Menclose Documentation 以查看更多效果。 二、矩阵使用参考无框矩阵在开头使用 begin{matrix}，在结尾使用 end{matrix}，在中间插入矩阵元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。使用矩阵时必须声明 $ 或 $$ 符号。 例：：1234567$$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix} $$ $$\\begin{matrix}1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end{matrix}$$ 边框矩阵在开头将 matrix 替换为 pmatrix bmatrix Bmatrix vmatrix Vmatrix 。 例：：123456$ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $$ \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{pmatrix} $$ \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{bmatrix} $$ \\begin{Bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Bmatrix} $$ \\begin{vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{vmatrix} $$ \\begin{Vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Vmatrix} $ matrix pmatrix bmatrix Bmatrix vmatrix Vmatrix $ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $ $ \\begin{pmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{pmatrix} $ $ \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{bmatrix} $ $ \\begin{matrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{matrix} $ $ \\begin{vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{vmatrix} $ $ \\begin{Vmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ \\end{Vmatrix} $ 带省略符号的矩阵使用 \\cdots , \\ddots , \\vdots 来输入省略符号。 例：：12345678$$\\begin{pmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\\\end{pmatrix}$$ $$\\begin{pmatrix}1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\\\\\end{pmatrix}$$ 带分割符号的矩阵详见”数组使用参考“。 例：：12345678$$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array}\\right]$$ $$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\\\ 4&amp;5&amp;6 \\end{array}\\right]$$ 其中 cc|c 代表在一个三列矩阵中的第二和第三列之间插入分割线。 行中矩阵若想在一行内显示矩阵，使用\\bigl(\\begin{smallmatrix} ... \\end{smallmatrix}\\bigr)。 例：：1这是一个行中矩阵的示例 $\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)$ 。 这是一个行中矩阵的示例 $\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)$ 。 三、方程式序列使用参考方程式序列人们经常想要一列整齐且居中的方程式序列。使用 \\begin{align}…\\end{align} 来创造一列方程式，其中在每行结尾处使用 \\\\ 。使用方程式序列无需声明公式符号 $ 或 $$ 。 请注意 {align} 语句是 自动编号 的。 例：：123456789$$\\begin{align}\\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ &amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ &amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\&amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}$$ $$\\begin{align}\\sqrt{37} &amp; = \\sqrt{\\frac{73^2-1}{12^2}} \\\\&amp; = \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\&amp; = \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\&amp; = \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\&amp; \\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right)\\end{align}$$ 本例中每行公式的编号续自 如何插入公式 中的自动编号公式 。 在一个方程式序列的每一行中注明原因在 {align} 中灵活组合 \\text 和 \\tag 语句。\\tag 语句编号优先级高于自动编号。 例：：1234567$$\\begin{align} v + w &amp; = 0 &amp;\\text{Given} \\tag 1\\\\ -w &amp; = -w + 0 &amp; \\text{additive identity} \\tag 2\\\\ -w + 0 &amp; = -w + (v + w) &amp; \\text{equations $(1)$ and $(2)$} \\end{align}$$ $$\\begin{align}v + w &amp; = 0 &amp;\\text{Given} \\tag 1\\\\-w &amp; = -w + 0 &amp; \\text{additive identity} \\tag 2\\\\-w + 0 &amp; = -w + (v + w) &amp; \\text{equations $(1)$ and $(2)$}\\end{align}$$ 本例中第一、第二行的自动编号被 \\tag 语句覆盖，第三行的编号为自动编号。 四、条件表达式使用参考条件表达式使用 begin{cases} 来创造一组条件表达式，在每一行条件中插入 &amp; 来指定需要对齐的内容，并在每一行结尾处使用 \\\\，以 end{cases} 结束。条件表达式无需声明 $ 或 $$ 符号。 例：：1234567$$f(n) = \\begin{cases}n/2, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd} \\end{cases}$$ $$f(n) =\\begin{cases}n/2, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 左侧对齐的条件表达式若想让文字在 左侧对齐显示 ，则有如下方式： 例：：123456789$$\\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n/2\\\\\\text{if $n$ is odd:}&amp;3n+1\\end{array} \\right\\} =f(n)$$ $$\\left.\\begin{array}{l}\\text{if $n$ is even:}&amp;n/2\\\\\\text{if $n$ is odd:}&amp;3n+1\\end{array}\\right\\}=f(n)$$ 使条件表达式适配行高在一些情况下，条件表达式中某些行的行高为非标准高度，此时使用 \\\\[2ex] 语句代替该行末尾的 \\\\ 来让编辑器适配。 例：： 不适配[2ex]1234567$$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 适配[2ex]1234567$$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex]3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 不适配[2ex] $$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 适配[2ex] $$f(n) = \\begin{cases}\\frac{n}{2}, &amp; \\text{if $n$ is even} \\\\[2ex]3n+1, &amp; \\text{if $n$ is odd}\\end{cases}$$ 一个 [ex] 指一个 “X-Height”，即x字母高度。可以根据情况指定多个 [ex]，如 [3ex]、[4ex] 等。其实可以在任何地方使用 \\\\[2ex] 语句，只要你觉得合适。 五、数组与表格使用参考数组或表格通常，一个格式化后的表格比单纯的文字或排版后的文字更具有可读性。数组和表格均以 begin{array} 开头，并在其后定义列数及每一列的文本对齐属性，c l r 分别代表居中、左对齐及右对齐。若需要插入垂直分割线，在定义式中插入 | ，若要插入水平分割线，在下一行输入前插入 \\hline 。与矩阵相似，每行元素间均须要插入 &amp; ，每行元素以 \\\\ 结尾，最后以 end{array} 结束数组。使用单个数组或表格时无需声明 $ 或 $$ 符号。 例：：123456789$$\\begin{array}{c|lcr}n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i\\end{array}$$ $$\\begin{array}{c|lcr}n &amp; \\text{左对齐} &amp; \\text{居中对齐} &amp; \\text{右对齐} \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i\\end{array}$$ 嵌套的数组或表格多个数组/表格可 互相嵌套 并组成一组数组/一组表格。使用嵌套前必须声明 $$ 符号。 例：：123456789101112131415161718192021222324252627282930313233343536373839$$% outer vertical array of arrays 外层垂直表格\\begin{array}{c} % inner horizontal array of arrays 内层水平表格 \\begin{array}{cc} % inner array of minimum values 内层&quot;最小值&quot;数组 \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; % inner array of maximum values 内层&quot;最大值&quot;数组 \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} % 内层第一行表格组结束 \\\\ % inner array of delta values 内层第二行Delta值数组 \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array} % 内层第二行表格组结束\\end{array}$$ $$\\begin{array}{c} \\begin{array}{cc} \\begin{array}{c|cccc} \\text{min} &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ \\hline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1\\\\ 2 &amp; 0 &amp; 1 &amp; 2 &amp; 2\\\\ 3 &amp; 0 &amp; 1 &amp; 2 &amp; 3 \\end{array} &amp; \\begin{array}{c|cccc} \\text{max}&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 1 &amp; 2 &amp; 3\\\\ 2 &amp; 2 &amp; 2 &amp; 2 &amp; 3\\\\ 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\end{array} \\end{array} \\\\ \\begin{array}{c|cccc} \\Delta&amp;0&amp;1&amp;2&amp;3\\\\ \\hline 0 &amp; 0 &amp; 1 &amp; 2 &amp; 3\\\\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 2\\\\ 2 &amp; 2 &amp; 1 &amp; 0 &amp; 1\\\\ 3 &amp; 3 &amp; 2 &amp; 1 &amp; 0 \\end{array}\\end{array}$$ 方程组使用 \\begin{array}…\\end{array} 和 \\left\\{…\\right. 来创建一个方程组。 例：：123456789$$\\left\\{ \\begin{array}{c}a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end{array}\\right. $$ $$\\left\\{\\begin{array}{c}a_1x+b_1y+c_1z=d_1 \\\\a_2x+b_2y+c_2z=d_2 \\\\a_3x+b_3y+c_3z=d_3\\end{array}\\right.$$ 或者使用条件表达式组 \\begin{cases}…\\end{cases} 来实现相同效果： 例：：1234567$$\\begin{cases}a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end{cases}$$ $$\\begin{cases}a_1x+b_1y+c_1z=d_1 \\\\a_2x+b_2y+c_2z=d_2 \\\\a_3x+b_3y+c_3z=d_3\\end{cases}$$ 六、连分数使用参考连分式就像输入分式时使用 \\frac 一样，使用 \\cfrac 来创建一个连分数。 例：： 12345$$x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}}$$ $$x = a_0 + \\cfrac{1^2}{a_1+ \\cfrac{2^2}{a_2+ \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}}$$ 不要使用普通的 \\frac 或 \\over 来创建，否则会看起来 很恶心 。 反例：： 12345$$x = a_0 + \\frac{1^2}{a_1+ \\frac{2^2}{a_2+ \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}}$$ $$x = a_0 + \\frac{1^2}{a_1+ \\frac{2^2}{a_2+ \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}}$$ 当然，你可以使用 \\frac 来表达连分数的 紧缩记法 。 例：： 12345$$x = a_0 + \\frac{1^2}{a_1+} \\frac{2^2}{a_2+} \\frac{3^2}{a_3 +} \\frac{4^4}{a_4 +} \\cdots$$ $$x = a_0 + \\frac{1^2}{a_1+}\\frac{2^2}{a_2+}\\frac{3^2}{a_3 +} \\frac{4^4}{a_4 +} \\cdots$$ 连分数通常都太大以至于不易排版，所以建议在连分数前后声明 $$ 符号，或使用像 [a0;a1,a2,a3,…] 一样的紧缩记法。 七、交换图表使用参考交换图表使用一行 $ \\require{AMScd} $ 语句来允许交换图表的显示。声明交换图表后，语法与矩阵相似，在开头使用 begin{CD}，在结尾使用 end{CD}，在中间插入图表元素，每个元素之间插入 &amp; ，并在每行结尾处使用 \\\\ 。 例：： 123456$\\require{AMScd}$\\begin{CD} A @&gt;&gt;&gt; B\\\\ @VVV @VVV\\\\ C @&gt;&gt;&gt; D\\end{CD} $$$\\require{AMScd}$\\begin{CD}A @&gt;&gt;&gt; B\\\\@VVV @VVV\\\\C @&gt;&gt;&gt; D\\end{CD}$$ 其中，@&gt;&gt;&gt; 代表右箭头、@&lt;&lt;&lt; 代表左箭头、@VVV 代表下箭头、@AAA 代表上箭头、@= 代表水平双实线、@| 代表竖直双实线、@.代表没有箭头。在 @&gt;&gt;&gt; 的 &gt;&gt;&gt; 之间任意插入文字即代表该箭头的注释文字。 例：： 1234567$$\\begin{CD} A @&gt;&gt;&gt; B @&gt;{\\text{very long label}}&gt;&gt; C \\\\ @. @AAA @| \\\\ D @= E @&lt;&lt;&lt; F\\end{CD}$$ $$\\begin{CD}A @&gt;&gt;&gt; B @&gt;{\\text{very long label}}&gt;&gt; C \\\\@. @AAA @| \\\\D @= E @&lt;&lt;&lt; F\\end{CD}$$ 在本例中， “very long label”自动延长了它所在箭头以及对应箭头的长度。 八、一些特殊的注意事项 These are issues that won’t affect the correctness of formulas, but might make them look significantly better or worse. Beginners should feel free to ignore this advice; someone else will correct it for them, or more likely nobody will care. 现在指出的小问题并不会影响方程式及公式等的正确显示，但能让它们看起来明显更好看。初学者可无视这些建议，自然会有强迫症患者替你们改掉它的，或者更可能地，根本没人发现这些问题。 Don’t use \\frac in exponents or limits of integrals; it looks bad and can be confusing, which is why it is rarely done in professional mathematical typesetting. Write the fraction horizontally, with a slash. 在以e为底的指数函数、极限和积分中尽量不要使用 \\frac 符号：它会使整段函数看起来很怪，而且可能产生歧义。也正是因此它在专业数学排版中几乎从不出现。横着写这些分式，中间使用斜线间隔 / （用斜线代替分数线）。 例：： 12345678$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\\\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\\\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\\\end{array}$$ The | symbol has the wrong spacing when it is used as a divider, for example in set comprehensions. Use \\mid instead. | 符号在被当作分隔符时会产生错误的间隔，因此在需要分隔时最好使用 \\mid 来代替它。 例：： 1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\{x|x^2\\in\\Bbb Z\\} &amp; \\{x\\mid x^2\\in\\Bbb Z\\} \\\\\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\{x|x^2\\in\\Bbb Z\\} &amp; \\{x\\mid x^2\\in\\Bbb Z\\} \\\\\\end{array}$$ For double and triple integrals, don’t use \\int\\int or \\int\\int\\int. Instead use the special forms \\iint and \\iiint. 使用多重积分符号时，不要多次使用 \\int 来声明，直接使用 \\iint 来表示 二重积分 ，使用 \\iiint 来表示 三重积分等。对于无限次积分，可以用 \\int \\cdots \\int 表示。 例：： 12345678$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int\\int_S f(x)\\,dy\\,dx &amp; \\iint_S f(x)\\,dy\\,dx \\\\\\int\\int\\int_V f(x)\\,dz\\,dy\\,dx &amp; \\iiint_V f(x)\\,dz\\,dy\\,dx\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\int\\int_S f(x)\\,dy\\,dx &amp; \\iint_S f(x)\\,dy\\,dx \\\\\\int\\int\\int_V f(x)\\,dz\\,dy\\,dx &amp; \\iiint_V f(x)\\,dz\\,dy\\,dx\\end{array}$$ 无限次积分： Use \\,, to insert a thin space before differentials; without this will mash them together. 在微分符号前加入 \\, 来插入一个小的间隔空隙；没有 \\, 符号的话， 将会把不同的微分符号堆在一起。 例：： 1234567$$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\\\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x &amp; \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x\\end{array}$$ $$\\begin{array}{cc}\\mathrm{Bad} &amp; \\mathrm{Better} \\\\\\hline \\\\iiint_V f(x){\\rm d}z {\\rm d}y {\\rm d}x &amp; \\iiint_V f(x)\\,{\\rm d}z\\,{\\rm d}y\\,{\\rm d}x\\end{array}$$ ReferenceCmd Markdown 简明语法手册","link":"/2018/02/26/Write-Markdown-with-Formulas/"}],"tags":[{"name":"BoP2016","slug":"BoP2016","link":"/tags/BoP2016/"},{"name":"Configuration","slug":"Configuration","link":"/tags/Configuration/"},{"name":"WPF","slug":"WPF","link":"/tags/WPF/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"}],"categories":[{"name":"Creative","slug":"Creative","link":"/categories/Creative/"},{"name":"Basic","slug":"Basic","link":"/categories/Basic/"},{"name":"DanmakuPie","slug":"DanmakuPie","link":"/categories/DanmakuPie/"}]}